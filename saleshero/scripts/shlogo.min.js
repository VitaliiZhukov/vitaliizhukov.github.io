/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 83);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

    "use strict";
    
    
    exports.__esModule = true;
    /**
     * String of the current PIXI version.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @name VERSION
     * @type {string}
     */
    var VERSION = exports.VERSION = '2.9.3';
    
    /**
     * Two Pi.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @type {number}
     */
    var PI_2 = exports.PI_2 = Math.PI * 2;
    
    /**
     * Conversion factor for converting radians to degrees.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @type {number}
     */
    var RAD_TO_DEG = exports.RAD_TO_DEG = 180 / Math.PI;
    
    /**
     * Conversion factor for converting degrees to radians.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @type {number}
     */
    var DEG_TO_RAD = exports.DEG_TO_RAD = Math.PI / 180;
    
    /**
     * Constant to identify the Renderer Type.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @name RENDERER_TYPE
     * @type {object}
     * @property {number} UNKNOWN - Unknown render type.
     * @property {number} WEBGL - WebGL render type.
     * @property {number} CANVAS - Canvas render type.
     */
    var RENDERER_TYPE = exports.RENDERER_TYPE = {
      UNKNOWN: 0,
      WEBGL: 1,
      CANVAS: 2
    };
    
    /**
     * Various blend modes supported by PIXI.
     *
     * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
     * Anything else will silently act like NORMAL.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @name BLEND_MODES
     * @type {object}
     * @property {number} NORMAL
     * @property {number} ADD
     * @property {number} MULTIPLY
     * @property {number} SCREEN
     * @property {number} OVERLAY
     * @property {number} DARKEN
     * @property {number} LIGHTEN
     * @property {number} COLOR_DODGE
     * @property {number} COLOR_BURN
     * @property {number} HARD_LIGHT
     * @property {number} SOFT_LIGHT
     * @property {number} DIFFERENCE
     * @property {number} EXCLUSION
     * @property {number} HUE
     * @property {number} SATURATION
     * @property {number} COLOR
     * @property {number} LUMINOSITY
     */
    var BLEND_MODES = exports.BLEND_MODES = {
      NORMAL: 0,
      ADD: 1,
      MULTIPLY: 2,
      SCREEN: 3,
      OVERLAY: 4,
      DARKEN: 5,
      LIGHTEN: 6,
      COLOR_DODGE: 7,
      COLOR_BURN: 8,
      HARD_LIGHT: 9,
      SOFT_LIGHT: 10,
      DIFFERENCE: 11,
      EXCLUSION: 12,
      HUE: 13,
      SATURATION: 14,
      COLOR: 15,
      LUMINOSITY: 16
    };
    
    /**
     * Various webgl draw modes. These can be used to specify which GL drawMode to use
     * under certain situations and renderers.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @name DRAW_MODES
     * @type {object}
     * @property {number} POINTS
     * @property {number} LINES
     * @property {number} LINE_LOOP
     * @property {number} LINE_STRIP
     * @property {number} TRIANGLES
     * @property {number} TRIANGLE_STRIP
     * @property {number} TRIANGLE_FAN
     */
    var DRAW_MODES = exports.DRAW_MODES = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };
    
    /**
     * The scale modes that are supported by pixi.
     *
     * The {@link PIXI.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.
     * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @name SCALE_MODES
     * @type {object}
     * @property {number} LINEAR Smooth scaling
     * @property {number} NEAREST Pixelating scaling
     */
    var SCALE_MODES = exports.SCALE_MODES = {
      LINEAR: 0,
      NEAREST: 1
    };
    
    /**
     * The wrap modes that are supported by pixi.
     *
     * The {@link PIXI.settings.WRAP_MODE} wrap mode affects the default wraping mode of future operations.
     * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.
     * If the texture is non power of two then clamp will be used regardless as webGL can
     * only use REPEAT if the texture is po2.
     *
     * This property only affects WebGL.
     *
     * @static
     * @constant
     * @name WRAP_MODES
     * @memberof PIXI
     * @type {object}
     * @property {number} CLAMP - The textures uvs are clamped
     * @property {number} REPEAT - The texture uvs tile and repeat
     * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring
     */
    var WRAP_MODES = exports.WRAP_MODES = {
      CLAMP: 0,
      REPEAT: 1,
      MIRRORED_REPEAT: 2
    };
    
    /**
     * The gc modes that are supported by pixi.
     *
     * The {@link PIXI.settings.GC_MODE} Garbage Collection mode for pixi textures is AUTO
     * If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
     * used for a specified period of time they will be removed from the GPU. They will of course
     * be uploaded again when they are required. This is a silent behind the scenes process that
     * should ensure that the GPU does not  get filled up.
     *
     * Handy for mobile devices!
     * This property only affects WebGL.
     *
     * @static
     * @constant
     * @name GC_MODES
     * @memberof PIXI
     * @type {object}
     * @property {number} AUTO - Garbage collection will happen periodically automatically
     * @property {number} MANUAL - Garbage collection will need to be called manually
     */
    var GC_MODES = exports.GC_MODES = {
      AUTO: 0,
      MANUAL: 1
    };
    
    /**
     * Regexp for image type by extension.
     *
     * @static
     * @constant
     * @memberof PIXI
     * @type {RegExp|string}
     * @example `image.png`
     */
    var URL_FILE_EXTENSION = exports.URL_FILE_EXTENSION = /\.(\w{3,4})(?:$|\?|#)/i;
    
    /**
     * Regexp for data URI.
     * Based on: {@link https://github.com/ragingwind/data-uri-regex}
     *
     * @static
     * @constant
     * @name DATA_URI
     * @memberof PIXI
     * @type {RegExp|string}
     * @example data:image/png;base64
     */
    var DATA_URI = exports.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;(charset=[\w-]+|base64))?,(.*)/i;
    
    /**
     * Regexp for SVG size.
     *
     * @static
     * @constant
     * @name SVG_SIZE
     * @memberof PIXI
     * @type {RegExp|string}
     * @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
     */
    var SVG_SIZE = exports.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len
    
    /**
     * Constants that identify shapes, mainly to prevent `instanceof` calls.
     *
     * @static
     * @constant
     * @name SHAPES
     * @memberof PIXI
     * @type {object}
     * @property {number} POLY Polygon
     * @property {number} RECT Rectangle
     * @property {number} CIRC Circle
     * @property {number} ELIP Ellipse
     * @property {number} RREC Rounded Rectangle
     */
    var SHAPES = exports.SHAPES = {
      POLY: 0,
      RECT: 1,
      CIRC: 2,
      ELIP: 3,
      RREC: 4
    };
    
    /**
     * Constants that specify float precision in shaders.
     *
     * @static
     * @constant
     * @name PRECISION
     * @memberof PIXI
     * @type {object}
     * @property {string} LOW='lowp'
     * @property {string} MEDIUM='mediump'
     * @property {string} HIGH='highp'
     */
    var PRECISION = exports.PRECISION = {
      LOW: 'lowp',
      MEDIUM: 'mediump',
      HIGH: 'highp'
    };
    
    /**
     * Constants that specify the transform type.
     *
     * @static
     * @constant
     * @name TRANSFORM_MODE
     * @memberof PIXI
     * @type {object}
     * @property {number} STATIC
     * @property {number} DYNAMIC
     */
    var TRANSFORM_MODE = exports.TRANSFORM_MODE = {
      STATIC: 0,
      DYNAMIC: 1
    };
    
    /**
     * Constants that define the type of gradient on text.
     *
     * @static
     * @constant
     * @name TEXT_GRADIENT
     * @memberof PIXI
     * @type {object}
     * @property {number} LINEAR_VERTICAL Vertical gradient
     * @property {number} LINEAR_HORIZONTAL Linear gradient
     */
    var TEXT_GRADIENT = exports.TEXT_GRADIENT = {
      LINEAR_VERTICAL: 0,
      LINEAR_HORIZONTAL: 1
    };
    
    /**
     * Represents the update priorities used by internal PIXI classes when registered with
     * the {@link PIXI.ticker.Ticker} object. Higher priority items are updated first and lower
     * priority items, such as render, should go later.
     *
     * @static
     * @constant
     * @name UPDATE_PRIORITY
     * @memberof PIXI
     * @type {object}
     * @property {number} INTERACTION=50 Highest priority, used for {@link PIXI.interaction.InteractionManager}
     * @property {number} HIGH=25 High priority updating, {@link PIXI.VideoBaseTexture} and {@link PIXI.extras.AnimatedSprite}
     * @property {number} NORMAL=0 Default priority for ticker events, see {@link PIXI.ticker.Ticker#add}.
     * @property {number} LOW=-25 Low priority used for {@link PIXI.Application} rendering.
     * @property {number} UTILITY=-50 Lowest priority used for {@link PIXI.prepare.BasePrepare} utility.
     */
    var UPDATE_PRIORITY = exports.UPDATE_PRIORITY = {
      INTERACTION: 50,
      HIGH: 25,
      NORMAL: 0,
      LOW: -25,
      UTILITY: -50
    };
    
    /***/ }),
    /* 1 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.BaseTextureCache = exports.TextureCache = exports.mixins = exports.pluginTarget = exports.EventEmitter = exports.isMobile = undefined;
    exports.uid = uid;
    exports.hex2rgb = hex2rgb;
    exports.hex2string = hex2string;
    exports.rgb2hex = rgb2hex;
    exports.getResolutionOfUrl = getResolutionOfUrl;
    exports.decomposeDataUri = decomposeDataUri;
    exports.getUrlFileExtension = getUrlFileExtension;
    exports.getSvgSize = getSvgSize;
    exports.skipHello = skipHello;
    exports.sayHello = sayHello;
    exports.isWebGLSupported = isWebGLSupported;
    exports.sign = sign;
    exports.removeItems = removeItems;
    exports.destroyTextureCache = destroyTextureCache;
    exports.clearTextureCache = clearTextureCache;
    
    var _const = __webpack_require__(0);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _eventemitter = __webpack_require__(6);
    
    var _eventemitter2 = _interopRequireDefault(_eventemitter);
    
    var _pluginTarget = __webpack_require__(104);
    
    var _pluginTarget2 = _interopRequireDefault(_pluginTarget);
    
    var _mixin = __webpack_require__(105);
    
    var mixins = _interopRequireWildcard(_mixin);
    
    var _ismobilejs = __webpack_require__(45);
    
    var isMobile = _interopRequireWildcard(_ismobilejs);
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var nextUid = 0;
    var saidHello = false;
    
    /**
     * Generalized convenience utilities for PIXI.
     * @example
     * // Extend PIXI's internal Event Emitter.
     * class MyEmitter extends PIXI.utils.EventEmitter {
     *   constructor() {
     *      super();
     *      console.log("Emitter created!");
     *   }
     * }
     *
     * // Get info on current device
     * console.log(PIXI.utils.isMobile);
     *
     * // Convert hex color to string
     * console.log(PIXI.utils.hex2string(0xff00ff)); // returns: "#ff00ff"
     * @namespace PIXI.utils
     */
    exports.isMobile = isMobile;
    exports.EventEmitter = _eventemitter2.default;
    exports.pluginTarget = _pluginTarget2.default;
    exports.mixins = mixins;
    
    /**
     * Gets the next unique identifier
     *
     * @memberof PIXI.utils
     * @function uid
     * @return {number} The next unique identifier to use.
     */
    
    function uid() {
        return ++nextUid;
    }
    
    /**
     * Converts a hex color number to an [R, G, B] array
     *
     * @memberof PIXI.utils
     * @function hex2rgb
     * @param {number} hex - The number to convert
     * @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
     * @return {number[]} An array representing the [R, G, B] of the color.
     */
    function hex2rgb(hex, out) {
        out = out || [];
    
        out[0] = (hex >> 16 & 0xFF) / 255;
        out[1] = (hex >> 8 & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;
    
        return out;
    }
    
    /**
     * Converts a hex color number to a string.
     *
     * @memberof PIXI.utils
     * @function hex2string
     * @param {number} hex - Number in hex
     * @return {string} The string color.
     */
    function hex2string(hex) {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;
    
        return '#' + hex;
    }
    
    /**
     * Converts a color as an [R, G, B] array to a hex number
     *
     * @memberof PIXI.utils
     * @function rgb2hex
     * @param {number[]} rgb - rgb array
     * @return {number} The color number
     */
    function rgb2hex(rgb) {
        return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);
    }
    
    /**
     * get the resolution / device pixel ratio of an asset by looking for the prefix
     * used by spritesheets and image urls
     *
     * @memberof PIXI.utils
     * @function getResolutionOfUrl
     * @param {string} url - the image path
     * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.
     * @return {number} resolution / device pixel ratio of an asset
     */
    function getResolutionOfUrl(url, defaultValue) {
        var resolution = _settings2.default.RETINA_PREFIX.exec(url);
    
        if (resolution) {
            return parseFloat(resolution[1]);
        }
    
        return defaultValue !== undefined ? defaultValue : 1;
    }
    
    /**
     * Typedef for decomposeDataUri return object.
     *
     * @typedef {object} DecomposedDataUri
     * @property {mediaType} Media type, eg. `image`
     * @property {subType} Sub type, eg. `png`
     * @property {encoding} Data encoding, eg. `base64`
     * @property {data} The actual data
     */
    
    /**
     * Split a data URI into components. Returns undefined if
     * parameter `dataUri` is not a valid data URI.
     *
     * @memberof PIXI.utils
     * @function decomposeDataUri
     * @param {string} dataUri - the data URI to check
     * @return {DecomposedDataUri|undefined} The decomposed data uri or undefined
     */
    function decomposeDataUri(dataUri) {
        var dataUriMatch = _const.DATA_URI.exec(dataUri);
    
        if (dataUriMatch) {
            return {
                mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
                subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
                encoding: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
                data: dataUriMatch[4]
            };
        }
    
        return undefined;
    }
    
    /**
     * Get type of the image by regexp for extension. Returns undefined for unknown extensions.
     *
     * @memberof PIXI.utils
     * @function getUrlFileExtension
     * @param {string} url - the image path
     * @return {string|undefined} image extension
     */
    function getUrlFileExtension(url) {
        var extension = _const.URL_FILE_EXTENSION.exec(url);
    
        if (extension) {
            return extension[1].toLowerCase();
        }
    
        return undefined;
    }
    
    /**
     * Typedef for Size object.
     *
     * @typedef {object} Size
     * @property {width} Width component
     * @property {height} Height component
     */
    
    /**
     * Get size from an svg string using regexp.
     *
     * @memberof PIXI.utils
     * @function getSvgSize
     * @param {string} svgString - a serialized svg element
     * @return {Size|undefined} image extension
     */
    function getSvgSize(svgString) {
        var sizeMatch = _const.SVG_SIZE.exec(svgString);
        var size = {};
    
        if (sizeMatch) {
            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
    
        return size;
    }
    
    /**
     * Skips the hello message of renderers that are created after this is run.
     *
     * @function skipHello
     * @memberof PIXI.utils
     */
    function skipHello() {
        saidHello = true;
    }
    
    /**
     * Logs out the version and renderer information for this running instance of PIXI.
     * If you don't want to see this message you can run `PIXI.utils.skipHello()` before
     * creating your renderer. Keep in mind that doing that will forever makes you a jerk face.
     *
     * @static
     * @function sayHello
     * @memberof PIXI.utils
     * @param {string} type - The string renderer type to log.
     */
    function sayHello(type) {
        if (saidHello) {
            return;
        }
    
        if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
            var args = ['\n %c %c %c Pixi.js ' + _const.VERSION + ' - \u2730 ' + type + ' \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n', 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];
    
            window.console.log.apply(console, args);
        } else if (window.console) {
            window.console.log('Pixi.js ' + _const.VERSION + ' - ' + type + ' - http://www.pixijs.com/');
        }
    
        saidHello = true;
    }
    
    /**
     * Helper for checking for webgl support
     *
     * @memberof PIXI.utils
     * @function isWebGLSupported
     * @return {boolean} is webgl supported
     */
    function isWebGLSupported() {
        var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };
    
        try {
            if (!window.WebGLRenderingContext) {
                return false;
            }
    
            var canvas = document.createElement('canvas');
            var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
    
            var success = !!(gl && gl.getContextAttributes().stencil);
    
            if (gl) {
                var loseContext = gl.getExtension('WEBGL_lose_context');
    
                if (loseContext) {
                    loseContext.loseContext();
                }
            }
    
            gl = null;
    
            return success;
        } catch (e) {
            return false;
        }
    }
    
    /**
     * Returns sign of number
     *
     * @memberof PIXI.utils
     * @function sign
     * @param {number} n - the number to check the sign of
     * @returns {number} 0 if `n` is 0, -1 if `n` is negative, 1 if `n` is positive
     */
    function sign(n) {
        if (n === 0) return 0;
    
        return n < 0 ? -1 : 1;
    }
    
    /**
     * Remove a range of items from an array
     *
     * @memberof PIXI.utils
     * @function removeItems
     * @param {Array<*>} arr The target array
     * @param {number} startIdx The index to begin removing from (inclusive)
     * @param {number} removeCount How many items to remove
     */
    function removeItems(arr, startIdx, removeCount) {
        var length = arr.length;
    
        if (startIdx >= length || removeCount === 0) {
            return;
        }
    
        removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
    
        var len = length - removeCount;
    
        for (var i = startIdx; i < len; ++i) {
            arr[i] = arr[i + removeCount];
        }
    
        arr.length = len;
    }
    
    /**
     * @todo Describe property usage
     *
     * @memberof PIXI.utils
     * @private
     */
    var TextureCache = exports.TextureCache = Object.create(null);
    
    /**
     * @todo Describe property usage
     *
     * @memberof PIXI.utils
     * @private
     */
    var BaseTextureCache = exports.BaseTextureCache = Object.create(null);
    
    /**
     * Destroys all texture in the cache
     *
     * @memberof PIXI.utils
     * @function destroyTextureCache
     */
    function destroyTextureCache() {
        var key = void 0;
    
        for (key in TextureCache) {
            TextureCache[key].destroy();
        }
        for (key in BaseTextureCache) {
            BaseTextureCache[key].destroy();
        }
    }
    
    /**
     * Removes all textures from cache, but does not destroy them
     *
     * @memberof PIXI.utils
     * @function clearTextureCache
     */
    function clearTextureCache() {
        var key = void 0;
    
        for (key in TextureCache) {
            delete TextureCache[key];
        }
        for (key in BaseTextureCache) {
            delete BaseTextureCache[key];
        }
    }
    
    /***/ }),
    /* 2 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Point = __webpack_require__(21);
    
    Object.defineProperty(exports, 'Point', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Point).default;
      }
    });
    
    var _ObservablePoint = __webpack_require__(91);
    
    Object.defineProperty(exports, 'ObservablePoint', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_ObservablePoint).default;
      }
    });
    
    var _Matrix = __webpack_require__(22);
    
    Object.defineProperty(exports, 'Matrix', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Matrix).default;
      }
    });
    
    var _GroupD = __webpack_require__(34);
    
    Object.defineProperty(exports, 'GroupD8', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_GroupD).default;
      }
    });
    
    var _Circle = __webpack_require__(92);
    
    Object.defineProperty(exports, 'Circle', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Circle).default;
      }
    });
    
    var _Ellipse = __webpack_require__(93);
    
    Object.defineProperty(exports, 'Ellipse', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Ellipse).default;
      }
    });
    
    var _Polygon = __webpack_require__(94);
    
    Object.defineProperty(exports, 'Polygon', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Polygon).default;
      }
    });
    
    var _Rectangle = __webpack_require__(23);
    
    Object.defineProperty(exports, 'Rectangle', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Rectangle).default;
      }
    });
    
    var _RoundedRectangle = __webpack_require__(95);
    
    Object.defineProperty(exports, 'RoundedRectangle', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_RoundedRectangle).default;
      }
    });
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /***/ }),
    /* 3 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _maxRecommendedTextures = __webpack_require__(102);
    
    var _maxRecommendedTextures2 = _interopRequireDefault(_maxRecommendedTextures);
    
    var _canUploadSameBuffer = __webpack_require__(103);
    
    var _canUploadSameBuffer2 = _interopRequireDefault(_canUploadSameBuffer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * User's customizable globals for overriding the default PIXI settings, such
     * as a renderer's default resolution, framerate, float percision, etc.
     * @example
     * // Use the native window resolution as the default resolution
     * // will support high-density displays when rendering
     * PIXI.settings.RESOLUTION = window.devicePixelRatio.
     *
     * // Disable interpolation when scaling, will make texture be pixelated
     * PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
     * @namespace PIXI.settings
     */
    exports.default = {
    
      /**
       * Target frames per millisecond.
       *
       * @static
       * @memberof PIXI.settings
       * @type {number}
       * @default 0.06
       */
      TARGET_FPMS: 0.06,
    
      /**
       * If set to true WebGL will attempt make textures mimpaped by default.
       * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
       *
       * @static
       * @memberof PIXI.settings
       * @type {boolean}
       * @default true
       */
      MIPMAP_TEXTURES: true,
    
      /**
       * Default resolution / device pixel ratio of the renderer.
       *
       * @static
       * @memberof PIXI.settings
       * @type {number}
       * @default 1
       */
      RESOLUTION: 1,
    
      /**
       * Default filter resolution.
       *
       * @static
       * @memberof PIXI.settings
       * @type {number}
       * @default 1
       */
      FILTER_RESOLUTION: 1,
    
      /**
       * The maximum textures that this device supports.
       *
       * @static
       * @memberof PIXI.settings
       * @type {number}
       * @default 32
       */
      SPRITE_MAX_TEXTURES: (0, _maxRecommendedTextures2.default)(32),
    
      // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
      // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
    
      /**
       * The default sprite batch size.
       *
       * The default aims to balance desktop and mobile devices.
       *
       * @static
       * @memberof PIXI.settings
       * @type {number}
       * @default 4096
       */
      SPRITE_BATCH_SIZE: 4096,
    
      /**
       * The prefix that denotes a URL is for a retina asset.
       *
       * @static
       * @memberof PIXI.settings
       * @type {RegExp}
       * @example `@2x`
       * @default /@([0-9\.]+)x/
       */
      RETINA_PREFIX: /@([0-9\.]+)x/,
    
      /**
       * The default render options if none are supplied to {@link PIXI.WebGLRenderer}
       * or {@link PIXI.CanvasRenderer}.
       *
       * @static
       * @constant
       * @memberof PIXI.settings
       * @type {object}
       * @property {HTMLCanvasElement} view=null
       * @property {number} resolution=1
       * @property {boolean} antialias=false
       * @property {boolean} forceFXAA=false
       * @property {boolean} autoResize=false
       * @property {boolean} transparent=false
       * @property {number} backgroundColor=0x000000
       * @property {boolean} clearBeforeRender=true
       * @property {boolean} preserveDrawingBuffer=false
       * @property {boolean} roundPixels=false
       * @property {number} width=800
       * @property {number} height=600
       * @property {boolean} legacy=false
       */
      RENDER_OPTIONS: {
        view: null,
        antialias: false,
        forceFXAA: false,
        autoResize: false,
        transparent: false,
        backgroundColor: 0x000000,
        clearBeforeRender: true,
        preserveDrawingBuffer: false,
        roundPixels: false,
        width: 800,
        height: 600,
        legacy: false
      },
    
      /**
       * Default transform type.
       *
       * @static
       * @memberof PIXI.settings
       * @type {PIXI.TRANSFORM_MODE}
       * @default PIXI.TRANSFORM_MODE.STATIC
       */
      TRANSFORM_MODE: 0,
    
      /**
       * Default Garbage Collection mode.
       *
       * @static
       * @memberof PIXI.settings
       * @type {PIXI.GC_MODES}
       * @default PIXI.GC_MODES.AUTO
       */
      GC_MODE: 0,
    
      /**
       * Default Garbage Collection max idle.
       *
       * @static
       * @memberof PIXI.settings
       * @type {number}
       * @default 3600
       */
      GC_MAX_IDLE: 60 * 60,
    
      /**
       * Default Garbage Collection maximum check count.
       *
       * @static
       * @memberof PIXI.settings
       * @type {number}
       * @default 600
       */
      GC_MAX_CHECK_COUNT: 60 * 10,
    
      /**
       * Default wrap modes that are supported by pixi.
       *
       * @static
       * @memberof PIXI.settings
       * @type {PIXI.WRAP_MODES}
       * @default PIXI.WRAP_MODES.CLAMP
       */
      WRAP_MODE: 0,
    
      /**
       * The scale modes that are supported by pixi.
       *
       * @static
       * @memberof PIXI.settings
       * @type {PIXI.SCALE_MODES}
       * @default PIXI.SCALE_MODES.LINEAR
       */
      SCALE_MODE: 0,
    
      /**
       * Default specify float precision in vertex shader.
       *
       * @static
       * @memberof PIXI.settings
       * @type {PIXI.PRECISION}
       * @default PIXI.PRECISION.HIGH
       */
      PRECISION_VERTEX: 'highp',
    
      /**
       * Default specify float precision in fragment shader.
       *
       * @static
       * @memberof PIXI.settings
       * @type {PIXI.PRECISION}
       * @default PIXI.PRECISION.MEDIUM
       */
      PRECISION_FRAGMENT: 'mediump',
    
      /**
       * Can we upload the same buffer in a single frame?
       *
       * @static
       * @constant
       * @memberof PIXI
       * @type {boolean}
       */
      CAN_UPLOAD_SAME_BUFFER: (0, _canUploadSameBuffer2.default)()
    
    };
    
    /***/ }),
    /* 4 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.autoDetectRenderer = exports.Application = exports.Filter = exports.SpriteMaskFilter = exports.Quad = exports.RenderTarget = exports.ObjectRenderer = exports.WebGLManager = exports.Shader = exports.CanvasRenderTarget = exports.TextureUvs = exports.VideoBaseTexture = exports.BaseRenderTexture = exports.RenderTexture = exports.BaseTexture = exports.Texture = exports.Spritesheet = exports.CanvasGraphicsRenderer = exports.GraphicsRenderer = exports.GraphicsData = exports.Graphics = exports.SpriteRenderer = exports.CanvasTinter = exports.CanvasSpriteRenderer = exports.Sprite = exports.TransformBase = exports.TransformStatic = exports.Transform = exports.Container = exports.DisplayObject = exports.Bounds = exports.glCore = exports.WebGLRenderer = exports.CanvasRenderer = exports.ticker = exports.utils = exports.settings = undefined;
    
    var _const = __webpack_require__(0);
    
    Object.keys(_const).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _const[key];
        }
      });
    });
    
    var _math = __webpack_require__(2);
    
    Object.keys(_math).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _math[key];
        }
      });
    });
    
    var _pixiGlCore = __webpack_require__(5);
    
    Object.defineProperty(exports, 'glCore', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_pixiGlCore).default;
      }
    });
    
    var _Bounds = __webpack_require__(25);
    
    Object.defineProperty(exports, 'Bounds', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Bounds).default;
      }
    });
    
    var _DisplayObject = __webpack_require__(44);
    
    Object.defineProperty(exports, 'DisplayObject', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_DisplayObject).default;
      }
    });
    
    var _Container = __webpack_require__(7);
    
    Object.defineProperty(exports, 'Container', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Container).default;
      }
    });
    
    var _Transform = __webpack_require__(47);
    
    Object.defineProperty(exports, 'Transform', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Transform).default;
      }
    });
    
    var _TransformStatic = __webpack_require__(46);
    
    Object.defineProperty(exports, 'TransformStatic', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_TransformStatic).default;
      }
    });
    
    var _TransformBase = __webpack_require__(26);
    
    Object.defineProperty(exports, 'TransformBase', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_TransformBase).default;
      }
    });
    
    var _Sprite = __webpack_require__(48);
    
    Object.defineProperty(exports, 'Sprite', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Sprite).default;
      }
    });
    
    var _CanvasSpriteRenderer = __webpack_require__(115);
    
    Object.defineProperty(exports, 'CanvasSpriteRenderer', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_CanvasSpriteRenderer).default;
      }
    });
    
    var _CanvasTinter = __webpack_require__(56);
    
    Object.defineProperty(exports, 'CanvasTinter', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_CanvasTinter).default;
      }
    });
    
    var _SpriteRenderer = __webpack_require__(118);
    
    Object.defineProperty(exports, 'SpriteRenderer', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_SpriteRenderer).default;
      }
    });
    
    var _Graphics = __webpack_require__(134);
    
    Object.defineProperty(exports, 'Graphics', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Graphics).default;
      }
    });
    
    var _GraphicsData = __webpack_require__(61);
    
    Object.defineProperty(exports, 'GraphicsData', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_GraphicsData).default;
      }
    });
    
    var _GraphicsRenderer = __webpack_require__(136);
    
    Object.defineProperty(exports, 'GraphicsRenderer', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_GraphicsRenderer).default;
      }
    });
    
    var _CanvasGraphicsRenderer = __webpack_require__(143);
    
    Object.defineProperty(exports, 'CanvasGraphicsRenderer', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_CanvasGraphicsRenderer).default;
      }
    });
    
    var _Spritesheet = __webpack_require__(144);
    
    Object.defineProperty(exports, 'Spritesheet', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Spritesheet).default;
      }
    });
    
    var _Texture = __webpack_require__(8);
    
    Object.defineProperty(exports, 'Texture', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Texture).default;
      }
    });
    
    var _BaseTexture = __webpack_require__(9);
    
    Object.defineProperty(exports, 'BaseTexture', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_BaseTexture).default;
      }
    });
    
    var _RenderTexture = __webpack_require__(29);
    
    Object.defineProperty(exports, 'RenderTexture', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_RenderTexture).default;
      }
    });
    
    var _BaseRenderTexture = __webpack_require__(53);
    
    Object.defineProperty(exports, 'BaseRenderTexture', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_BaseRenderTexture).default;
      }
    });
    
    var _VideoBaseTexture = __webpack_require__(50);
    
    Object.defineProperty(exports, 'VideoBaseTexture', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_VideoBaseTexture).default;
      }
    });
    
    var _TextureUvs = __webpack_require__(51);
    
    Object.defineProperty(exports, 'TextureUvs', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_TextureUvs).default;
      }
    });
    
    var _CanvasRenderTarget = __webpack_require__(54);
    
    Object.defineProperty(exports, 'CanvasRenderTarget', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_CanvasRenderTarget).default;
      }
    });
    
    var _Shader = __webpack_require__(16);
    
    Object.defineProperty(exports, 'Shader', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Shader).default;
      }
    });
    
    var _WebGLManager = __webpack_require__(11);
    
    Object.defineProperty(exports, 'WebGLManager', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_WebGLManager).default;
      }
    });
    
    var _ObjectRenderer = __webpack_require__(13);
    
    Object.defineProperty(exports, 'ObjectRenderer', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_ObjectRenderer).default;
      }
    });
    
    var _RenderTarget = __webpack_require__(15);
    
    Object.defineProperty(exports, 'RenderTarget', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_RenderTarget).default;
      }
    });
    
    var _Quad = __webpack_require__(59);
    
    Object.defineProperty(exports, 'Quad', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Quad).default;
      }
    });
    
    var _SpriteMaskFilter = __webpack_require__(57);
    
    Object.defineProperty(exports, 'SpriteMaskFilter', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_SpriteMaskFilter).default;
      }
    });
    
    var _Filter = __webpack_require__(58);
    
    Object.defineProperty(exports, 'Filter', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Filter).default;
      }
    });
    
    var _Application = __webpack_require__(63);
    
    Object.defineProperty(exports, 'Application', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Application).default;
      }
    });
    
    var _autoDetectRenderer = __webpack_require__(64);
    
    Object.defineProperty(exports, 'autoDetectRenderer', {
      enumerable: true,
      get: function get() {
        return _autoDetectRenderer.autoDetectRenderer;
      }
    });
    
    var _utils = __webpack_require__(1);
    
    var utils = _interopRequireWildcard(_utils);
    
    var _ticker = __webpack_require__(28);
    
    var ticker = _interopRequireWildcard(_ticker);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _CanvasRenderer = __webpack_require__(10);
    
    var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
    
    var _WebGLRenderer = __webpack_require__(14);
    
    var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    exports.settings = _settings2.default;
    exports.utils = utils;
    exports.ticker = ticker;
    exports.CanvasRenderer = _CanvasRenderer2.default;
    exports.WebGLRenderer = _WebGLRenderer2.default; /**
                                                      * @namespace PIXI
                                                      */
    
    /***/ }),
    /* 5 */
    /***/ (function(module, exports, __webpack_require__) {
    
    var gl = {
        createContext:          __webpack_require__(96),
        setVertexAttribArrays:  __webpack_require__(35),
        GLBuffer:               __webpack_require__(97),
        GLFramebuffer:          __webpack_require__(98),
        GLShader:               __webpack_require__(99),
        GLTexture:              __webpack_require__(36),
        VertexArrayObject:      __webpack_require__(100),
        shader:                 __webpack_require__(101)
    };
    
    // Export for Node-compatible environments
    if (typeof module !== 'undefined' && module.exports)
    {
        // Export the module
        module.exports = gl;
    }
    
    // Add to the browser window pixi.gl
    if (typeof window !== 'undefined')
    {
        // add the window object
        window.PIXI = window.PIXI || {};
        window.PIXI.glCore = gl;
    }
    
    
    /***/ }),
    /* 6 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var has = Object.prototype.hasOwnProperty
      , prefix = '~';
    
    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @api private
     */
    function Events() {}
    
    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);
    
      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }
    
    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {Mixed} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @api private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    
    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @api public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    
    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @api public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = []
        , events
        , name;
    
      if (this._eventsCount === 0) return names;
    
      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
    
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
    
      return names;
    };
    
    /**
     * Return the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Boolean} exists Only check if there are listeners.
     * @returns {Array|Boolean}
     * @api public
     */
    EventEmitter.prototype.listeners = function listeners(event, exists) {
      var evt = prefix ? prefix + event : event
        , available = this._events[evt];
    
      if (exists) return !!available;
      if (!available) return [];
      if (available.fn) return [available.fn];
    
      for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
        ee[i] = available[i].fn;
      }
    
      return ee;
    };
    
    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @api public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events[evt]) return false;
    
      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;
    
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
    
        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
    
        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
    
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;
    
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
    
          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
    
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
    
      return true;
    };
    
    /**
     * Add a listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      var listener = new EE(fn, context || this)
        , evt = prefix ? prefix + event : event;
    
      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];
    
      return this;
    };
    
    /**
     * Add a one-time listener for a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn The listener function.
     * @param {Mixed} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      var listener = new EE(fn, context || this, true)
        , evt = prefix ? prefix + event : event;
    
      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
      else if (!this._events[evt].fn) this._events[evt].push(listener);
      else this._events[evt] = [this._events[evt], listener];
    
      return this;
    };
    
    /**
     * Remove the listeners of a given event.
     *
     * @param {String|Symbol} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {Mixed} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events[evt]) return this;
      if (!fn) {
        if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
        return this;
      }
    
      var listeners = this._events[evt];
    
      if (listeners.fn) {
        if (
             listeners.fn === fn
          && (!once || listeners.once)
          && (!context || listeners.context === context)
        ) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (
               listeners[i].fn !== fn
            || (once && !listeners[i].once)
            || (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }
    
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else if (--this._eventsCount === 0) this._events = new Events();
        else delete this._events[evt];
      }
    
      return this;
    };
    
    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {String|Symbol} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @api public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
    
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) {
          if (--this._eventsCount === 0) this._events = new Events();
          else delete this._events[evt];
        }
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
    
      return this;
    };
    
    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    
    //
    // This function doesn't apply anymore.
    //
    EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
      return this;
    };
    
    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;
    
    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;
    
    //
    // Expose the module.
    //
    if (true) {
      module.exports = EventEmitter;
    }
    
    
    /***/ }),
    /* 7 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _utils = __webpack_require__(1);
    
    var _DisplayObject2 = __webpack_require__(44);
    
    var _DisplayObject3 = _interopRequireDefault(_DisplayObject2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * A Container represents a collection of display objects.
     * It is the base class of all display objects that act as a container for other objects.
     *
     *```js
     * let container = new PIXI.Container();
     * container.addChild(sprite);
     * ```
     *
     * @class
     * @extends PIXI.DisplayObject
     * @memberof PIXI
     */
    var Container = function (_DisplayObject) {
        _inherits(Container, _DisplayObject);
    
        /**
         *
         */
        function Container() {
            _classCallCheck(this, Container);
    
            /**
             * The array of children of this container.
             *
             * @member {PIXI.DisplayObject[]}
             * @readonly
             */
            var _this = _possibleConstructorReturn(this, _DisplayObject.call(this));
    
            _this.children = [];
            return _this;
        }
    
        /**
         * Overridable method that can be used by Container subclasses whenever the children array is modified
         *
         * @private
         */
    
    
        Container.prototype.onChildrenChange = function onChildrenChange() {}
        /* empty */
    
    
        /**
         * Adds one or more children to the container.
         *
         * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
         *
         * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
         * @return {PIXI.DisplayObject} The first child that was added.
         */
        ;
    
        Container.prototype.addChild = function addChild(child) {
            var argumentsLength = arguments.length;
    
            // if there is only one argument we can bypass looping through the them
            if (argumentsLength > 1) {
                // loop through the arguments property and add all children
                // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
                for (var i = 0; i < argumentsLength; i++) {
                    this.addChild(arguments[i]);
                }
            } else {
                // if the child has a parent then lets remove it as Pixi objects can only exist in one place
                if (child.parent) {
                    child.parent.removeChild(child);
                }
    
                child.parent = this;
                // ensure child transform will be recalculated
                child.transform._parentID = -1;
    
                this.children.push(child);
    
                // ensure bounds will be recalculated
                this._boundsID++;
    
                // TODO - lets either do all callbacks or all events.. not both!
                this.onChildrenChange(this.children.length - 1);
                child.emit('added', this);
            }
    
            return child;
        };
    
        /**
         * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
         *
         * @param {PIXI.DisplayObject} child - The child to add
         * @param {number} index - The index to place the child in
         * @return {PIXI.DisplayObject} The child that was added.
         */
    
    
        Container.prototype.addChildAt = function addChildAt(child, index) {
            if (index < 0 || index > this.children.length) {
                throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);
            }
    
            if (child.parent) {
                child.parent.removeChild(child);
            }
    
            child.parent = this;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
    
            this.children.splice(index, 0, child);
    
            // ensure bounds will be recalculated
            this._boundsID++;
    
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            child.emit('added', this);
    
            return child;
        };
    
        /**
         * Swaps the position of 2 Display Objects within this container.
         *
         * @param {PIXI.DisplayObject} child - First display object to swap
         * @param {PIXI.DisplayObject} child2 - Second display object to swap
         */
    
    
        Container.prototype.swapChildren = function swapChildren(child, child2) {
            if (child === child2) {
                return;
            }
    
            var index1 = this.getChildIndex(child);
            var index2 = this.getChildIndex(child2);
    
            this.children[index1] = child2;
            this.children[index2] = child;
            this.onChildrenChange(index1 < index2 ? index1 : index2);
        };
    
        /**
         * Returns the index position of a child DisplayObject instance
         *
         * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
         * @return {number} The index position of the child display object to identify
         */
    
    
        Container.prototype.getChildIndex = function getChildIndex(child) {
            var index = this.children.indexOf(child);
    
            if (index === -1) {
                throw new Error('The supplied DisplayObject must be a child of the caller');
            }
    
            return index;
        };
    
        /**
         * Changes the position of an existing child in the display object container
         *
         * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
         * @param {number} index - The resulting index number for the child display object
         */
    
    
        Container.prototype.setChildIndex = function setChildIndex(child, index) {
            if (index < 0 || index >= this.children.length) {
                throw new Error('The supplied index is out of bounds');
            }
    
            var currentIndex = this.getChildIndex(child);
    
            (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position
            this.children.splice(index, 0, child); // add at new position
    
            this.onChildrenChange(index);
        };
    
        /**
         * Returns the child at the specified index
         *
         * @param {number} index - The index to get the child at
         * @return {PIXI.DisplayObject} The child at the given index, if any.
         */
    
    
        Container.prototype.getChildAt = function getChildAt(index) {
            if (index < 0 || index >= this.children.length) {
                throw new Error('getChildAt: Index (' + index + ') does not exist.');
            }
    
            return this.children[index];
        };
    
        /**
         * Removes one or more children from the container.
         *
         * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
         * @return {PIXI.DisplayObject} The first child that was removed.
         */
    
    
        Container.prototype.removeChild = function removeChild(child) {
            var argumentsLength = arguments.length;
    
            // if there is only one argument we can bypass looping through the them
            if (argumentsLength > 1) {
                // loop through the arguments property and add all children
                // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes
                for (var i = 0; i < argumentsLength; i++) {
                    this.removeChild(arguments[i]);
                }
            } else {
                var index = this.children.indexOf(child);
    
                if (index === -1) return null;
    
                child.parent = null;
                // ensure child transform will be recalculated
                child.transform._parentID = -1;
                (0, _utils.removeItems)(this.children, index, 1);
    
                // ensure bounds will be recalculated
                this._boundsID++;
    
                // TODO - lets either do all callbacks or all events.. not both!
                this.onChildrenChange(index);
                child.emit('removed', this);
            }
    
            return child;
        };
    
        /**
         * Removes a child from the specified index position.
         *
         * @param {number} index - The index to get the child from
         * @return {PIXI.DisplayObject} The child that was removed.
         */
    
    
        Container.prototype.removeChildAt = function removeChildAt(index) {
            var child = this.getChildAt(index);
    
            // ensure child transform will be recalculated..
            child.parent = null;
            child.transform._parentID = -1;
            (0, _utils.removeItems)(this.children, index, 1);
    
            // ensure bounds will be recalculated
            this._boundsID++;
    
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            child.emit('removed', this);
    
            return child;
        };
    
        /**
         * Removes all children from this container that are within the begin and end indexes.
         *
         * @param {number} [beginIndex=0] - The beginning position.
         * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
         * @returns {DisplayObject[]} List of removed children
         */
    
    
        Container.prototype.removeChildren = function removeChildren() {
            var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var endIndex = arguments[1];
    
            var begin = beginIndex;
            var end = typeof endIndex === 'number' ? endIndex : this.children.length;
            var range = end - begin;
            var removed = void 0;
    
            if (range > 0 && range <= end) {
                removed = this.children.splice(begin, range);
    
                for (var i = 0; i < removed.length; ++i) {
                    removed[i].parent = null;
                    if (removed[i].transform) {
                        removed[i].transform._parentID = -1;
                    }
                }
    
                this._boundsID++;
    
                this.onChildrenChange(beginIndex);
    
                for (var _i = 0; _i < removed.length; ++_i) {
                    removed[_i].emit('removed', this);
                }
    
                return removed;
            } else if (range === 0 && this.children.length === 0) {
                return [];
            }
    
            throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
        };
    
        /**
         * Updates the transform on all children of this container for rendering
         */
    
    
        Container.prototype.updateTransform = function updateTransform() {
            this._boundsID++;
    
            this.transform.updateTransform(this.parent.transform);
    
            // TODO: check render flags, how to process stuff here
            this.worldAlpha = this.alpha * this.parent.worldAlpha;
    
            for (var i = 0, j = this.children.length; i < j; ++i) {
                var child = this.children[i];
    
                if (child.visible) {
                    child.updateTransform();
                }
            }
        };
    
        /**
         * Recalculates the bounds of the container.
         *
         */
    
    
        Container.prototype.calculateBounds = function calculateBounds() {
            this._bounds.clear();
    
            this._calculateBounds();
    
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
    
                if (!child.visible || !child.renderable) {
                    continue;
                }
    
                child.calculateBounds();
    
                // TODO: filter+mask, need to mask both somehow
                if (child._mask) {
                    child._mask.calculateBounds();
                    this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
                } else if (child.filterArea) {
                    this._bounds.addBoundsArea(child._bounds, child.filterArea);
                } else {
                    this._bounds.addBounds(child._bounds);
                }
            }
    
            this._lastBoundsID = this._boundsID;
        };
    
        /**
         * Recalculates the bounds of the object. Override this to
         * calculate the bounds of the specific object (not including children).
         *
         */
    
    
        Container.prototype._calculateBounds = function _calculateBounds() {}
        // FILL IN//
    
    
        /**
         * Renders the object using the WebGL renderer
         *
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */
        ;
    
        Container.prototype.renderWebGL = function renderWebGL(renderer) {
            // if the object is not visible or the alpha is 0 then no need to render this element
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
    
            // do a quick check to see if this element has a mask or a filter.
            if (this._mask || this._filters) {
                this.renderAdvancedWebGL(renderer);
            } else {
                this._renderWebGL(renderer);
    
                // simple render children!
                for (var i = 0, j = this.children.length; i < j; ++i) {
                    this.children[i].renderWebGL(renderer);
                }
            }
        };
    
        /**
         * Render the object using the WebGL renderer and advanced features.
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */
    
    
        Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {
            renderer.flush();
    
            var filters = this._filters;
            var mask = this._mask;
    
            // push filter first as we need to ensure the stencil buffer is correct for any masking
            if (filters) {
                if (!this._enabledFilters) {
                    this._enabledFilters = [];
                }
    
                this._enabledFilters.length = 0;
    
                for (var i = 0; i < filters.length; i++) {
                    if (filters[i].enabled) {
                        this._enabledFilters.push(filters[i]);
                    }
                }
    
                if (this._enabledFilters.length) {
                    renderer.filterManager.pushFilter(this, this._enabledFilters);
                }
            }
    
            if (mask) {
                renderer.maskManager.pushMask(this, this._mask);
            }
    
            // add this object to the batch, only rendered if it has a texture.
            this._renderWebGL(renderer);
    
            // now loop through the children and make sure they get rendered
            for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) {
                this.children[_i2].renderWebGL(renderer);
            }
    
            renderer.flush();
    
            if (mask) {
                renderer.maskManager.popMask(this, this._mask);
            }
    
            if (filters && this._enabledFilters && this._enabledFilters.length) {
                renderer.filterManager.popFilter();
            }
        };
    
        /**
         * To be overridden by the subclasses.
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */
    
    
        Container.prototype._renderWebGL = function _renderWebGL(renderer) // eslint-disable-line no-unused-vars
        {}
        // this is where content itself gets rendered...
    
    
        /**
         * To be overridden by the subclass
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */
        ;
    
        Container.prototype._renderCanvas = function _renderCanvas(renderer) // eslint-disable-line no-unused-vars
        {}
        // this is where content itself gets rendered...
    
    
        /**
         * Renders the object using the Canvas renderer
         *
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */
        ;
    
        Container.prototype.renderCanvas = function renderCanvas(renderer) {
            // if not visible or the alpha is 0 then no need to render this
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
    
            if (this._mask) {
                renderer.maskManager.pushMask(this._mask);
            }
    
            this._renderCanvas(renderer);
            for (var i = 0, j = this.children.length; i < j; ++i) {
                this.children[i].renderCanvas(renderer);
            }
    
            if (this._mask) {
                renderer.maskManager.popMask(renderer);
            }
        };
    
        /**
         * Removes all internal references and listeners as well as removes children from the display list.
         * Do not use a Container after calling `destroy`.
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *  method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the texture of the child sprite
         * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the base texture of the child sprite
         */
    
    
        Container.prototype.destroy = function destroy(options) {
            _DisplayObject.prototype.destroy.call(this);
    
            var destroyChildren = typeof options === 'boolean' ? options : options && options.children;
    
            var oldChildren = this.removeChildren(0, this.children.length);
    
            if (destroyChildren) {
                for (var i = 0; i < oldChildren.length; ++i) {
                    oldChildren[i].destroy(options);
                }
            }
        };
    
        /**
         * The width of the Container, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */
    
    
        _createClass(Container, [{
            key: 'width',
            get: function get() {
                return this.scale.x * this.getLocalBounds().width;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                var width = this.getLocalBounds().width;
    
                if (width !== 0) {
                    this.scale.x = value / width;
                } else {
                    this.scale.x = 1;
                }
    
                this._width = value;
            }
    
            /**
             * The height of the Container, setting this will actually modify the scale to achieve the value set
             *
             * @member {number}
             */
    
        }, {
            key: 'height',
            get: function get() {
                return this.scale.y * this.getLocalBounds().height;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                var height = this.getLocalBounds().height;
    
                if (height !== 0) {
                    this.scale.y = value / height;
                } else {
                    this.scale.y = 1;
                }
    
                this._height = value;
            }
        }]);
    
        return Container;
    }(_DisplayObject3.default);
    
    // performance increase to avoid using call.. (10x faster)
    
    
    exports.default = Container;
    Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
    
    /***/ }),
    /* 8 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _BaseTexture = __webpack_require__(9);
    
    var _BaseTexture2 = _interopRequireDefault(_BaseTexture);
    
    var _VideoBaseTexture = __webpack_require__(50);
    
    var _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);
    
    var _TextureUvs = __webpack_require__(51);
    
    var _TextureUvs2 = _interopRequireDefault(_TextureUvs);
    
    var _eventemitter = __webpack_require__(6);
    
    var _eventemitter2 = _interopRequireDefault(_eventemitter);
    
    var _math = __webpack_require__(2);
    
    var _utils = __webpack_require__(1);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * A texture stores the information that represents an image or part of an image. It cannot be added
     * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided
     * then the whole image is used.
     *
     * You can directly create a texture from an image and then reuse it multiple times like this :
     *
     * ```js
     * let texture = PIXI.Texture.fromImage('assets/image.png');
     * let sprite1 = new PIXI.Sprite(texture);
     * let sprite2 = new PIXI.Sprite(texture);
     * ```
     *
     * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.
     * You can check for this by checking the sprite's _textureID property.
     * ```js
     * var texture = PIXI.Texture.fromImage('assets/image.svg');
     * var sprite1 = new PIXI.Sprite(texture);
     * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file
     * ```
     * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.
     *
     * @class
     * @extends EventEmitter
     * @memberof PIXI
     */
    var Texture = function (_EventEmitter) {
        _inherits(Texture, _EventEmitter);
    
        /**
         * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from
         * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
         * @param {PIXI.Rectangle} [orig] - The area of original texture
         * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture
         * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}
         */
        function Texture(baseTexture, frame, orig, trim, rotate) {
            _classCallCheck(this, Texture);
    
            /**
             * Does this Texture have any frame data assigned to it?
             *
             * @member {boolean}
             */
            var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
    
            _this.noFrame = false;
    
            if (!frame) {
                _this.noFrame = true;
                frame = new _math.Rectangle(0, 0, 1, 1);
            }
    
            if (baseTexture instanceof Texture) {
                baseTexture = baseTexture.baseTexture;
            }
    
            /**
             * The base texture that this texture uses.
             *
             * @member {PIXI.BaseTexture}
             */
            _this.baseTexture = baseTexture;
    
            /**
             * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
             * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
             *
             * @member {PIXI.Rectangle}
             */
            _this._frame = frame;
    
            /**
             * This is the trimmed area of original texture, before it was put in atlas
             *
             * @member {PIXI.Rectangle}
             */
            _this.trim = trim;
    
            /**
             * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
             *
             * @member {boolean}
             */
            _this.valid = false;
    
            /**
             * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)
             *
             * @member {boolean}
             */
            _this.requiresUpdate = false;
    
            /**
             * The WebGL UV data cache.
             *
             * @member {PIXI.TextureUvs}
             * @private
             */
            _this._uvs = null;
    
            /**
             * This is the area of original texture, before it was put in atlas
             *
             * @member {PIXI.Rectangle}
             */
            _this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);
    
            _this._rotate = Number(rotate || 0);
    
            if (rotate === true) {
                // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
                _this._rotate = 2;
            } else if (_this._rotate % 2 !== 0) {
                throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
            }
    
            if (baseTexture.hasLoaded) {
                if (_this.noFrame) {
                    frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
    
                    // if there is no frame we should monitor for any base texture changes..
                    baseTexture.on('update', _this.onBaseTextureUpdated, _this);
                }
                _this.frame = frame;
            } else {
                baseTexture.once('loaded', _this.onBaseTextureLoaded, _this);
            }
    
            /**
             * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.
             *
             * @event PIXI.Texture#update
             * @protected
             * @param {PIXI.Texture} texture - Instance of texture being updated.
             */
    
            _this._updateID = 0;
    
            /**
             * Extra field for extra plugins. May contain clamp settings and some matrices
             * @type {Object}
             */
            _this.transform = null;
    
            /**
             * The ids under which this Texture has been added to the texture cache. This is
             * automatically set as long as Texture.addToCache is used, but may not be set if a
             * Texture is added directly to the TextureCache array.
             *
             * @member {string[]}
             */
            _this.textureCacheIds = [];
            return _this;
        }
    
        /**
         * Updates this texture on the gpu.
         *
         */
    
    
        Texture.prototype.update = function update() {
            this.baseTexture.update();
        };
    
        /**
         * Called when the base texture is loaded
         *
         * @private
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */
    
    
        Texture.prototype.onBaseTextureLoaded = function onBaseTextureLoaded(baseTexture) {
            this._updateID++;
    
            // TODO this code looks confusing.. boo to abusing getters and setters!
            if (this.noFrame) {
                this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            } else {
                this.frame = this._frame;
            }
    
            this.baseTexture.on('update', this.onBaseTextureUpdated, this);
            this.emit('update', this);
        };
    
        /**
         * Called when the base texture is updated
         *
         * @private
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */
    
    
        Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated(baseTexture) {
            this._updateID++;
    
            this._frame.width = baseTexture.width;
            this._frame.height = baseTexture.height;
    
            this.emit('update', this);
        };
    
        /**
         * Destroys this texture
         *
         * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
         */
    
    
        Texture.prototype.destroy = function destroy(destroyBase) {
            if (this.baseTexture) {
                if (destroyBase) {
                    // delete the texture if it exists in the texture cache..
                    // this only needs to be removed if the base texture is actually destroyed too..
                    if (_utils.TextureCache[this.baseTexture.imageUrl]) {
                        Texture.removeFromCache(this.baseTexture.imageUrl);
                    }
    
                    this.baseTexture.destroy();
                }
    
                this.baseTexture.off('update', this.onBaseTextureUpdated, this);
                this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);
    
                this.baseTexture = null;
            }
    
            this._frame = null;
            this._uvs = null;
            this.trim = null;
            this.orig = null;
    
            this.valid = false;
    
            Texture.removeFromCache(this);
            this.textureCacheIds = null;
        };
    
        /**
         * Creates a new texture object that acts the same as this one.
         *
         * @return {PIXI.Texture} The new texture
         */
    
    
        Texture.prototype.clone = function clone() {
            return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate);
        };
    
        /**
         * Updates the internal WebGL UV cache.
         *
         * @protected
         */
    
    
        Texture.prototype._updateUvs = function _updateUvs() {
            if (!this._uvs) {
                this._uvs = new _TextureUvs2.default();
            }
    
            this._uvs.set(this._frame, this.baseTexture, this.rotate);
    
            this._updateID++;
        };
    
        /**
         * Helper function that creates a Texture object from the given image url.
         * If the image is not in the texture cache it will be  created and loaded.
         *
         * @static
         * @param {string} imageUrl - The image url of the texture
         * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.
         * @return {PIXI.Texture} The newly created texture
         */
    
    
        Texture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
            var texture = _utils.TextureCache[imageUrl];
    
            if (!texture) {
                texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));
                Texture.addToCache(texture, imageUrl);
            }
    
            return texture;
        };
    
        /**
         * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
         * The frame ids are created when a Texture packer file has been loaded
         *
         * @static
         * @param {string} frameId - The frame Id of the texture in the cache
         * @return {PIXI.Texture} The newly created texture
         */
    
    
        Texture.fromFrame = function fromFrame(frameId) {
            var texture = _utils.TextureCache[frameId];
    
            if (!texture) {
                throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
            }
    
            return texture;
        };
    
        /**
         * Helper function that creates a new Texture based on the given canvas element.
         *
         * @static
         * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {string} [origin='canvas'] - A string origin of who created the base texture
         * @return {PIXI.Texture} The newly created texture
         */
    
    
        Texture.fromCanvas = function fromCanvas(canvas, scaleMode) {
            var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';
    
            return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode, origin));
        };
    
        /**
         * Helper function that creates a new Texture based on the given video element.
         *
         * @static
         * @param {HTMLVideoElement|string} video - The URL or actual element of the video
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @return {PIXI.Texture} The newly created texture
         */
    
    
        Texture.fromVideo = function fromVideo(video, scaleMode) {
            if (typeof video === 'string') {
                return Texture.fromVideoUrl(video, scaleMode);
            }
    
            return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode));
        };
    
        /**
         * Helper function that creates a new Texture based on the video url.
         *
         * @static
         * @param {string} videoUrl - URL of the video
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @return {PIXI.Texture} The newly created texture
         */
    
    
        Texture.fromVideoUrl = function fromVideoUrl(videoUrl, scaleMode) {
            return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode));
        };
    
        /**
         * Helper function that creates a new Texture based on the source you provide.
         * The source can be - frame id, image url, video url, canvas element, video element, base texture
         *
         * @static
         * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}
         *        source - Source to create texture from
         * @return {PIXI.Texture} The newly created texture
         */
    
    
        Texture.from = function from(source) {
            // TODO auto detect cross origin..
            // TODO pass in scale mode?
            if (typeof source === 'string') {
                var texture = _utils.TextureCache[source];
    
                if (!texture) {
                    // check if its a video..
                    var isVideo = source.match(/\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;
    
                    if (isVideo) {
                        return Texture.fromVideoUrl(source);
                    }
    
                    return Texture.fromImage(source);
                }
    
                return texture;
            } else if (source instanceof HTMLImageElement) {
                return new Texture(_BaseTexture2.default.from(source));
            } else if (source instanceof HTMLCanvasElement) {
                return Texture.fromCanvas(source, _settings2.default.SCALE_MODE, 'HTMLCanvasElement');
            } else if (source instanceof HTMLVideoElement) {
                return Texture.fromVideo(source);
            } else if (source instanceof _BaseTexture2.default) {
                return new Texture(source);
            }
    
            // lets assume its a texture!
            return source;
        };
    
        /**
         * Create a texture from a source and add to the cache.
         *
         * @static
         * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
         * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
         * @param {String} [name] - Human readible name for the texture cache. If no name is
         *        specified, only `imageUrl` will be used as the cache ID.
         * @return {PIXI.Texture} Output texture
         */
    
    
        Texture.fromLoader = function fromLoader(source, imageUrl, name) {
            var baseTexture = new _BaseTexture2.default(source, undefined, (0, _utils.getResolutionOfUrl)(imageUrl));
            var texture = new Texture(baseTexture);
    
            baseTexture.imageUrl = imageUrl;
    
            // No name, use imageUrl instead
            if (!name) {
                name = imageUrl;
            }
    
            // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions
            _BaseTexture2.default.addToCache(texture.baseTexture, name);
            Texture.addToCache(texture, name);
    
            // also add references by url if they are different.
            if (name !== imageUrl) {
                _BaseTexture2.default.addToCache(texture.baseTexture, imageUrl);
                Texture.addToCache(texture, imageUrl);
            }
    
            return texture;
        };
    
        /**
         * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
         *
         * @static
         * @param {PIXI.Texture} texture - The Texture to add to the cache.
         * @param {string} id - The id that the Texture will be stored against.
         */
    
    
        Texture.addToCache = function addToCache(texture, id) {
            if (id) {
                if (texture.textureCacheIds.indexOf(id) === -1) {
                    texture.textureCacheIds.push(id);
                }
    
                // @if DEBUG
                /* eslint-disable no-console */
                if (_utils.TextureCache[id]) {
                    console.warn('Texture added to the cache with an id [' + id + '] that already had an entry');
                }
                /* eslint-enable no-console */
                // @endif
    
                _utils.TextureCache[id] = texture;
            }
        };
    
        /**
         * Remove a Texture from the global TextureCache.
         *
         * @static
         * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
         * @return {PIXI.Texture|null} The Texture that was removed
         */
    
    
        Texture.removeFromCache = function removeFromCache(texture) {
            if (typeof texture === 'string') {
                var textureFromCache = _utils.TextureCache[texture];
    
                if (textureFromCache) {
                    var index = textureFromCache.textureCacheIds.indexOf(texture);
    
                    if (index > -1) {
                        textureFromCache.textureCacheIds.splice(index, 1);
                    }
    
                    delete _utils.TextureCache[texture];
    
                    return textureFromCache;
                }
            } else if (texture && texture.textureCacheIds) {
                for (var i = 0; i < texture.textureCacheIds.length; ++i) {
                    delete _utils.TextureCache[texture.textureCacheIds[i]];
                }
    
                texture.textureCacheIds.length = 0;
    
                return texture;
            }
    
            return null;
        };
    
        /**
         * The frame specifies the region of the base texture that this texture uses.
         *
         * @member {PIXI.Rectangle}
         */
    
    
        _createClass(Texture, [{
            key: 'frame',
            get: function get() {
                return this._frame;
            },
            set: function set(frame) // eslint-disable-line require-jsdoc
            {
                this._frame = frame;
    
                this.noFrame = false;
    
                if (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height) {
                    throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: ' + ('X: ' + frame.x + ' + ' + frame.width + ' > ' + this.baseTexture.width + ' ') + ('Y: ' + frame.y + ' + ' + frame.height + ' > ' + this.baseTexture.height));
                }
    
                // this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;
                this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;
    
                if (!this.trim && !this.rotate) {
                    this.orig = frame;
                }
    
                if (this.valid) {
                    this._updateUvs();
                }
            }
    
            /**
             * Indicates whether the texture is rotated inside the atlas
             * set to 2 to compensate for texture packer rotation
             * set to 6 to compensate for spine packer rotation
             * can be used to rotate or mirror sprites
             * See {@link PIXI.GroupD8} for explanation
             *
             * @member {number}
             */
    
        }, {
            key: 'rotate',
            get: function get() {
                return this._rotate;
            },
            set: function set(rotate) // eslint-disable-line require-jsdoc
            {
                this._rotate = rotate;
                if (this.valid) {
                    this._updateUvs();
                }
            }
    
            /**
             * The width of the Texture in pixels.
             *
             * @member {number}
             */
    
        }, {
            key: 'width',
            get: function get() {
                return this.orig.width;
            }
    
            /**
             * The height of the Texture in pixels.
             *
             * @member {number}
             */
    
        }, {
            key: 'height',
            get: function get() {
                return this.orig.height;
            }
        }]);
    
        return Texture;
    }(_eventemitter2.default);
    
    exports.default = Texture;
    
    
    function createWhiteTexture() {
        var canvas = document.createElement('canvas');
    
        canvas.width = 10;
        canvas.height = 10;
    
        var context = canvas.getContext('2d');
    
        context.fillStyle = 'white';
        context.fillRect(0, 0, 10, 10);
    
        return new Texture(new _BaseTexture2.default(canvas));
    }
    
    function removeAllHandlers(tex) {
        tex.destroy = function _emptyDestroy() {/* empty */};
        tex.on = function _emptyOn() {/* empty */};
        tex.once = function _emptyOnce() {/* empty */};
        tex.emit = function _emptyEmit() {/* empty */};
    }
    
    /**
     * An empty texture, used often to not have to create multiple empty textures.
     * Can not be destroyed.
     *
     * @static
     * @constant
     */
    Texture.EMPTY = new Texture(new _BaseTexture2.default());
    removeAllHandlers(Texture.EMPTY);
    removeAllHandlers(Texture.EMPTY.baseTexture);
    
    /**
     * A white texture of 10x10 size, used for graphics and other things
     * Can not be destroyed.
     *
     * @static
     * @constant
     */
    Texture.WHITE = createWhiteTexture();
    removeAllHandlers(Texture.WHITE);
    removeAllHandlers(Texture.WHITE.baseTexture);
    
    /***/ }),
    /* 9 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _utils = __webpack_require__(1);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _eventemitter = __webpack_require__(6);
    
    var _eventemitter2 = _interopRequireDefault(_eventemitter);
    
    var _determineCrossOrigin = __webpack_require__(106);
    
    var _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);
    
    var _bitTwiddle = __webpack_require__(27);
    
    var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * A texture stores the information that represents an image. All textures have a base texture.
     *
     * @class
     * @extends EventEmitter
     * @memberof PIXI
     */
    var BaseTexture = function (_EventEmitter) {
        _inherits(BaseTexture, _EventEmitter);
    
        /**
         * @param {HTMLImageElement|HTMLCanvasElement} [source] - the source object of the texture.
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture
         */
        function BaseTexture(source, scaleMode, resolution) {
            _classCallCheck(this, BaseTexture);
    
            var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
    
            _this.uid = (0, _utils.uid)();
    
            _this.touched = 0;
    
            /**
             * The resolution / device pixel ratio of the texture
             *
             * @member {number}
             * @default 1
             */
            _this.resolution = resolution || _settings2.default.RESOLUTION;
    
            /**
             * The width of the base texture set when the image has loaded
             *
             * @readonly
             * @member {number}
             */
            _this.width = 100;
    
            /**
             * The height of the base texture set when the image has loaded
             *
             * @readonly
             * @member {number}
             */
            _this.height = 100;
    
            // TODO docs
            // used to store the actual dimensions of the source
            /**
             * Used to store the actual width of the source of this texture
             *
             * @readonly
             * @member {number}
             */
            _this.realWidth = 100;
            /**
             * Used to store the actual height of the source of this texture
             *
             * @readonly
             * @member {number}
             */
            _this.realHeight = 100;
    
            /**
             * The scale mode to apply when scaling this texture
             *
             * @member {number}
             * @default PIXI.settings.SCALE_MODE
             * @see PIXI.SCALE_MODES
             */
            _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
    
            /**
             * Set to true once the base texture has successfully loaded.
             *
             * This is never true if the underlying source fails to load or has no texture data.
             *
             * @readonly
             * @member {boolean}
             */
            _this.hasLoaded = false;
    
            /**
             * Set to true if the source is currently loading.
             *
             * If an Image source is loading the 'loaded' or 'error' event will be
             * dispatched when the operation ends. An underyling source that is
             * immediately-available bypasses loading entirely.
             *
             * @readonly
             * @member {boolean}
             */
            _this.isLoading = false;
    
            /**
             * The image source that is used to create the texture.
             *
             * TODO: Make this a setter that calls loadSource();
             *
             * @readonly
             * @member {HTMLImageElement|HTMLCanvasElement}
             */
            _this.source = null; // set in loadSource, if at all
    
            /**
             * The image source that is used to create the texture. This is used to
             * store the original Svg source when it is replaced with a canvas element.
             *
             * TODO: Currently not in use but could be used when re-scaling svg.
             *
             * @readonly
             * @member {Image}
             */
            _this.origSource = null; // set in loadSvg, if at all
    
            /**
             * Type of image defined in source, eg. `png` or `svg`
             *
             * @readonly
             * @member {string}
             */
            _this.imageType = null; // set in updateImageType
    
            /**
             * Scale for source image. Used with Svg images to scale them before rasterization.
             *
             * @readonly
             * @member {number}
             */
            _this.sourceScale = 1.0;
    
            /**
             * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)
             * All blend modes, and shaders written for default value. Change it on your own risk.
             *
             * @member {boolean}
             * @default true
             */
            _this.premultipliedAlpha = true;
    
            /**
             * The image url of the texture
             *
             * @member {string}
             */
            _this.imageUrl = null;
    
            /**
             * Whether or not the texture is a power of two, try to use power of two textures as much
             * as you can
             *
             * @private
             * @member {boolean}
             */
            _this.isPowerOfTwo = false;
    
            // used for webGL
    
            /**
             *
             * Set this to true if a mipmap of this texture needs to be generated. This value needs
             * to be set before the texture is used
             * Also the texture must be a power of two size to work
             *
             * @member {boolean}
             * @see PIXI.MIPMAP_TEXTURES
             */
            _this.mipmap = _settings2.default.MIPMAP_TEXTURES;
    
            /**
             *
             * WebGL Texture wrap mode
             *
             * @member {number}
             * @see PIXI.WRAP_MODES
             */
            _this.wrapMode = _settings2.default.WRAP_MODE;
    
            /**
             * A map of renderer IDs to webgl textures
             *
             * @private
             * @member {object<number, WebGLTexture>}
             */
            _this._glTextures = {};
    
            _this._enabled = 0;
            _this._virtalBoundId = -1;
    
            /**
             * If the object has been destroyed via destroy(). If true, it should not be used.
             *
             * @member {boolean}
             * @private
             * @readonly
             */
            _this._destroyed = false;
    
            /**
             * The ids under which this BaseTexture has been added to the base texture cache. This is
             * automatically set as long as BaseTexture.addToCache is used, but may not be set if a
             * BaseTexture is added directly to the BaseTextureCache array.
             *
             * @member {string[]}
             */
            _this.textureCacheIds = [];
    
            // if no source passed don't try to load
            if (source) {
                _this.loadSource(source);
            }
    
            /**
             * Fired when a not-immediately-available source finishes loading.
             *
             * @protected
             * @event PIXI.BaseTexture#loaded
             * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
             */
    
            /**
             * Fired when a not-immediately-available source fails to load.
             *
             * @protected
             * @event PIXI.BaseTexture#error
             * @param {PIXI.BaseTexture} baseTexture - Resource errored.
             */
    
            /**
             * Fired when BaseTexture is updated.
             *
             * @protected
             * @event PIXI.BaseTexture#update
             * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
             */
    
            /**
             * Fired when BaseTexture is destroyed.
             *
             * @protected
             * @event PIXI.BaseTexture#dispose
             * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
             */
            return _this;
        }
    
        /**
         * Updates the texture on all the webgl renderers, this also assumes the src has changed.
         *
         * @fires PIXI.BaseTexture#update
         */
    
    
        BaseTexture.prototype.update = function update() {
            // Svg size is handled during load
            if (this.imageType !== 'svg') {
                this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width;
                this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height;
    
                this._updateDimensions();
            }
    
            this.emit('update', this);
        };
    
        /**
         * Update dimensions from real values
         */
    
    
        BaseTexture.prototype._updateDimensions = function _updateDimensions() {
            this.width = this.realWidth / this.resolution;
            this.height = this.realHeight / this.resolution;
    
            this.isPowerOfTwo = _bitTwiddle2.default.isPow2(this.realWidth) && _bitTwiddle2.default.isPow2(this.realHeight);
        };
    
        /**
         * Load a source.
         *
         * If the source is not-immediately-available, such as an image that needs to be
         * downloaded, then the 'loaded' or 'error' event will be dispatched in the future
         * and `hasLoaded` will remain false after this call.
         *
         * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:
         *
         *     if (texture.hasLoaded) {
         *        // texture ready for use
         *     } else if (texture.isLoading) {
         *        // listen to 'loaded' and/or 'error' events on texture
         *     } else {
         *        // not loading, not going to load UNLESS the source is reloaded
         *        // (it may still make sense to listen to the events)
         *     }
         *
         * @protected
         * @param {HTMLImageElement|HTMLCanvasElement} source - the source object of the texture.
         */
    
    
        BaseTexture.prototype.loadSource = function loadSource(source) {
            var wasLoading = this.isLoading;
    
            this.hasLoaded = false;
            this.isLoading = false;
    
            if (wasLoading && this.source) {
                this.source.onload = null;
                this.source.onerror = null;
            }
    
            var firstSourceLoaded = !this.source;
    
            this.source = source;
    
            // Apply source if loaded. Otherwise setup appropriate loading monitors.
            if ((source.src && source.complete || source.getContext) && source.width && source.height) {
                this._updateImageType();
    
                if (this.imageType === 'svg') {
                    this._loadSvgSource();
                } else {
                    this._sourceLoaded();
                }
    
                if (firstSourceLoaded) {
                    // send loaded event if previous source was null and we have been passed a pre-loaded IMG element
                    this.emit('loaded', this);
                }
            } else if (!source.getContext) {
                // Image fail / not ready
                this.isLoading = true;
    
                var scope = this;
    
                source.onload = function () {
                    scope._updateImageType();
                    source.onload = null;
                    source.onerror = null;
    
                    if (!scope.isLoading) {
                        return;
                    }
    
                    scope.isLoading = false;
                    scope._sourceLoaded();
    
                    if (scope.imageType === 'svg') {
                        scope._loadSvgSource();
    
                        return;
                    }
    
                    scope.emit('loaded', scope);
                };
    
                source.onerror = function () {
                    source.onload = null;
                    source.onerror = null;
    
                    if (!scope.isLoading) {
                        return;
                    }
    
                    scope.isLoading = false;
                    scope.emit('error', scope);
                };
    
                // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element
                //   "The value of `complete` can thus change while a script is executing."
                // So complete needs to be re-checked after the callbacks have been added..
                // NOTE: complete will be true if the image has no src so best to check if the src is set.
                if (source.complete && source.src) {
                    // ..and if we're complete now, no need for callbacks
                    source.onload = null;
                    source.onerror = null;
    
                    if (scope.imageType === 'svg') {
                        scope._loadSvgSource();
    
                        return;
                    }
    
                    this.isLoading = false;
    
                    if (source.width && source.height) {
                        this._sourceLoaded();
    
                        // If any previous subscribers possible
                        if (wasLoading) {
                            this.emit('loaded', this);
                        }
                    }
                    // If any previous subscribers possible
                    else if (wasLoading) {
                            this.emit('error', this);
                        }
                }
            }
        };
    
        /**
         * Updates type of the source image.
         */
    
    
        BaseTexture.prototype._updateImageType = function _updateImageType() {
            if (!this.imageUrl) {
                return;
            }
    
            var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
            var imageType = void 0;
    
            if (dataUri && dataUri.mediaType === 'image') {
                // Check for subType validity
                var firstSubType = dataUri.subType.split('+')[0];
    
                imageType = (0, _utils.getUrlFileExtension)('.' + firstSubType);
    
                if (!imageType) {
                    throw new Error('Invalid image type in data URI.');
                }
            } else {
                imageType = (0, _utils.getUrlFileExtension)(this.imageUrl);
    
                if (!imageType) {
                    imageType = 'png';
                }
            }
    
            this.imageType = imageType;
        };
    
        /**
         * Checks if `source` is an SVG image and whether it's loaded via a URL or a data URI. Then calls
         * `_loadSvgSourceUsingDataUri` or `_loadSvgSourceUsingXhr`.
         */
    
    
        BaseTexture.prototype._loadSvgSource = function _loadSvgSource() {
            if (this.imageType !== 'svg') {
                // Do nothing if source is not svg
                return;
            }
    
            var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
    
            if (dataUri) {
                this._loadSvgSourceUsingDataUri(dataUri);
            } else {
                // We got an URL, so we need to do an XHR to check the svg size
                this._loadSvgSourceUsingXhr();
            }
        };
    
        /**
         * Reads an SVG string from data URI and then calls `_loadSvgSourceUsingString`.
         *
         * @param {string} dataUri - The data uri to load from.
         */
    
    
        BaseTexture.prototype._loadSvgSourceUsingDataUri = function _loadSvgSourceUsingDataUri(dataUri) {
            var svgString = void 0;
    
            if (dataUri.encoding === 'base64') {
                if (!atob) {
                    throw new Error('Your browser doesn\'t support base64 conversions.');
                }
                svgString = atob(dataUri.data);
            } else {
                svgString = dataUri.data;
            }
    
            this._loadSvgSourceUsingString(svgString);
        };
    
        /**
         * Loads an SVG string from `imageUrl` using XHR and then calls `_loadSvgSourceUsingString`.
         */
    
    
        BaseTexture.prototype._loadSvgSourceUsingXhr = function _loadSvgSourceUsingXhr() {
            var _this2 = this;
    
            var svgXhr = new XMLHttpRequest();
    
            // This throws error on IE, so SVG Document can't be used
            // svgXhr.responseType = 'document';
    
            // This is not needed since we load the svg as string (breaks IE too)
            // but overrideMimeType() can be used to force the response to be parsed as XML
            // svgXhr.overrideMimeType('image/svg+xml');
    
            svgXhr.onload = function () {
                if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
                    throw new Error('Failed to load SVG using XHR.');
                }
    
                _this2._loadSvgSourceUsingString(svgXhr.response);
            };
    
            svgXhr.onerror = function () {
                return _this2.emit('error', _this2);
            };
    
            svgXhr.open('GET', this.imageUrl, true);
            svgXhr.send();
        };
    
        /**
         * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
         * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
         * `_loadSvgSourceUsingXhr` or `_loadSvgSourceUsingDataUri`.
         *
         * @param  {string} svgString SVG source as string
         *
         * @fires PIXI.BaseTexture#loaded
         */
    
    
        BaseTexture.prototype._loadSvgSourceUsingString = function _loadSvgSourceUsingString(svgString) {
            var svgSize = (0, _utils.getSvgSize)(svgString);
    
            var svgWidth = svgSize.width;
            var svgHeight = svgSize.height;
    
            if (!svgWidth || !svgHeight) {
                throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
            }
    
            // Scale realWidth and realHeight
            this.realWidth = Math.round(svgWidth * this.sourceScale);
            this.realHeight = Math.round(svgHeight * this.sourceScale);
    
            this._updateDimensions();
    
            // Create a canvas element
            var canvas = document.createElement('canvas');
    
            canvas.width = this.realWidth;
            canvas.height = this.realHeight;
            canvas._pixiId = 'canvas_' + (0, _utils.uid)();
    
            // Draw the Svg to the canvas
            canvas.getContext('2d').drawImage(this.source, 0, 0, svgWidth, svgHeight, 0, 0, this.realWidth, this.realHeight);
    
            // Replace the original source image with the canvas
            this.origSource = this.source;
            this.source = canvas;
    
            // Add also the canvas in cache (destroy clears by `imageUrl` and `source._pixiId`)
            BaseTexture.addToCache(this, canvas._pixiId);
    
            this.isLoading = false;
            this._sourceLoaded();
            this.emit('loaded', this);
        };
    
        /**
         * Used internally to update the width, height, and some other tracking vars once
         * a source has successfully loaded.
         *
         * @private
         */
    
    
        BaseTexture.prototype._sourceLoaded = function _sourceLoaded() {
            this.hasLoaded = true;
            this.update();
        };
    
        /**
         * Destroys this base texture
         *
         */
    
    
        BaseTexture.prototype.destroy = function destroy() {
            if (this.imageUrl) {
                delete _utils.TextureCache[this.imageUrl];
    
                this.imageUrl = null;
    
                if (!navigator.isCocoonJS) {
                    this.source.src = '';
                }
            }
    
            this.source = null;
    
            this.dispose();
    
            BaseTexture.removeFromCache(this);
            this.textureCacheIds = null;
    
            this._destroyed = true;
        };
    
        /**
         * Frees the texture from WebGL memory without destroying this texture object.
         * This means you can still use the texture later which will upload it to GPU
         * memory again.
         *
         * @fires PIXI.BaseTexture#dispose
         */
    
    
        BaseTexture.prototype.dispose = function dispose() {
            this.emit('dispose', this);
        };
    
        /**
         * Changes the source image of the texture.
         * The original source must be an Image element.
         *
         * @param {string} newSrc - the path of the image
         */
    
    
        BaseTexture.prototype.updateSourceImage = function updateSourceImage(newSrc) {
            this.source.src = newSrc;
    
            this.loadSource(this.source);
        };
    
        /**
         * Helper function that creates a base texture from the given image url.
         * If the image is not in the base texture cache it will be created and loaded.
         *
         * @static
         * @param {string} imageUrl - The image url of the texture
         * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
         * @return {PIXI.BaseTexture} The new base texture.
         */
    
    
        BaseTexture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
            var baseTexture = _utils.BaseTextureCache[imageUrl];
    
            if (!baseTexture) {
                // new Image() breaks tex loading in some versions of Chrome.
                // See https://code.google.com/p/chromium/issues/detail?id=238071
                var image = new Image(); // document.createElement('img');
    
                if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) {
                    image.crossOrigin = (0, _determineCrossOrigin2.default)(imageUrl);
                }
    
                baseTexture = new BaseTexture(image, scaleMode);
                baseTexture.imageUrl = imageUrl;
    
                if (sourceScale) {
                    baseTexture.sourceScale = sourceScale;
                }
    
                // if there is an @2x at the end of the url we are going to assume its a highres image
                baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);
    
                image.src = imageUrl; // Setting this triggers load
    
                BaseTexture.addToCache(baseTexture, imageUrl);
            }
    
            return baseTexture;
        };
    
        /**
         * Helper function that creates a base texture from the given canvas element.
         *
         * @static
         * @param {HTMLCanvasElement} canvas - The canvas element source of the texture
         * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
         * @param {string} [origin='canvas'] - A string origin of who created the base texture
         * @return {PIXI.BaseTexture} The new base texture.
         */
    
    
        BaseTexture.fromCanvas = function fromCanvas(canvas, scaleMode) {
            var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';
    
            if (!canvas._pixiId) {
                canvas._pixiId = origin + '_' + (0, _utils.uid)();
            }
    
            var baseTexture = _utils.BaseTextureCache[canvas._pixiId];
    
            if (!baseTexture) {
                baseTexture = new BaseTexture(canvas, scaleMode);
                BaseTexture.addToCache(baseTexture, canvas._pixiId);
            }
    
            return baseTexture;
        };
    
        /**
         * Helper function that creates a base texture based on the source you provide.
         * The source can be - image url, image element, canvas element.
         *
         * @static
         * @param {string|HTMLImageElement|HTMLCanvasElement} source - The source to create base texture from.
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [sourceScale=(auto)] - Scale for the original image, used with Svg images.
         * @return {PIXI.BaseTexture} The new base texture.
         */
    
    
        BaseTexture.from = function from(source, scaleMode, sourceScale) {
            if (typeof source === 'string') {
                return BaseTexture.fromImage(source, undefined, scaleMode, sourceScale);
            } else if (source instanceof HTMLImageElement) {
                var imageUrl = source.src;
                var baseTexture = _utils.BaseTextureCache[imageUrl];
    
                if (!baseTexture) {
                    baseTexture = new BaseTexture(source, scaleMode);
                    baseTexture.imageUrl = imageUrl;
    
                    if (sourceScale) {
                        baseTexture.sourceScale = sourceScale;
                    }
    
                    // if there is an @2x at the end of the url we are going to assume its a highres image
                    baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);
    
                    BaseTexture.addToCache(baseTexture, imageUrl);
                }
    
                return baseTexture;
            } else if (source instanceof HTMLCanvasElement) {
                return BaseTexture.fromCanvas(source, scaleMode);
            }
    
            // lets assume its a base texture!
            return source;
        };
    
        /**
         * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
         *
         * @static
         * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
         * @param {string} id - The id that the BaseTexture will be stored against.
         */
    
    
        BaseTexture.addToCache = function addToCache(baseTexture, id) {
            if (id) {
                if (baseTexture.textureCacheIds.indexOf(id) === -1) {
                    baseTexture.textureCacheIds.push(id);
                }
    
                // @if DEBUG
                /* eslint-disable no-console */
                if (_utils.BaseTextureCache[id]) {
                    console.warn('BaseTexture added to the cache with an id [' + id + '] that already had an entry');
                }
                /* eslint-enable no-console */
                // @endif
    
                _utils.BaseTextureCache[id] = baseTexture;
            }
        };
    
        /**
         * Remove a BaseTexture from the global BaseTextureCache.
         *
         * @static
         * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
         * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
         */
    
    
        BaseTexture.removeFromCache = function removeFromCache(baseTexture) {
            if (typeof baseTexture === 'string') {
                var baseTextureFromCache = _utils.BaseTextureCache[baseTexture];
    
                if (baseTextureFromCache) {
                    var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
    
                    if (index > -1) {
                        baseTextureFromCache.textureCacheIds.splice(index, 1);
                    }
    
                    delete _utils.BaseTextureCache[baseTexture];
    
                    return baseTextureFromCache;
                }
            } else if (baseTexture && baseTexture.textureCacheIds) {
                for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
                    delete _utils.BaseTextureCache[baseTexture.textureCacheIds[i]];
                }
    
                baseTexture.textureCacheIds.length = 0;
    
                return baseTexture;
            }
    
            return null;
        };
    
        return BaseTexture;
    }(_eventemitter2.default);
    
    exports.default = BaseTexture;
    
    /***/ }),
    /* 10 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _SystemRenderer2 = __webpack_require__(52);
    
    var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);
    
    var _CanvasMaskManager = __webpack_require__(116);
    
    var _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);
    
    var _CanvasRenderTarget = __webpack_require__(54);
    
    var _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);
    
    var _mapCanvasBlendModesToPixi = __webpack_require__(117);
    
    var _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);
    
    var _utils = __webpack_require__(1);
    
    var _const = __webpack_require__(0);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should
     * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to
     * your DOM or you will not see anything :)
     *
     * @class
     * @memberof PIXI
     * @extends PIXI.SystemRenderer
     */
    var CanvasRenderer = function (_SystemRenderer) {
        _inherits(CanvasRenderer, _SystemRenderer);
    
        // eslint-disable-next-line valid-jsdoc
        /**
         * @param {object} [options] - The optional renderer parameters
         * @param {number} [options.width=800] - the width of the screen
         * @param {number} [options.height=600] - the height of the screen
         * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
         * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
         * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
         * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
         * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
         *  resolution of the renderer retina would be 2.
         * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear the canvas or
         *      not before the new render pass.
         * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
         *  (shown if not transparent).
         * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when rendering,
         *  stopping pixel interpolation.
         */
        function CanvasRenderer(options, arg2, arg3) {
            _classCallCheck(this, CanvasRenderer);
    
            var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'Canvas', options, arg2, arg3));
    
            _this.type = _const.RENDERER_TYPE.CANVAS;
    
            /**
             * The canvas 2d context that everything is drawn with.
             *
             * @member {CanvasRenderingContext2D}
             */
            _this.rootContext = _this.view.getContext('2d', { alpha: _this.transparent });
    
            /**
             * Boolean flag controlling canvas refresh.
             *
             * @member {boolean}
             */
            _this.refresh = true;
    
            /**
             * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.
             *
             * @member {PIXI.CanvasMaskManager}
             */
            _this.maskManager = new _CanvasMaskManager2.default(_this);
    
            /**
             * The canvas property used to set the canvas smoothing property.
             *
             * @member {string}
             */
            _this.smoothProperty = 'imageSmoothingEnabled';
    
            if (!_this.rootContext.imageSmoothingEnabled) {
                if (_this.rootContext.webkitImageSmoothingEnabled) {
                    _this.smoothProperty = 'webkitImageSmoothingEnabled';
                } else if (_this.rootContext.mozImageSmoothingEnabled) {
                    _this.smoothProperty = 'mozImageSmoothingEnabled';
                } else if (_this.rootContext.oImageSmoothingEnabled) {
                    _this.smoothProperty = 'oImageSmoothingEnabled';
                } else if (_this.rootContext.msImageSmoothingEnabled) {
                    _this.smoothProperty = 'msImageSmoothingEnabled';
                }
            }
    
            _this.initPlugins();
    
            _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();
            _this._activeBlendMode = null;
    
            _this.context = null;
            _this.renderingToScreen = false;
    
            _this.resize(_this.options.width, _this.options.height);
    
            /**
             * Fired after rendering finishes.
             *
             * @event PIXI.CanvasRenderer#postrender
             */
    
            /**
             * Fired before rendering starts.
             *
             * @event PIXI.CanvasRenderer#prerender
             */
            return _this;
        }
    
        /**
         * Renders the object to this canvas view
         *
         * @param {PIXI.DisplayObject} displayObject - The object to be rendered
         * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.
         *  If unset, it will render to the root context.
         * @param {boolean} [clear=false] - Whether to clear the canvas before drawing
         * @param {PIXI.Transform} [transform] - A transformation to be applied
         * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform
         */
    
    
        CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
            if (!this.view) {
                return;
            }
    
            // can be handy to know!
            this.renderingToScreen = !renderTexture;
    
            this.emit('prerender');
    
            var rootResolution = this.resolution;
    
            if (renderTexture) {
                renderTexture = renderTexture.baseTexture || renderTexture;
    
                if (!renderTexture._canvasRenderTarget) {
                    renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);
                    renderTexture.source = renderTexture._canvasRenderTarget.canvas;
                    renderTexture.valid = true;
                }
    
                this.context = renderTexture._canvasRenderTarget.context;
                this.resolution = renderTexture._canvasRenderTarget.resolution;
            } else {
                this.context = this.rootContext;
            }
    
            var context = this.context;
    
            if (!renderTexture) {
                this._lastObjectRendered = displayObject;
            }
    
            if (!skipUpdateTransform) {
                // update the scene graph
                var cacheParent = displayObject.parent;
                var tempWt = this._tempDisplayObjectParent.transform.worldTransform;
    
                if (transform) {
                    transform.copy(tempWt);
    
                    // lets not forget to flag the parent transform as dirty...
                    this._tempDisplayObjectParent.transform._worldID = -1;
                } else {
                    tempWt.identity();
                }
    
                displayObject.parent = this._tempDisplayObjectParent;
    
                displayObject.updateTransform();
                displayObject.parent = cacheParent;
                // displayObject.hitArea = //TODO add a temp hit area
            }
    
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.globalAlpha = 1;
            context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];
    
            if (navigator.isCocoonJS && this.view.screencanvas) {
                context.fillStyle = 'black';
                context.clear();
            }
    
            if (clear !== undefined ? clear : this.clearBeforeRender) {
                if (this.renderingToScreen) {
                    if (this.transparent) {
                        context.clearRect(0, 0, this.width, this.height);
                    } else {
                        context.fillStyle = this._backgroundColorString;
                        context.fillRect(0, 0, this.width, this.height);
                    }
                } else {
                    // TODO: implement background for CanvasRenderTarget or RenderTexture?
                    if (this.transparent) {
                        context.clearRect(0, 0, this.width, this.height);
                    } else {
                        context.fillStyle = this._backgroundColorString;
                        context.fillRect(0, 0, this.width, this.height);
                    }
                }
            }
    
            // TODO RENDER TARGET STUFF HERE..
            var tempContext = this.context;
    
            this.context = context;
            displayObject.renderCanvas(this);
            this.context = tempContext;
    
            this.resolution = rootResolution;
    
            this.emit('postrender');
        };
    
        /**
         * Clear the canvas of renderer.
         *
         * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.
         */
    
    
        CanvasRenderer.prototype.clear = function clear(clearColor) {
            var context = this.context;
    
            clearColor = clearColor || this._backgroundColorString;
    
            if (!this.transparent && clearColor) {
                context.fillStyle = clearColor;
                context.fillRect(0, 0, this.width, this.height);
            } else {
                context.clearRect(0, 0, this.width, this.height);
            }
        };
    
        /**
         * Sets the blend mode of the renderer.
         *
         * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.
         */
    
    
        CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
            if (this._activeBlendMode === blendMode) {
                return;
            }
    
            this._activeBlendMode = blendMode;
            this.context.globalCompositeOperation = this.blendModes[blendMode];
        };
    
        /**
         * Removes everything from the renderer and optionally removes the Canvas DOM element.
         *
         * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
         */
    
    
        CanvasRenderer.prototype.destroy = function destroy(removeView) {
            this.destroyPlugins();
    
            // call the base destroy
            _SystemRenderer.prototype.destroy.call(this, removeView);
    
            this.context = null;
    
            this.refresh = true;
    
            this.maskManager.destroy();
            this.maskManager = null;
    
            this.smoothProperty = null;
        };
    
        /**
         * Resizes the canvas view to the specified width and height.
         *
         * @extends PIXI.SystemRenderer#resize
         *
         * @param {number} screenWidth - the new width of the screen
         * @param {number} screenHeight - the new height of the screen
         */
    
    
        CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
            _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);
    
            // reset the scale mode.. oddly this seems to be reset when the canvas is resized.
            // surely a browser bug?? Let pixi fix that for you..
            if (this.smoothProperty) {
                this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;
            }
        };
    
        return CanvasRenderer;
    }(_SystemRenderer3.default);
    
    /**
     * Collection of installed plugins. These are included by default in PIXI, but can be excluded
     * by creating a custom build. Consult the README for more information about creating custom
     * builds and excluding plugins.
     * @name PIXI.CanvasRenderer#plugins
     * @type {object}
     * @readonly
     * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.
     * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.
     * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.
     * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.
     */
    
    /**
     * Adds a plugin to the renderer.
     *
     * @method PIXI.CanvasRenderer#registerPlugin
     * @param {string} pluginName - The name of the plugin.
     * @param {Function} ctor - The constructor function or class for the plugin.
     */
    
    exports.default = CanvasRenderer;
    _utils.pluginTarget.mixin(CanvasRenderer);
    
    /***/ }),
    /* 11 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * @class
     * @memberof PIXI
     */
    var WebGLManager = function () {
      /**
       * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
       */
      function WebGLManager(renderer) {
        _classCallCheck(this, WebGLManager);
    
        /**
         * The renderer this manager works for.
         *
         * @member {PIXI.WebGLRenderer}
         */
        this.renderer = renderer;
    
        this.renderer.on('context', this.onContextChange, this);
      }
    
      /**
       * Generic method called when there is a WebGL context change.
       *
       */
    
    
      WebGLManager.prototype.onContextChange = function onContextChange() {}
      // do some codes init!
    
    
      /**
       * Generic destroy methods to be overridden by the subclass
       *
       */
      ;
    
      WebGLManager.prototype.destroy = function destroy() {
        this.renderer.off('context', this.onContextChange, this);
    
        this.renderer = null;
      };
    
      return WebGLManager;
    }();
    
    exports.default = WebGLManager;
    
    /***/ }),
    /* 12 */
    /***/ (function(module, exports) {
    
    var g;
    
    // This works in non-strict mode
    g = (function() {
        return this;
    })();
    
    try {
        // This works if eval is allowed (see CSP)
        g = g || Function("return this")() || (1,eval)("this");
    } catch(e) {
        // This works if the window reference is available
        if(typeof window === "object")
            g = window;
    }
    
    // g can still be undefined, but nothing to do about it...
    // We return undefined, instead of nothing here, so it's
    // easier to handle this case. if(!global) { ...}
    
    module.exports = g;
    
    
    /***/ }),
    /* 13 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _WebGLManager2 = __webpack_require__(11);
    
    var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * Base for a common object renderer that can be used as a system renderer plugin.
     *
     * @class
     * @extends PIXI.WebGLManager
     * @memberof PIXI
     */
    var ObjectRenderer = function (_WebGLManager) {
      _inherits(ObjectRenderer, _WebGLManager);
    
      function ObjectRenderer() {
        _classCallCheck(this, ObjectRenderer);
    
        return _possibleConstructorReturn(this, _WebGLManager.apply(this, arguments));
      }
    
      /**
       * Starts the renderer and sets the shader
       *
       */
      ObjectRenderer.prototype.start = function start() {}
      // set the shader..
    
    
      /**
       * Stops the renderer
       *
       */
      ;
    
      ObjectRenderer.prototype.stop = function stop() {
        this.flush();
      };
    
      /**
       * Stub method for rendering content and emptying the current batch.
       *
       */
    
    
      ObjectRenderer.prototype.flush = function flush() {}
      // flush!
    
    
      /**
       * Renders an object
       *
       * @param {PIXI.DisplayObject} object - The object to render.
       */
      ;
    
      ObjectRenderer.prototype.render = function render(object) // eslint-disable-line no-unused-vars
      {
        // render the object
      };
    
      return ObjectRenderer;
    }(_WebGLManager3.default);
    
    exports.default = ObjectRenderer;
    
    /***/ }),
    /* 14 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _SystemRenderer2 = __webpack_require__(52);
    
    var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);
    
    var _MaskManager = __webpack_require__(119);
    
    var _MaskManager2 = _interopRequireDefault(_MaskManager);
    
    var _StencilManager = __webpack_require__(122);
    
    var _StencilManager2 = _interopRequireDefault(_StencilManager);
    
    var _FilterManager = __webpack_require__(123);
    
    var _FilterManager2 = _interopRequireDefault(_FilterManager);
    
    var _RenderTarget = __webpack_require__(15);
    
    var _RenderTarget2 = _interopRequireDefault(_RenderTarget);
    
    var _ObjectRenderer = __webpack_require__(13);
    
    var _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);
    
    var _TextureManager = __webpack_require__(125);
    
    var _TextureManager2 = _interopRequireDefault(_TextureManager);
    
    var _BaseTexture = __webpack_require__(9);
    
    var _BaseTexture2 = _interopRequireDefault(_BaseTexture);
    
    var _TextureGarbageCollector = __webpack_require__(126);
    
    var _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);
    
    var _WebGLState = __webpack_require__(127);
    
    var _WebGLState2 = _interopRequireDefault(_WebGLState);
    
    var _mapWebGLDrawModesToPixi = __webpack_require__(129);
    
    var _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);
    
    var _validateContext = __webpack_require__(130);
    
    var _validateContext2 = _interopRequireDefault(_validateContext);
    
    var _utils = __webpack_require__(1);
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
    
    var _const = __webpack_require__(0);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var CONTEXT_UID = 0;
    
    /**
     * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer
     * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.
     * So no need for Sprite Batches or Sprite Clouds.
     * Don't forget to add the view to your DOM or you will not see anything :)
     *
     * @class
     * @memberof PIXI
     * @extends PIXI.SystemRenderer
     */
    
    var WebGLRenderer = function (_SystemRenderer) {
        _inherits(WebGLRenderer, _SystemRenderer);
    
        // eslint-disable-next-line valid-jsdoc
        /**
         *
         * @param {object} [options] - The optional renderer parameters
         * @param {number} [options.width=800] - the width of the screen
         * @param {number} [options.height=600] - the height of the screen
         * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
         * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
         * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
         * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA
         *  antialiasing is used
         * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.
         *  FXAA is faster, but may not always look as great
         * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.
         *  The resolution of the renderer retina would be 2.
         * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear
         *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set
         *  preserveDrawingBuffer to `true`.
         * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,
         *  enable this if you need to call toDataUrl on the webgl context.
         * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when
         *  rendering, stopping pixel interpolation.
         * @param {boolean} [options.legacy=false] - If true Pixi will aim to ensure compatibility
         * with older / less advanced devices. If you experiance unexplained flickering try setting this to true.
         */
        function WebGLRenderer(options, arg2, arg3) {
            _classCallCheck(this, WebGLRenderer);
    
            var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'WebGL', options, arg2, arg3));
    
            _this.legacy = _this.options.legacy;
    
            if (_this.legacy) {
                _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true;
            }
    
            /**
             * The type of this renderer as a standardised const
             *
             * @member {number}
             * @see PIXI.RENDERER_TYPE
             */
            _this.type = _const.RENDERER_TYPE.WEBGL;
    
            _this.handleContextLost = _this.handleContextLost.bind(_this);
            _this.handleContextRestored = _this.handleContextRestored.bind(_this);
    
            _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);
            _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);
    
            /**
             * The options passed in to create a new webgl context.
             *
             * @member {object}
             * @private
             */
            _this._contextOptions = {
                alpha: _this.transparent,
                antialias: _this.options.antialias,
                premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied',
                stencil: true,
                preserveDrawingBuffer: _this.options.preserveDrawingBuffer
            };
    
            _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;
    
            /**
             * Manages the masks using the stencil buffer.
             *
             * @member {PIXI.MaskManager}
             */
            _this.maskManager = new _MaskManager2.default(_this);
    
            /**
             * Manages the stencil buffer.
             *
             * @member {PIXI.StencilManager}
             */
            _this.stencilManager = new _StencilManager2.default(_this);
    
            /**
             * An empty renderer.
             *
             * @member {PIXI.ObjectRenderer}
             */
            _this.emptyRenderer = new _ObjectRenderer2.default(_this);
    
            /**
             * The currently active ObjectRenderer.
             *
             * @member {PIXI.ObjectRenderer}
             */
            _this.currentRenderer = _this.emptyRenderer;
    
            _this.initPlugins();
    
            /**
             * The current WebGL rendering context, it is created here
             *
             * @member {WebGLRenderingContext}
             */
            // initialize the context so it is ready for the managers.
            if (_this.options.context) {
                // checks to see if a context is valid..
                (0, _validateContext2.default)(_this.options.context);
            }
    
            _this.gl = _this.options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);
    
            _this.CONTEXT_UID = CONTEXT_UID++;
    
            /**
             * The currently active ObjectRenderer.
             *
             * @member {PIXI.WebGLState}
             */
            _this.state = new _WebGLState2.default(_this.gl);
    
            _this.renderingToScreen = true;
    
            /**
             * Holds the current state of textures bound to the GPU.
             * @type {Array}
             */
            _this.boundTextures = null;
    
            /**
             * Holds the current shader
             *
             * @member {PIXI.Shader}
             */
            _this._activeShader = null;
    
            _this._activeVao = null;
    
            /**
             * Holds the current render target
             *
             * @member {PIXI.RenderTarget}
             */
            _this._activeRenderTarget = null;
    
            _this._initContext();
    
            /**
             * Manages the filters.
             *
             * @member {PIXI.FilterManager}
             */
            _this.filterManager = new _FilterManager2.default(_this);
            // map some webGL blend and drawmodes..
            _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);
    
            _this._nextTextureLocation = 0;
    
            _this.setBlendMode(0);
    
            /**
             * Fired after rendering finishes.
             *
             * @event PIXI.WebGLRenderer#postrender
             */
    
            /**
             * Fired before rendering starts.
             *
             * @event PIXI.WebGLRenderer#prerender
             */
    
            /**
             * Fired when the WebGL context is set.
             *
             * @event PIXI.WebGLRenderer#context
             * @param {WebGLRenderingContext} gl - WebGL context.
             */
            return _this;
        }
    
        /**
         * Creates the WebGL context
         *
         * @private
         */
    
    
        WebGLRenderer.prototype._initContext = function _initContext() {
            var gl = this.gl;
    
            // restore a context if it was previously lost
            if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
                gl.getExtension('WEBGL_lose_context').restoreContext();
            }
    
            var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    
            this.boundTextures = new Array(maxTextures);
            this.emptyTextures = new Array(maxTextures);
    
            // create a texture manager...
            this.textureManager = new _TextureManager2.default(this);
            this.textureGC = new _TextureGarbageCollector2.default(this);
    
            this.state.resetToDefault();
    
            this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);
            this.rootRenderTarget.clearColor = this._backgroundColorRgba;
    
            this.bindRenderTarget(this.rootRenderTarget);
    
            // now lets fill up the textures with empty ones!
            var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);
    
            var tempObj = { _glTextures: {} };
    
            tempObj._glTextures[this.CONTEXT_UID] = {};
    
            for (var i = 0; i < maxTextures; i++) {
                var empty = new _BaseTexture2.default();
    
                empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;
    
                this.boundTextures[i] = tempObj;
                this.emptyTextures[i] = empty;
                this.bindTexture(null, i);
            }
    
            this.emit('context', gl);
    
            // setup the width/height properties and gl viewport
            this.resize(this.screen.width, this.screen.height);
        };
    
        /**
         * Renders the object to its webGL view
         *
         * @param {PIXI.DisplayObject} displayObject - the object to be rendered
         * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.
         * @param {boolean} [clear] - Should the canvas be cleared before the new render
         * @param {PIXI.Transform} [transform] - A transform to apply to the render texture before rendering.
         * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?
         */
    
    
        WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
            // can be handy to know!
            this.renderingToScreen = !renderTexture;
    
            this.emit('prerender');
    
            // no point rendering if our context has been blown up!
            if (!this.gl || this.gl.isContextLost()) {
                return;
            }
    
            this._nextTextureLocation = 0;
    
            if (!renderTexture) {
                this._lastObjectRendered = displayObject;
            }
    
            if (!skipUpdateTransform) {
                // update the scene graph
                var cacheParent = displayObject.parent;
    
                displayObject.parent = this._tempDisplayObjectParent;
                displayObject.updateTransform();
                displayObject.parent = cacheParent;
                // displayObject.hitArea = //TODO add a temp hit area
            }
    
            this.bindRenderTexture(renderTexture, transform);
    
            this.currentRenderer.start();
    
            if (clear !== undefined ? clear : this.clearBeforeRender) {
                this._activeRenderTarget.clear();
            }
    
            displayObject.renderWebGL(this);
    
            // apply transform..
            this.currentRenderer.flush();
    
            // this.setObjectRenderer(this.emptyRenderer);
    
            this.textureGC.update();
    
            this.emit('postrender');
        };
    
        /**
         * Changes the current renderer to the one given in parameter
         *
         * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
         */
    
    
        WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {
            if (this.currentRenderer === objectRenderer) {
                return;
            }
    
            this.currentRenderer.stop();
            this.currentRenderer = objectRenderer;
            this.currentRenderer.start();
        };
    
        /**
         * This should be called if you wish to do some custom rendering
         * It will basically render anything that may be batched up such as sprites
         *
         */
    
    
        WebGLRenderer.prototype.flush = function flush() {
            this.setObjectRenderer(this.emptyRenderer);
        };
    
        /**
         * Resizes the webGL view to the specified width and height.
         *
         * @param {number} screenWidth - the new width of the screen
         * @param {number} screenHeight - the new height of the screen
         */
    
    
        WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
            //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;
    
            _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);
    
            this.rootRenderTarget.resize(screenWidth, screenHeight);
    
            if (this._activeRenderTarget === this.rootRenderTarget) {
                this.rootRenderTarget.activate();
    
                if (this._activeShader) {
                    this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);
                }
            }
        };
    
        /**
         * Resizes the webGL view to the specified width and height.
         *
         * @param {number} blendMode - the desired blend mode
         */
    
    
        WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
            this.state.setBlendMode(blendMode);
        };
    
        /**
         * Erases the active render target and fills the drawing area with a colour
         *
         * @param {number} [clearColor] - The colour
         */
    
    
        WebGLRenderer.prototype.clear = function clear(clearColor) {
            this._activeRenderTarget.clear(clearColor);
        };
    
        /**
         * Sets the transform of the active render target to the given matrix
         *
         * @param {PIXI.Matrix} matrix - The transformation matrix
         */
    
    
        WebGLRenderer.prototype.setTransform = function setTransform(matrix) {
            this._activeRenderTarget.transform = matrix;
        };
    
        /**
         * Erases the render texture and fills the drawing area with a colour
         *
         * @param {PIXI.RenderTexture} renderTexture - The render texture to clear
         * @param {number} [clearColor] - The colour
         * @return {PIXI.WebGLRenderer} Returns itself.
         */
    
    
        WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {
            var baseTexture = renderTexture.baseTexture;
            var renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
    
            if (renderTarget) {
                renderTarget.clear(clearColor);
            }
    
            return this;
        };
    
        /**
         * Binds a render texture for rendering
         *
         * @param {PIXI.RenderTexture} renderTexture - The render texture to render
         * @param {PIXI.Transform} transform - The transform to be applied to the render texture
         * @return {PIXI.WebGLRenderer} Returns itself.
         */
    
    
        WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {
            var renderTarget = void 0;
    
            if (renderTexture) {
                var baseTexture = renderTexture.baseTexture;
    
                if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {
                    // bind the current texture
                    this.textureManager.updateTexture(baseTexture, 0);
                }
    
                this.unbindTexture(baseTexture);
    
                renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
                renderTarget.setFrame(renderTexture.frame);
            } else {
                renderTarget = this.rootRenderTarget;
            }
    
            renderTarget.transform = transform;
            this.bindRenderTarget(renderTarget);
    
            return this;
        };
    
        /**
         * Changes the current render target to the one given in parameter
         *
         * @param {PIXI.RenderTarget} renderTarget - the new render target
         * @return {PIXI.WebGLRenderer} Returns itself.
         */
    
    
        WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {
            if (renderTarget !== this._activeRenderTarget) {
                this._activeRenderTarget = renderTarget;
                renderTarget.activate();
    
                if (this._activeShader) {
                    this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);
                }
    
                this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);
            }
    
            return this;
        };
    
        /**
         * Changes the current shader to the one given in parameter
         *
         * @param {PIXI.Shader} shader - the new shader
         * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix
         * @return {PIXI.WebGLRenderer} Returns itself.
         */
    
    
        WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {
            // TODO cache
            if (this._activeShader !== shader) {
                this._activeShader = shader;
                shader.bind();
    
                // `autoProject` normally would be a default parameter set to true
                // but because of how Babel transpiles default parameters
                // it hinders the performance of this method.
                if (autoProject !== false) {
                    // automatically set the projection matrix
                    shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);
                }
            }
    
            return this;
        };
    
        /**
         * Binds the texture. This will return the location of the bound texture.
         * It may not be the same as the one you pass in. This is due to optimisation that prevents
         * needless binding of textures. For example if the texture is already bound it will return the
         * current location of the texture instead of the one provided. To bypass this use force location
         *
         * @param {PIXI.Texture} texture - the new texture
         * @param {number} location - the suggested texture location
         * @param {boolean} forceLocation - force the location
         * @return {PIXI.WebGLRenderer} Returns itself.
         */
    
    
        WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {
            texture = texture || this.emptyTextures[location];
            texture = texture.baseTexture || texture;
            texture.touched = this.textureGC.count;
    
            if (!forceLocation) {
                // TODO - maybe look into adding boundIds.. save us the loop?
                for (var i = 0; i < this.boundTextures.length; i++) {
                    if (this.boundTextures[i] === texture) {
                        return i;
                    }
                }
    
                if (location === undefined) {
                    this._nextTextureLocation++;
                    this._nextTextureLocation %= this.boundTextures.length;
                    location = this.boundTextures.length - this._nextTextureLocation - 1;
                }
            } else {
                location = location || 0;
            }
    
            var gl = this.gl;
            var glTexture = texture._glTextures[this.CONTEXT_UID];
    
            if (!glTexture) {
                // this will also bind the texture..
                this.textureManager.updateTexture(texture, location);
            } else {
                // bind the current texture
                this.boundTextures[location] = texture;
                gl.activeTexture(gl.TEXTURE0 + location);
                gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
            }
    
            return location;
        };
    
        /**
        * unbinds the texture ...
        *
        * @param {PIXI.Texture} texture - the texture to unbind
        * @return {PIXI.WebGLRenderer} Returns itself.
        */
    
    
        WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {
            var gl = this.gl;
    
            texture = texture.baseTexture || texture;
    
            for (var i = 0; i < this.boundTextures.length; i++) {
                if (this.boundTextures[i] === texture) {
                    this.boundTextures[i] = this.emptyTextures[i];
    
                    gl.activeTexture(gl.TEXTURE0 + i);
                    gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);
                }
            }
    
            return this;
        };
    
        /**
         * Creates a new VAO from this renderer's context and state.
         *
         * @return {VertexArrayObject} The new VAO.
         */
    
    
        WebGLRenderer.prototype.createVao = function createVao() {
            return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);
        };
    
        /**
         * Changes the current Vao to the one given in parameter
         *
         * @param {PIXI.VertexArrayObject} vao - the new Vao
         * @return {PIXI.WebGLRenderer} Returns itself.
         */
    
    
        WebGLRenderer.prototype.bindVao = function bindVao(vao) {
            if (this._activeVao === vao) {
                return this;
            }
    
            if (vao) {
                vao.bind();
            } else if (this._activeVao) {
                // TODO this should always be true i think?
                this._activeVao.unbind();
            }
    
            this._activeVao = vao;
    
            return this;
        };
    
        /**
         * Resets the WebGL state so you can render things however you fancy!
         *
         * @return {PIXI.WebGLRenderer} Returns itself.
         */
    
    
        WebGLRenderer.prototype.reset = function reset() {
            this.setObjectRenderer(this.emptyRenderer);
    
            this._activeShader = null;
            this._activeRenderTarget = this.rootRenderTarget;
    
            // bind the main frame buffer (the screen);
            this.rootRenderTarget.activate();
    
            this.state.resetToDefault();
    
            return this;
        };
    
        /**
         * Handles a lost webgl context
         *
         * @private
         * @param {WebGLContextEvent} event - The context lost event.
         */
    
    
        WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) {
            event.preventDefault();
        };
    
        /**
         * Handles a restored webgl context
         *
         * @private
         */
    
    
        WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() {
            this._initContext();
            this.textureManager.removeAll();
        };
    
        /**
         * Removes everything from the renderer (event listeners, spritebatch, etc...)
         *
         * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
         *  See: https://github.com/pixijs/pixi.js/issues/2233
         */
    
    
        WebGLRenderer.prototype.destroy = function destroy(removeView) {
            this.destroyPlugins();
    
            // remove listeners
            this.view.removeEventListener('webglcontextlost', this.handleContextLost);
            this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);
    
            this.textureManager.destroy();
    
            // call base destroy
            _SystemRenderer.prototype.destroy.call(this, removeView);
    
            this.uid = 0;
    
            // destroy the managers
            this.maskManager.destroy();
            this.stencilManager.destroy();
            this.filterManager.destroy();
    
            this.maskManager = null;
            this.filterManager = null;
            this.textureManager = null;
            this.currentRenderer = null;
    
            this.handleContextLost = null;
            this.handleContextRestored = null;
    
            this._contextOptions = null;
            this.gl.useProgram(null);
    
            if (this.gl.getExtension('WEBGL_lose_context')) {
                this.gl.getExtension('WEBGL_lose_context').loseContext();
            }
    
            this.gl = null;
    
            // this = null;
        };
    
        return WebGLRenderer;
    }(_SystemRenderer3.default);
    
    /**
     * Collection of installed plugins. These are included by default in PIXI, but can be excluded
     * by creating a custom build. Consult the README for more information about creating custom
     * builds and excluding plugins.
     * @name PIXI.WebGLRenderer#plugins
     * @type {object}
     * @readonly
     * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.
     * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.
     * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.
     * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.
     */
    
    /**
     * Adds a plugin to the renderer.
     *
     * @method PIXI.WebGLRenderer#registerPlugin
     * @param {string} pluginName - The name of the plugin.
     * @param {Function} ctor - The constructor function or class for the plugin.
     */
    
    exports.default = WebGLRenderer;
    _utils.pluginTarget.mixin(WebGLRenderer);
    
    /***/ }),
    /* 15 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _math = __webpack_require__(2);
    
    var _const = __webpack_require__(0);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _pixiGlCore = __webpack_require__(5);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * @class
     * @memberof PIXI
     */
    var RenderTarget = function () {
      /**
       * @param {WebGLRenderingContext} gl - The current WebGL drawing context
       * @param {number} [width=0] - the horizontal range of the filter
       * @param {number} [height=0] - the vertical range of the filter
       * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
       * @param {number} [resolution=1] - The current resolution / device pixel ratio
       * @param {boolean} [root=false] - Whether this object is the root element or not
       */
      function RenderTarget(gl, width, height, scaleMode, resolution, root) {
        _classCallCheck(this, RenderTarget);
    
        // TODO Resolution could go here ( eg low res blurs )
    
        /**
         * The current WebGL drawing context.
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
        // next time to create a frame buffer and texture
    
        /**
         * A frame buffer
         *
         * @member {PIXI.glCore.GLFramebuffer}
         */
        this.frameBuffer = null;
    
        /**
         * The texture
         *
         * @member {PIXI.glCore.GLTexture}
         */
        this.texture = null;
    
        /**
         * The background colour of this render target, as an array of [r,g,b,a] values
         *
         * @member {number[]}
         */
        this.clearColor = [0, 0, 0, 0];
    
        /**
         * The size of the object as a rectangle
         *
         * @member {PIXI.Rectangle}
         */
        this.size = new _math.Rectangle(0, 0, 1, 1);
    
        /**
         * The current resolution / device pixel ratio
         *
         * @member {number}
         * @default 1
         */
        this.resolution = resolution || _settings2.default.RESOLUTION;
    
        /**
         * The projection matrix
         *
         * @member {PIXI.Matrix}
         */
        this.projectionMatrix = new _math.Matrix();
    
        /**
         * The object's transform
         *
         * @member {PIXI.Matrix}
         */
        this.transform = null;
    
        /**
         * The frame.
         *
         * @member {PIXI.Rectangle}
         */
        this.frame = null;
    
        /**
         * The stencil buffer stores masking data for the render target
         *
         * @member {glCore.GLBuffer}
         */
        this.defaultFrame = new _math.Rectangle();
        this.destinationFrame = null;
        this.sourceFrame = null;
    
        /**
         * The stencil buffer stores masking data for the render target
         *
         * @member {glCore.GLBuffer}
         */
        this.stencilBuffer = null;
    
        /**
         * The data structure for the stencil masks
         *
         * @member {PIXI.Graphics[]}
         */
        this.stencilMaskStack = [];
    
        /**
         * Stores filter data for the render target
         *
         * @member {object[]}
         */
        this.filterData = null;
    
        /**
         * The scale mode.
         *
         * @member {number}
         * @default PIXI.settings.SCALE_MODE
         * @see PIXI.SCALE_MODES
         */
        this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
    
        /**
         * Whether this object is the root element or not
         *
         * @member {boolean}
         */
        this.root = root;
    
        if (!this.root) {
          this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);
    
          if (this.scaleMode === _const.SCALE_MODES.NEAREST) {
            this.frameBuffer.texture.enableNearestScaling();
          } else {
            this.frameBuffer.texture.enableLinearScaling();
          }
          /*
              A frame buffer needs a target to render to..
              create a texture and bind it attach it to the framebuffer..
           */
    
          // this is used by the base texture
          this.texture = this.frameBuffer.texture;
        } else {
          // make it a null framebuffer..
          this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);
          this.frameBuffer.framebuffer = null;
        }
    
        this.setFrame();
    
        this.resize(width, height);
      }
    
      /**
       * Clears the filter texture.
       *
       * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer
       */
    
    
      RenderTarget.prototype.clear = function clear(clearColor) {
        var cc = clearColor || this.clearColor;
    
        this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);
      };
    
      /**
       * Binds the stencil buffer.
       *
       */
    
    
      RenderTarget.prototype.attachStencilBuffer = function attachStencilBuffer() {
        // TODO check if stencil is done?
        /**
         * The stencil buffer is used for masking in pixi
         * lets create one and then add attach it to the framebuffer..
         */
        if (!this.root) {
          this.frameBuffer.enableStencil();
        }
      };
    
      /**
       * Sets the frame of the render target.
       *
       * @param {Rectangle} destinationFrame - The destination frame.
       * @param {Rectangle} sourceFrame - The source frame.
       */
    
    
      RenderTarget.prototype.setFrame = function setFrame(destinationFrame, sourceFrame) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      };
    
      /**
       * Binds the buffers and initialises the viewport.
       *
       */
    
    
      RenderTarget.prototype.activate = function activate() {
        // TOOD refactor usage of frame..
        var gl = this.gl;
    
        // make sure the texture is unbound!
        this.frameBuffer.bind();
    
        this.calculateProjection(this.destinationFrame, this.sourceFrame);
    
        if (this.transform) {
          this.projectionMatrix.append(this.transform);
        }
    
        // TODO add a check as them may be the same!
        if (this.destinationFrame !== this.sourceFrame) {
          gl.enable(gl.SCISSOR_TEST);
          gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
        } else {
          gl.disable(gl.SCISSOR_TEST);
        }
    
        // TODO - does not need to be updated all the time??
        gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
      };
    
      /**
       * Updates the projection matrix based on a projection frame (which is a rectangle)
       *
       * @param {Rectangle} destinationFrame - The destination frame.
       * @param {Rectangle} sourceFrame - The source frame.
       */
    
    
      RenderTarget.prototype.calculateProjection = function calculateProjection(destinationFrame, sourceFrame) {
        var pm = this.projectionMatrix;
    
        sourceFrame = sourceFrame || destinationFrame;
    
        pm.identity();
    
        // TODO: make dest scale source
        if (!this.root) {
          pm.a = 1 / destinationFrame.width * 2;
          pm.d = 1 / destinationFrame.height * 2;
    
          pm.tx = -1 - sourceFrame.x * pm.a;
          pm.ty = -1 - sourceFrame.y * pm.d;
        } else {
          pm.a = 1 / destinationFrame.width * 2;
          pm.d = -1 / destinationFrame.height * 2;
    
          pm.tx = -1 - sourceFrame.x * pm.a;
          pm.ty = 1 - sourceFrame.y * pm.d;
        }
      };
    
      /**
       * Resizes the texture to the specified width and height
       *
       * @param {number} width - the new width of the texture
       * @param {number} height - the new height of the texture
       */
    
    
      RenderTarget.prototype.resize = function resize(width, height) {
        width = width | 0;
        height = height | 0;
    
        if (this.size.width === width && this.size.height === height) {
          return;
        }
    
        this.size.width = width;
        this.size.height = height;
    
        this.defaultFrame.width = width;
        this.defaultFrame.height = height;
    
        this.frameBuffer.resize(width * this.resolution, height * this.resolution);
    
        var projectionFrame = this.frame || this.size;
    
        this.calculateProjection(projectionFrame);
      };
    
      /**
       * Destroys the render target.
       *
       */
    
    
      RenderTarget.prototype.destroy = function destroy() {
        this.frameBuffer.destroy();
    
        this.frameBuffer = null;
        this.texture = null;
      };
    
      return RenderTarget;
    }();
    
    exports.default = RenderTarget;
    
    /***/ }),
    /* 16 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    function checkPrecision(src, def) {
        if (src instanceof Array) {
            if (src[0].substring(0, 9) !== 'precision') {
                var copy = src.slice(0);
    
                copy.unshift('precision ' + def + ' float;');
    
                return copy;
            }
        } else if (src.substring(0, 9) !== 'precision') {
            return 'precision ' + def + ' float;\n' + src;
        }
    
        return src;
    }
    
    /**
     * Wrapper class, webGL Shader for Pixi.
     * Adds precision string if vertexSrc or fragmentSrc have no mention of it.
     *
     * @class
     * @extends GLShader
     * @memberof PIXI
     */
    
    var Shader = function (_GLShader) {
        _inherits(Shader, _GLShader);
    
        /**
         *
         * @param {WebGLRenderingContext} gl - The current WebGL rendering context
         * @param {string|string[]} vertexSrc - The vertex shader source as an array of strings.
         * @param {string|string[]} fragmentSrc - The fragment shader source as an array of strings.
         */
        function Shader(gl, vertexSrc, fragmentSrc) {
            _classCallCheck(this, Shader);
    
            return _possibleConstructorReturn(this, _GLShader.call(this, gl, checkPrecision(vertexSrc, _settings2.default.PRECISION_VERTEX), checkPrecision(fragmentSrc, _settings2.default.PRECISION_FRAGMENT)));
        }
    
        return Shader;
    }(_pixiGlCore.GLShader);
    
    exports.default = Shader;
    
    /***/ }),
    /* 17 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    exports.default = function (graphicsData, webGLData, webGLDataNativeLines) {
        if (graphicsData.nativeLines) {
            buildNativeLine(graphicsData, webGLDataNativeLines);
        } else {
            buildLine(graphicsData, webGLData);
        }
    };
    
    var _math = __webpack_require__(2);
    
    var _utils = __webpack_require__(1);
    
    /**
     * Builds a line to draw using the poligon method.
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
     * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
     */
    function buildLine(graphicsData, webGLData) {
        // TODO OPTIMISE!
        var points = graphicsData.points;
    
        if (points.length === 0) {
            return;
        }
        // if the line width is an odd number add 0.5 to align to a whole pixel
        // commenting this out fixes #711 and #1620
        // if (graphicsData.lineWidth%2)
        // {
        //     for (i = 0; i < points.length; i++)
        //     {
        //         points[i] += 0.5;
        //     }
        // }
    
        // get first and last point.. figure out the middle!
        var firstPoint = new _math.Point(points[0], points[1]);
        var lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);
    
        // if the first point is the last point - gonna have issues :)
        if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) {
            // need to clone as we are going to slightly modify the shape..
            points = points.slice();
    
            points.pop();
            points.pop();
    
            lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);
    
            var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5;
            var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;
    
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
    
        var verts = webGLData.points;
        var indices = webGLData.indices;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 6;
    
        // DRAW the Line
        var width = graphicsData.lineWidth / 2;
    
        // sort color
        var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
        var alpha = graphicsData.lineAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
    
        var p1x = points[0];
        var p1y = points[1];
        var p2x = points[2];
        var p2y = points[3];
        var p3x = 0;
        var p3y = 0;
    
        var perpx = -(p1y - p2y);
        var perpy = p1x - p2x;
        var perp2x = 0;
        var perp2y = 0;
        var perp3x = 0;
        var perp3y = 0;
    
        var dist = Math.sqrt(perpx * perpx + perpy * perpy);
    
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
    
        // start
        verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);
    
        verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);
    
        for (var i = 1; i < length - 1; ++i) {
            p1x = points[(i - 1) * 2];
            p1y = points[(i - 1) * 2 + 1];
    
            p2x = points[i * 2];
            p2y = points[i * 2 + 1];
    
            p3x = points[(i + 1) * 2];
            p3y = points[(i + 1) * 2 + 1];
    
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
    
            dist = Math.sqrt(perpx * perpx + perpy * perpy);
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
    
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
    
            dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
    
            var a1 = -perpy + p1y - (-perpy + p2y);
            var b1 = -perpx + p2x - (-perpx + p1x);
            var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
            var a2 = -perp2y + p3y - (-perp2y + p2y);
            var b2 = -perp2x + p2x - (-perp2x + p3x);
            var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
    
            var denom = a1 * b2 - a2 * b1;
    
            if (Math.abs(denom) < 0.1) {
                denom += 10.1;
                verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);
    
                verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha);
    
                continue;
            }
    
            var px = (b1 * c2 - b2 * c1) / denom;
            var py = (a2 * c1 - a1 * c2) / denom;
            var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);
    
            if (pdist > 196 * width * width) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
    
                dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
    
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
    
                verts.push(p2x + perp3x, p2y + perp3y);
                verts.push(r, g, b, alpha);
    
                verts.push(p2x - perp3x, p2y - perp3y);
                verts.push(r, g, b, alpha);
    
                indexCount++;
            } else {
                verts.push(px, py);
                verts.push(r, g, b, alpha);
    
                verts.push(p2x - (px - p2x), p2y - (py - p2y));
                verts.push(r, g, b, alpha);
            }
        }
    
        p1x = points[(length - 2) * 2];
        p1y = points[(length - 2) * 2 + 1];
    
        p2x = points[(length - 1) * 2];
        p2y = points[(length - 1) * 2 + 1];
    
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
    
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
    
        verts.push(p2x - perpx, p2y - perpy);
        verts.push(r, g, b, alpha);
    
        verts.push(p2x + perpx, p2y + perpy);
        verts.push(r, g, b, alpha);
    
        indices.push(indexStart);
    
        for (var _i = 0; _i < indexCount; ++_i) {
            indices.push(indexStart++);
        }
    
        indices.push(indexStart - 1);
    }
    
    /**
     * Builds a line to draw using the gl.drawArrays(gl.LINES) method
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
     * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
     */
    
    
    /**
     * Builds a line to draw
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
     * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
     * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
     */
    function buildNativeLine(graphicsData, webGLData) {
        var i = 0;
        var points = graphicsData.points;
    
        if (points.length === 0) return;
    
        var verts = webGLData.points;
        var length = points.length / 2;
    
        // sort color
        var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
        var alpha = graphicsData.lineAlpha;
        var r = color[0] * alpha;
        var g = color[1] * alpha;
        var b = color[2] * alpha;
    
        for (i = 1; i < length; i++) {
            var p1x = points[(i - 1) * 2];
            var p1y = points[(i - 1) * 2 + 1];
    
            var p2x = points[i * 2];
            var p2y = points[i * 2 + 1];
    
            verts.push(p1x, p1y);
            verts.push(r, g, b, alpha);
    
            verts.push(p2x, p2y);
            verts.push(r, g, b, alpha);
        }
    }
    
    /***/ }),
    /* 18 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    // import Loader from './Loader';
    // import Resource from './Resource';
    // import * as async from './async';
    // import * as b64 from './b64';
    
    /* eslint-disable no-undef */
    
    var Loader = __webpack_require__(152).default;
    var Resource = __webpack_require__(31).default;
    var async = __webpack_require__(75);
    var b64 = __webpack_require__(76);
    
    Loader.Resource = Resource;
    Loader.async = async;
    Loader.base64 = b64;
    
    // export manually, and also as default
    module.exports = Loader;
    // export default Loader;
    module.exports.default = Loader;
    //# sourceMappingURL=index.js.map
    
    /***/ }),
    /* 19 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    exports.areEqualDeep = areEqualDeep;
    exports.convertSpeedPace = convertSpeedPace;
    if (!window.Float32Array) {
        window.Float32Array = Array;
    }
    
    if (!window.Float32Array.prototype.slice) {
        window.Float32Array.prototype.slice = function (begin, end) {
            if (!begin) {
                begin = 0;
            }
            if (!end) {
                end = this.length;
            }
            var target = new Float32Array(end - begin);
            for (var i = 0; i < begin + end; ++i) {
                target[i] = this[begin + i];
            }
            return target;
        };
    }
    
    if (!window.Uint32Array) {
        window.Uint32Array = Array;
    }
    
    if (!window.Uint32Array.prototype.slice) {
        window.Uint32Array.prototype.slice = function (begin, end) {
            if (!begin) {
                begin = 0;
            }
            if (!end) {
                end = this.length;
            }
            var target = new Uint32Array(end - begin);
            for (var i = 0; i < begin + end; ++i) {
                target[i] = this[begin + i];
            }
            return target;
        };
    }
    
    if (!window.Uint16Array) {
        window.Uint16Array = Array;
    }
    
    if (!window.Uint16Array.prototype.slice) {
        window.Uint16Array.prototype.slice = function (begin, end) {
            if (!begin) {
                begin = 0;
            }
            if (!end) {
                end = this.length;
            }
            var target = new Uint16Array(end - begin);
            for (var i = 0; i < begin + end; ++i) {
                target[i] = this[begin + i];
            }
            return target;
        };
    }
    
    if (!window.isObject) {
        window.isObject = function (item) {
            return item && (typeof item === "undefined" ? "undefined" : _typeof(item)) === "object" && !Array.isArray(item);
        };
    }
    
    if (!window.mergeDeep) {
    
        window.mergeDeep = function (target, source) {
            if (isObject(target) && isObject(source)) {
                for (var key in source) {
                    if (isObject(source[key])) {
                        if (!target[key]) {
                            var _Object$assign;
    
                            Object.assign(target, (_Object$assign = {}, _Object$assign[key] = {}, _Object$assign));
                        }
                        mergeDeep(target[key], source[key]);
                    } else {
                        var _Object$assign2;
    
                        Object.assign(target, (_Object$assign2 = {}, _Object$assign2[key] = source[key], _Object$assign2));
                    }
                }
            }
        };
    }
    
    function areEqualDeep(first, second) {
        if (isObject(first) && isObject(second)) {
            for (var key in second) {
                if (!first.hasOwnProperty(key)) {
                    return false;
                }
                if (!areEqualDeep(second[key], first[key])) {
                    return false;
                }
            }
            return true;
        }
        return first === second;
    }
    
    function convertSpeedPace(origin) {
        return !origin ? 0 : 100 * Math.PI / (origin * 3);
    }
    
    /***/ }),
    /* 20 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    var _index = __webpack_require__(160);
    
    var Ease = _interopRequireWildcard(_index);
    
    var _utils = __webpack_require__(19);
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var baseEase = Ease.easeLinear;
    var baseDuration = 600;
    
    var TransitionState = {
        CREATED: 0,
        STARTED: 1,
        ENDED: 2
    };
    
    function lerp(a, b, w) {
        if ((typeof a === "undefined" ? "undefined" : _typeof(a)) == "object" && (typeof b === "undefined" ? "undefined" : _typeof(b)) == "object") {
            var result = {};
            for (var key in a) {
                if (b.hasOwnProperty(key)) {
                    result[key] = lerp(a[key], b[key], w);
                }
            }
            return result;
        }
        if (isNaN(a) || isNaN(b)) {
            return b;
        }
        return a + w * (b - a);
    }
    
    var Transition = function () {
        function Transition(source) {
            var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : baseDuration;
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var easeType = arguments[3];
    
            _classCallCheck(this, Transition);
    
            this.delay = delay;
            this.duration = duration;
            this.easeFunc = easeType && Ease[easeType] ? Ease[easeType] : baseEase;
            this._tweens = {};
            this.events = {
                start: null,
                stop: null
            };
    
            this.init(source);
        }
    
        Transition.prototype.init = function init(source) {
            if (!!source.__transition) {
                source.__transition.stop();
            }
            this.source = source;
            this.source.__transition = this;
            this.initTime = new Date();
            this.state = TransitionState.CREATED;
        };
    
        Transition.prototype.delay = function delay(delayTime) {
            this.delay = delayTime || 0;
        };
    
        Transition.prototype.duration = function duration(time) {
            this.duration = isNaN(time) || time < 0 ? baseDuration : time;
        };
    
        Transition.prototype.ease = function ease(easeFunc) {
            this.easeFunc = easeFunc;
        };
    
        Transition.prototype.tween = function tween(name, target) {
            var origin = this.source[name];
            if (typeof origin === "undefined") {
                console.warn("'" + name + "' parameter is missing in the transiting object");
                return;
            }
            // if current value and target are equal - ignore transition
            if (!(0, _utils.areEqualDeep)(origin, target)) {
                this._tweens[name] = {
                    origin: origin,
                    target: target
                };
            }
        };
    
        Transition.prototype.tweenRotation = function tweenRotation(name, target) {
            var period = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.PI * 2;
    
            this.tween(name, target);
            var rotationTween = this._tweens[name];
            if (!rotationTween) {
                return;
            }
            var delta = rotationTween.target - rotationTween.origin;
            var halfPeriod = period * 0.5;
            if (delta > halfPeriod) {
                rotationTween.target -= period;
            } else if (delta < -halfPeriod) {
                rotationTween.target += period;
            }
        };
    
        Transition.prototype.start = function start() {
            if (this.state !== TransitionState.CREATED) {
                this.stop();
                return;
            }
            this.state = TransitionState.STARTED;
            if (typeof this.events.start === "function") {
                this.events.start();
            }
        };
    
        Transition.prototype.stop = function stop() {
            this.state = TransitionState.ENDED;
            if (typeof this.events.stop === "function") {
                this.events.stop();
            }
            delete this.source.__transition;
        };
    
        Transition.prototype.end = function end() {
            this.state = TransitionState.ENDED;
            for (var key in this._tweens) {
                var targetValue = this._tweens[key].target;
                this.source[key] = targetValue;
            }
            if (typeof this.events.stop === "function") {
                this.events.stop();
            }
            delete this.source.__transition;
        };
    
        Transition.prototype.tick = function tick(_tick) {
            var delta = new Date() - this.initTime - this.delay;
            if (delta < 0) {
                return;
            }
            if (delta > this.duration) {
                this.end();
                return;
            }
            if (this.state === TransitionState.CREATED) {
                this.start();
            }
            var current = this.easeFunc(delta / this.duration);
            for (var key in this._tweens) {
                var item = this._tweens[key];
                var curr = lerp(item.origin, item.target, current);
                this.source[key] = curr;
            }
        };
    
        Transition.prototype.on = function on(event, callback) {
            if (!this.events.hasProperty(event)) {
                return;
            }
            if (typeof callback === "function") {
                this.events[event] = callback;
            } else {
                this.events[event] = null;
            }
        };
    
        return Transition;
    }();
    
    exports.default = Transition;
    
    /***/ }),
    /* 21 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * The Point object represents a location in a two-dimensional coordinate system, where x represents
     * the horizontal axis and y represents the vertical axis.
     *
     * @class
     * @memberof PIXI
     */
    var Point = function () {
      /**
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      function Point() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    
        _classCallCheck(this, Point);
    
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
    
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
      }
    
      /**
       * Creates a clone of this point
       *
       * @return {PIXI.Point} a copy of the point
       */
    
    
      Point.prototype.clone = function clone() {
        return new Point(this.x, this.y);
      };
    
      /**
       * Copies x and y from the given point
       *
       * @param {PIXI.Point} p - The point to copy.
       */
    
    
      Point.prototype.copy = function copy(p) {
        this.set(p.x, p.y);
      };
    
      /**
       * Returns true if the given point is equal to this point
       *
       * @param {PIXI.Point} p - The point to check
       * @returns {boolean} Whether the given point equal to this point
       */
    
    
      Point.prototype.equals = function equals(p) {
        return p.x === this.x && p.y === this.y;
      };
    
      /**
       * Sets the point to a new x and y position.
       * If y is omitted, both x and y will be set to x.
       *
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
    
    
      Point.prototype.set = function set(x, y) {
        this.x = x || 0;
        this.y = y || (y !== 0 ? this.x : 0);
      };
    
      return Point;
    }();
    
    exports.default = Point;
    
    /***/ }),
    /* 22 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _Point = __webpack_require__(21);
    
    var _Point2 = _interopRequireDefault(_Point);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * The pixi Matrix class as an object, which makes it a lot faster,
     * here is a representation of it :
     * | a | b | tx|
     * | c | d | ty|
     * | 0 | 0 | 1 |
     *
     * @class
     * @memberof PIXI
     */
    var Matrix = function () {
        /**
         * @param {number} [a=1] - x scale
         * @param {number} [b=0] - y skew
         * @param {number} [c=0] - x skew
         * @param {number} [d=1] - y scale
         * @param {number} [tx=0] - x translation
         * @param {number} [ty=0] - y translation
         */
        function Matrix() {
            var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    
            _classCallCheck(this, Matrix);
    
            /**
             * @member {number}
             * @default 1
             */
            this.a = a;
    
            /**
             * @member {number}
             * @default 0
             */
            this.b = b;
    
            /**
             * @member {number}
             * @default 0
             */
            this.c = c;
    
            /**
             * @member {number}
             * @default 1
             */
            this.d = d;
    
            /**
             * @member {number}
             * @default 0
             */
            this.tx = tx;
    
            /**
             * @member {number}
             * @default 0
             */
            this.ty = ty;
    
            this.array = null;
        }
    
        /**
         * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
         *
         * a = array[0]
         * b = array[1]
         * c = array[3]
         * d = array[4]
         * tx = array[2]
         * ty = array[5]
         *
         * @param {number[]} array - The array that the matrix will be populated from.
         */
    
    
        Matrix.prototype.fromArray = function fromArray(array) {
            this.a = array[0];
            this.b = array[1];
            this.c = array[3];
            this.d = array[4];
            this.tx = array[2];
            this.ty = array[5];
        };
    
        /**
         * sets the matrix properties
         *
         * @param {number} a - Matrix component
         * @param {number} b - Matrix component
         * @param {number} c - Matrix component
         * @param {number} d - Matrix component
         * @param {number} tx - Matrix component
         * @param {number} ty - Matrix component
         *
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.set = function set(a, b, c, d, tx, ty) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
    
            return this;
        };
    
        /**
         * Creates an array from the current Matrix object.
         *
         * @param {boolean} transpose - Whether we need to transpose the matrix or not
         * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
         * @return {number[]} the newly created array which contains the matrix
         */
    
    
        Matrix.prototype.toArray = function toArray(transpose, out) {
            if (!this.array) {
                this.array = new Float32Array(9);
            }
    
            var array = out || this.array;
    
            if (transpose) {
                array[0] = this.a;
                array[1] = this.b;
                array[2] = 0;
                array[3] = this.c;
                array[4] = this.d;
                array[5] = 0;
                array[6] = this.tx;
                array[7] = this.ty;
                array[8] = 1;
            } else {
                array[0] = this.a;
                array[1] = this.c;
                array[2] = this.tx;
                array[3] = this.b;
                array[4] = this.d;
                array[5] = this.ty;
                array[6] = 0;
                array[7] = 0;
                array[8] = 1;
            }
    
            return array;
        };
    
        /**
         * Get a new position with the current transformation applied.
         * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
         *
         * @param {PIXI.Point} pos - The origin
         * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {PIXI.Point} The new point, transformed through this matrix
         */
    
    
        Matrix.prototype.apply = function apply(pos, newPos) {
            newPos = newPos || new _Point2.default();
    
            var x = pos.x;
            var y = pos.y;
    
            newPos.x = this.a * x + this.c * y + this.tx;
            newPos.y = this.b * x + this.d * y + this.ty;
    
            return newPos;
        };
    
        /**
         * Get a new position with the inverse of the current transformation applied.
         * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
         *
         * @param {PIXI.Point} pos - The origin
         * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
         * @return {PIXI.Point} The new point, inverse-transformed through this matrix
         */
    
    
        Matrix.prototype.applyInverse = function applyInverse(pos, newPos) {
            newPos = newPos || new _Point2.default();
    
            var id = 1 / (this.a * this.d + this.c * -this.b);
    
            var x = pos.x;
            var y = pos.y;
    
            newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
            newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;
    
            return newPos;
        };
    
        /**
         * Translates the matrix on the x and y.
         *
         * @param {number} x How much to translate x by
         * @param {number} y How much to translate y by
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.translate = function translate(x, y) {
            this.tx += x;
            this.ty += y;
    
            return this;
        };
    
        /**
         * Applies a scale transformation to the matrix.
         *
         * @param {number} x The amount to scale horizontally
         * @param {number} y The amount to scale vertically
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.scale = function scale(x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
    
            return this;
        };
    
        /**
         * Applies a rotation transformation to the matrix.
         *
         * @param {number} angle - The angle in radians.
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.rotate = function rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
    
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
    
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
    
            return this;
        };
    
        /**
         * Appends the given Matrix to this Matrix.
         *
         * @param {PIXI.Matrix} matrix - The matrix to append.
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.append = function append(matrix) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
    
            this.a = matrix.a * a1 + matrix.b * c1;
            this.b = matrix.a * b1 + matrix.b * d1;
            this.c = matrix.c * a1 + matrix.d * c1;
            this.d = matrix.c * b1 + matrix.d * d1;
    
            this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
            this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    
            return this;
        };
    
        /**
         * Sets the matrix based on all the available properties
         *
         * @param {number} x - Position on the x axis
         * @param {number} y - Position on the y axis
         * @param {number} pivotX - Pivot on the x axis
         * @param {number} pivotY - Pivot on the y axis
         * @param {number} scaleX - Scale on the x axis
         * @param {number} scaleY - Scale on the y axis
         * @param {number} rotation - Rotation in radians
         * @param {number} skewX - Skew on the x axis
         * @param {number} skewY - Skew on the y axis
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.setTransform = function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
            var sr = Math.sin(rotation);
            var cr = Math.cos(rotation);
            var cy = Math.cos(skewY);
            var sy = Math.sin(skewY);
            var nsx = -Math.sin(skewX);
            var cx = Math.cos(skewX);
    
            var a = cr * scaleX;
            var b = sr * scaleX;
            var c = -sr * scaleY;
            var d = cr * scaleY;
    
            this.a = cy * a + sy * c;
            this.b = cy * b + sy * d;
            this.c = nsx * a + cx * c;
            this.d = nsx * b + cx * d;
    
            this.tx = x + (pivotX * a + pivotY * c);
            this.ty = y + (pivotX * b + pivotY * d);
    
            return this;
        };
    
        /**
         * Prepends the given Matrix to this Matrix.
         *
         * @param {PIXI.Matrix} matrix - The matrix to prepend
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.prepend = function prepend(matrix) {
            var tx1 = this.tx;
    
            if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
                var a1 = this.a;
                var c1 = this.c;
    
                this.a = a1 * matrix.a + this.b * matrix.c;
                this.b = a1 * matrix.b + this.b * matrix.d;
                this.c = c1 * matrix.a + this.d * matrix.c;
                this.d = c1 * matrix.b + this.d * matrix.d;
            }
    
            this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    
            return this;
        };
    
        /**
         * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
         *
         * @param {PIXI.Transform|PIXI.TransformStatic} transform - The transform to apply the properties to.
         * @return {PIXI.Transform|PIXI.TransformStatic} The transform with the newly applied properties
         */
    
    
        Matrix.prototype.decompose = function decompose(transform) {
            // sort out rotation / skew..
            var a = this.a;
            var b = this.b;
            var c = this.c;
            var d = this.d;
    
            var skewX = -Math.atan2(-c, d);
            var skewY = Math.atan2(b, a);
    
            var delta = Math.abs(skewX + skewY);
    
            if (delta < 0.00001) {
                transform.rotation = skewY;
    
                if (a < 0 && d >= 0) {
                    transform.rotation += transform.rotation <= 0 ? Math.PI : -Math.PI;
                }
    
                transform.skew.x = transform.skew.y = 0;
            } else {
                transform.skew.x = skewX;
                transform.skew.y = skewY;
            }
    
            // next set scale
            transform.scale.x = Math.sqrt(a * a + b * b);
            transform.scale.y = Math.sqrt(c * c + d * d);
    
            // next set position
            transform.position.x = this.tx;
            transform.position.y = this.ty;
    
            return transform;
        };
    
        /**
         * Inverts this matrix
         *
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.invert = function invert() {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
    
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
    
            return this;
        };
    
        /**
         * Resets this Matix to an identity (default) matrix.
         *
         * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.identity = function identity() {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.tx = 0;
            this.ty = 0;
    
            return this;
        };
    
        /**
         * Creates a new Matrix object with the same values as this one.
         *
         * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
         */
    
    
        Matrix.prototype.clone = function clone() {
            var matrix = new Matrix();
    
            matrix.a = this.a;
            matrix.b = this.b;
            matrix.c = this.c;
            matrix.d = this.d;
            matrix.tx = this.tx;
            matrix.ty = this.ty;
    
            return matrix;
        };
    
        /**
         * Changes the values of the given matrix to be the same as the ones in this matrix
         *
         * @param {PIXI.Matrix} matrix - The matrix to copy from.
         * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
         */
    
    
        Matrix.prototype.copy = function copy(matrix) {
            matrix.a = this.a;
            matrix.b = this.b;
            matrix.c = this.c;
            matrix.d = this.d;
            matrix.tx = this.tx;
            matrix.ty = this.ty;
    
            return matrix;
        };
    
        /**
         * A default (identity) matrix
         *
         * @static
         * @const
         */
    
    
        _createClass(Matrix, null, [{
            key: 'IDENTITY',
            get: function get() {
                return new Matrix();
            }
    
            /**
             * A temp matrix
             *
             * @static
             * @const
             */
    
        }, {
            key: 'TEMP_MATRIX',
            get: function get() {
                return new Matrix();
            }
        }]);
    
        return Matrix;
    }();
    
    exports.default = Matrix;
    
    /***/ }),
    /* 23 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _const = __webpack_require__(0);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Rectangle object is an area defined by its position, as indicated by its top-left corner
     * point (x, y) and by its width and its height.
     *
     * @class
     * @memberof PIXI
     */
    var Rectangle = function () {
        /**
         * @param {number} [x=0] - The X coordinate of the upper-left corner of the rectangle
         * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rectangle
         * @param {number} [width=0] - The overall width of this rectangle
         * @param {number} [height=0] - The overall height of this rectangle
         */
        function Rectangle() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    
            _classCallCheck(this, Rectangle);
    
            /**
             * @member {number}
             * @default 0
             */
            this.x = x;
    
            /**
             * @member {number}
             * @default 0
             */
            this.y = y;
    
            /**
             * @member {number}
             * @default 0
             */
            this.width = width;
    
            /**
             * @member {number}
             * @default 0
             */
            this.height = height;
    
            /**
             * The type of the object, mainly used to avoid `instanceof` checks
             *
             * @member {number}
             * @readOnly
             * @default PIXI.SHAPES.RECT
             * @see PIXI.SHAPES
             */
            this.type = _const.SHAPES.RECT;
        }
    
        /**
         * returns the left edge of the rectangle
         *
         * @member {number}
         */
    
    
        /**
         * Creates a clone of this Rectangle
         *
         * @return {PIXI.Rectangle} a copy of the rectangle
         */
        Rectangle.prototype.clone = function clone() {
            return new Rectangle(this.x, this.y, this.width, this.height);
        };
    
        /**
         * Copies another rectangle to this one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to copy.
         * @return {PIXI.Rectangle} Returns itself.
         */
    
    
        Rectangle.prototype.copy = function copy(rectangle) {
            this.x = rectangle.x;
            this.y = rectangle.y;
            this.width = rectangle.width;
            this.height = rectangle.height;
    
            return this;
        };
    
        /**
         * Checks whether the x and y coordinates given are contained within this Rectangle
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this Rectangle
         */
    
    
        Rectangle.prototype.contains = function contains(x, y) {
            if (this.width <= 0 || this.height <= 0) {
                return false;
            }
    
            if (x >= this.x && x < this.x + this.width) {
                if (y >= this.y && y < this.y + this.height) {
                    return true;
                }
            }
    
            return false;
        };
    
        /**
         * Pads the rectangle making it grow in all directions.
         *
         * @param {number} paddingX - The horizontal padding amount.
         * @param {number} paddingY - The vertical padding amount.
         */
    
    
        Rectangle.prototype.pad = function pad(paddingX, paddingY) {
            paddingX = paddingX || 0;
            paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);
    
            this.x -= paddingX;
            this.y -= paddingY;
    
            this.width += paddingX * 2;
            this.height += paddingY * 2;
        };
    
        /**
         * Fits this rectangle around the passed one.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
         */
    
    
        Rectangle.prototype.fit = function fit(rectangle) {
            if (this.x < rectangle.x) {
                this.width += this.x;
                if (this.width < 0) {
                    this.width = 0;
                }
    
                this.x = rectangle.x;
            }
    
            if (this.y < rectangle.y) {
                this.height += this.y;
                if (this.height < 0) {
                    this.height = 0;
                }
                this.y = rectangle.y;
            }
    
            if (this.x + this.width > rectangle.x + rectangle.width) {
                this.width = rectangle.width - this.x;
                if (this.width < 0) {
                    this.width = 0;
                }
            }
    
            if (this.y + this.height > rectangle.y + rectangle.height) {
                this.height = rectangle.height - this.y;
                if (this.height < 0) {
                    this.height = 0;
                }
            }
        };
    
        /**
         * Enlarges this rectangle to include the passed rectangle.
         *
         * @param {PIXI.Rectangle} rectangle - The rectangle to include.
         */
    
    
        Rectangle.prototype.enlarge = function enlarge(rectangle) {
            var x1 = Math.min(this.x, rectangle.x);
            var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
            var y1 = Math.min(this.y, rectangle.y);
            var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    
            this.x = x1;
            this.width = x2 - x1;
            this.y = y1;
            this.height = y2 - y1;
        };
    
        _createClass(Rectangle, [{
            key: 'left',
            get: function get() {
                return this.x;
            }
    
            /**
             * returns the right edge of the rectangle
             *
             * @member {number}
             */
    
        }, {
            key: 'right',
            get: function get() {
                return this.x + this.width;
            }
    
            /**
             * returns the top edge of the rectangle
             *
             * @member {number}
             */
    
        }, {
            key: 'top',
            get: function get() {
                return this.y;
            }
    
            /**
             * returns the bottom edge of the rectangle
             *
             * @member {number}
             */
    
        }, {
            key: 'bottom',
            get: function get() {
                return this.y + this.height;
            }
    
            /**
             * A constant empty rectangle.
             *
             * @static
             * @constant
             */
    
        }], [{
            key: 'EMPTY',
            get: function get() {
                return new Rectangle(0, 0, 0, 0);
            }
        }]);
    
        return Rectangle;
    }();
    
    exports.default = Rectangle;
    
    /***/ }),
    /* 24 */
    /***/ (function(module, exports) {
    
    
    
    var mapSize = function(gl, type) 
    {
        if(!GL_TABLE) 
        {
            var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    
            GL_TABLE = {};
    
            for(var i = 0; i < typeNames.length; ++i) 
            {
                var tn = typeNames[i];
                GL_TABLE[ gl[tn] ] = GL_TO_GLSL_TYPES[tn];
            }
        }
    
      return GL_TABLE[type];
    };
    
    var GL_TABLE = null;
    
    var GL_TO_GLSL_TYPES = {
      'FLOAT':       'float',
      'FLOAT_VEC2':  'vec2',
      'FLOAT_VEC3':  'vec3',
      'FLOAT_VEC4':  'vec4',
    
      'INT':         'int',
      'INT_VEC2':    'ivec2',
      'INT_VEC3':    'ivec3',
      'INT_VEC4':    'ivec4',
      
      'BOOL':        'bool',
      'BOOL_VEC2':   'bvec2',
      'BOOL_VEC3':   'bvec3',
      'BOOL_VEC4':   'bvec4',
      
      'FLOAT_MAT2':  'mat2',
      'FLOAT_MAT3':  'mat3',
      'FLOAT_MAT4':  'mat4',
      
      'SAMPLER_2D':  'sampler2D'  
    };
    
    module.exports = mapSize;
    
    
    /***/ }),
    /* 25 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _math = __webpack_require__(2);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * 'Builder' pattern for bounds rectangles
     * Axis-Aligned Bounding Box
     * It is not a shape! Its mutable thing, no 'EMPTY' or that kind of problems
     *
     * @class
     * @memberof PIXI
     */
    var Bounds = function () {
        /**
         *
         */
        function Bounds() {
            _classCallCheck(this, Bounds);
    
            /**
             * @member {number}
             * @default 0
             */
            this.minX = Infinity;
    
            /**
             * @member {number}
             * @default 0
             */
            this.minY = Infinity;
    
            /**
             * @member {number}
             * @default 0
             */
            this.maxX = -Infinity;
    
            /**
             * @member {number}
             * @default 0
             */
            this.maxY = -Infinity;
    
            this.rect = null;
        }
    
        /**
         * Checks if bounds are empty.
         *
         * @return {boolean} True if empty.
         */
    
    
        Bounds.prototype.isEmpty = function isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY;
        };
    
        /**
         * Clears the bounds and resets.
         *
         */
    
    
        Bounds.prototype.clear = function clear() {
            this.updateID++;
    
            this.minX = Infinity;
            this.minY = Infinity;
            this.maxX = -Infinity;
            this.maxY = -Infinity;
        };
    
        /**
         * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
         * It is not guaranteed that it will return tempRect
         *
         * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
         * @returns {PIXI.Rectangle} A rectangle of the bounds
         */
    
    
        Bounds.prototype.getRectangle = function getRectangle(rect) {
            if (this.minX > this.maxX || this.minY > this.maxY) {
                return _math.Rectangle.EMPTY;
            }
    
            rect = rect || new _math.Rectangle(0, 0, 1, 1);
    
            rect.x = this.minX;
            rect.y = this.minY;
            rect.width = this.maxX - this.minX;
            rect.height = this.maxY - this.minY;
    
            return rect;
        };
    
        /**
         * This function should be inlined when its possible.
         *
         * @param {PIXI.Point} point - The point to add.
         */
    
    
        Bounds.prototype.addPoint = function addPoint(point) {
            this.minX = Math.min(this.minX, point.x);
            this.maxX = Math.max(this.maxX, point.x);
            this.minY = Math.min(this.minY, point.y);
            this.maxY = Math.max(this.maxY, point.y);
        };
    
        /**
         * Adds a quad, not transformed
         *
         * @param {Float32Array} vertices - The verts to add.
         */
    
    
        Bounds.prototype.addQuad = function addQuad(vertices) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
    
            var x = vertices[0];
            var y = vertices[1];
    
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            x = vertices[2];
            y = vertices[3];
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            x = vertices[4];
            y = vertices[5];
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            x = vertices[6];
            y = vertices[7];
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        };
    
        /**
         * Adds sprite frame, transformed.
         *
         * @param {PIXI.TransformBase} transform - TODO
         * @param {number} x0 - TODO
         * @param {number} y0 - TODO
         * @param {number} x1 - TODO
         * @param {number} y1 - TODO
         */
    
    
        Bounds.prototype.addFrame = function addFrame(transform, x0, y0, x1, y1) {
            var matrix = transform.worldTransform;
            var a = matrix.a;
            var b = matrix.b;
            var c = matrix.c;
            var d = matrix.d;
            var tx = matrix.tx;
            var ty = matrix.ty;
    
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
    
            var x = a * x0 + c * y0 + tx;
            var y = b * x0 + d * y0 + ty;
    
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            x = a * x1 + c * y0 + tx;
            y = b * x1 + d * y0 + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            x = a * x0 + c * y1 + tx;
            y = b * x0 + d * y1 + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            x = a * x1 + c * y1 + tx;
            y = b * x1 + d * y1 + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
    
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        };
    
        /**
         * Add an array of vertices
         *
         * @param {PIXI.TransformBase} transform - TODO
         * @param {Float32Array} vertices - TODO
         * @param {number} beginOffset - TODO
         * @param {number} endOffset - TODO
         */
    
    
        Bounds.prototype.addVertices = function addVertices(transform, vertices, beginOffset, endOffset) {
            var matrix = transform.worldTransform;
            var a = matrix.a;
            var b = matrix.b;
            var c = matrix.c;
            var d = matrix.d;
            var tx = matrix.tx;
            var ty = matrix.ty;
    
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
    
            for (var i = beginOffset; i < endOffset; i += 2) {
                var rawX = vertices[i];
                var rawY = vertices[i + 1];
                var x = a * rawX + c * rawY + tx;
                var y = d * rawY + b * rawX + ty;
    
                minX = x < minX ? x : minX;
                minY = y < minY ? y : minY;
                maxX = x > maxX ? x : maxX;
                maxY = y > maxY ? y : maxY;
            }
    
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        };
    
        /**
         * Adds other Bounds
         *
         * @param {PIXI.Bounds} bounds - TODO
         */
    
    
        Bounds.prototype.addBounds = function addBounds(bounds) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
    
            this.minX = bounds.minX < minX ? bounds.minX : minX;
            this.minY = bounds.minY < minY ? bounds.minY : minY;
            this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
            this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
        };
    
        /**
         * Adds other Bounds, masked with Bounds
         *
         * @param {PIXI.Bounds} bounds - TODO
         * @param {PIXI.Bounds} mask - TODO
         */
    
    
        Bounds.prototype.addBoundsMask = function addBoundsMask(bounds, mask) {
            var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
            var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
            var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
            var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    
            if (_minX <= _maxX && _minY <= _maxY) {
                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
    
                this.minX = _minX < minX ? _minX : minX;
                this.minY = _minY < minY ? _minY : minY;
                this.maxX = _maxX > maxX ? _maxX : maxX;
                this.maxY = _maxY > maxY ? _maxY : maxY;
            }
        };
    
        /**
         * Adds other Bounds, masked with Rectangle
         *
         * @param {PIXI.Bounds} bounds - TODO
         * @param {PIXI.Rectangle} area - TODO
         */
    
    
        Bounds.prototype.addBoundsArea = function addBoundsArea(bounds, area) {
            var _minX = bounds.minX > area.x ? bounds.minX : area.x;
            var _minY = bounds.minY > area.y ? bounds.minY : area.y;
            var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
            var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
    
            if (_minX <= _maxX && _minY <= _maxY) {
                var minX = this.minX;
                var minY = this.minY;
                var maxX = this.maxX;
                var maxY = this.maxY;
    
                this.minX = _minX < minX ? _minX : minX;
                this.minY = _minY < minY ? _minY : minY;
                this.maxX = _maxX > maxX ? _maxX : maxX;
                this.maxY = _maxY > maxY ? _maxY : maxY;
            }
        };
    
        return Bounds;
    }();
    
    exports.default = Bounds;
    
    /***/ }),
    /* 26 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _math = __webpack_require__(2);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Generic class to deal with traditional 2D matrix transforms
     *
     * @class
     * @memberof PIXI
     */
    var TransformBase = function () {
      /**
       *
       */
      function TransformBase() {
        _classCallCheck(this, TransformBase);
    
        /**
         * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
         *
         * @member {PIXI.Matrix}
         */
        this.worldTransform = new _math.Matrix();
    
        /**
         * The local matrix transform
         *
         * @member {PIXI.Matrix}
         */
        this.localTransform = new _math.Matrix();
    
        this._worldID = 0;
        this._parentID = 0;
      }
    
      /**
       * TransformBase does not have decomposition, so this function wont do anything
       */
    
    
      TransformBase.prototype.updateLocalTransform = function updateLocalTransform() {}
      // empty
    
    
      /**
       * Updates the values of the object and applies the parent's transform.
       *
       * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object
       */
      ;
    
      TransformBase.prototype.updateTransform = function updateTransform(parentTransform) {
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;
        var lt = this.localTransform;
    
        // concat the parent matrix with the objects transform.
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
    
        this._worldID++;
      };
    
      return TransformBase;
    }();
    
    /**
     * Updates the values of the object and applies the parent's transform.
     * @param  parentTransform {PIXI.Transform} The transform of the parent of this object
     *
     */
    
    
    exports.default = TransformBase;
    TransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;
    
    TransformBase.IDENTITY = new TransformBase();
    
    /***/ }),
    /* 27 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    /**
     * Bit twiddling hacks for JavaScript.
     *
     * Author: Mikola Lysenko
     *
     * Ported from Stanford bit twiddling hack library:
     *    http://graphics.stanford.edu/~seander/bithacks.html
     */
    
     "use restrict";
    
    //Number of bits in an integer
    var INT_BITS = 32;
    
    //Constants
    exports.INT_BITS  = INT_BITS;
    exports.INT_MAX   =  0x7fffffff;
    exports.INT_MIN   = -1<<(INT_BITS-1);
    
    //Returns -1, 0, +1 depending on sign of x
    exports.sign = function(v) {
      return (v > 0) - (v < 0);
    }
    
    //Computes absolute value of integer
    exports.abs = function(v) {
      var mask = v >> (INT_BITS-1);
      return (v ^ mask) - mask;
    }
    
    //Computes minimum of integers x and y
    exports.min = function(x, y) {
      return y ^ ((x ^ y) & -(x < y));
    }
    
    //Computes maximum of integers x and y
    exports.max = function(x, y) {
      return x ^ ((x ^ y) & -(x < y));
    }
    
    //Checks if a number is a power of two
    exports.isPow2 = function(v) {
      return !(v & (v-1)) && (!!v);
    }
    
    //Computes log base 2 of v
    exports.log2 = function(v) {
      var r, shift;
      r =     (v > 0xFFFF) << 4; v >>>= r;
      shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
      shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
      shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
      return r | (v >> 1);
    }
    
    //Computes log base 10 of v
    exports.log10 = function(v) {
      return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
              (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
              (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
    }
    
    //Counts number of bits
    exports.popCount = function(v) {
      v = v - ((v >>> 1) & 0x55555555);
      v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
      return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
    }
    
    //Counts number of trailing zeros
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v) c--;
      if (v & 0x0000FFFF) c -= 16;
      if (v & 0x00FF00FF) c -= 8;
      if (v & 0x0F0F0F0F) c -= 4;
      if (v & 0x33333333) c -= 2;
      if (v & 0x55555555) c -= 1;
      return c;
    }
    exports.countTrailingZeros = countTrailingZeros;
    
    //Rounds to next power of 2
    exports.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    }
    
    //Rounds down to previous power of 2
    exports.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v>>>1);
    }
    
    //Computes parity of word
    exports.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 0xf;
      return (0x6996 >>> v) & 1;
    }
    
    var REVERSE_TABLE = new Array(256);
    
    (function(tab) {
      for(var i=0; i<256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i] = (r << s) & 0xff;
      }
    })(REVERSE_TABLE);
    
    //Reverse bits in a 32 bit word
    exports.reverse = function(v) {
      return  (REVERSE_TABLE[ v         & 0xff] << 24) |
              (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
              (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
               REVERSE_TABLE[(v >>> 24) & 0xff];
    }
    
    //Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
    exports.interleave2 = function(x, y) {
      x &= 0xFFFF;
      x = (x | (x << 8)) & 0x00FF00FF;
      x = (x | (x << 4)) & 0x0F0F0F0F;
      x = (x | (x << 2)) & 0x33333333;
      x = (x | (x << 1)) & 0x55555555;
    
      y &= 0xFFFF;
      y = (y | (y << 8)) & 0x00FF00FF;
      y = (y | (y << 4)) & 0x0F0F0F0F;
      y = (y | (y << 2)) & 0x33333333;
      y = (y | (y << 1)) & 0x55555555;
    
      return x | (y << 1);
    }
    
    //Extracts the nth interleaved component
    exports.deinterleave2 = function(v, n) {
      v = (v >>> n) & 0x55555555;
      v = (v | (v >>> 1))  & 0x33333333;
      v = (v | (v >>> 2))  & 0x0F0F0F0F;
      v = (v | (v >>> 4))  & 0x00FF00FF;
      v = (v | (v >>> 16)) & 0x000FFFF;
      return (v << 16) >> 16;
    }
    
    
    //Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
    exports.interleave3 = function(x, y, z) {
      x &= 0x3FF;
      x  = (x | (x<<16)) & 4278190335;
      x  = (x | (x<<8))  & 251719695;
      x  = (x | (x<<4))  & 3272356035;
      x  = (x | (x<<2))  & 1227133513;
    
      y &= 0x3FF;
      y  = (y | (y<<16)) & 4278190335;
      y  = (y | (y<<8))  & 251719695;
      y  = (y | (y<<4))  & 3272356035;
      y  = (y | (y<<2))  & 1227133513;
      x |= (y << 1);
      
      z &= 0x3FF;
      z  = (z | (z<<16)) & 4278190335;
      z  = (z | (z<<8))  & 251719695;
      z  = (z | (z<<4))  & 3272356035;
      z  = (z | (z<<2))  & 1227133513;
      
      return x | (z << 2);
    }
    
    //Extracts nth interleaved component of a 3-tuple
    exports.deinterleave3 = function(v, n) {
      v = (v >>> n)       & 1227133513;
      v = (v | (v>>>2))   & 3272356035;
      v = (v | (v>>>4))   & 251719695;
      v = (v | (v>>>8))   & 4278190335;
      v = (v | (v>>>16))  & 0x3FF;
      return (v<<22)>>22;
    }
    
    //Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
    exports.nextCombination = function(v) {
      var t = v | (v - 1);
      return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
    }
    
    
    
    /***/ }),
    /* 28 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.Ticker = exports.shared = undefined;
    
    var _Ticker = __webpack_require__(113);
    
    var _Ticker2 = _interopRequireDefault(_Ticker);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * The shared ticker instance used by {@link PIXI.extras.AnimatedSprite}.
     * and by {@link PIXI.interaction.InteractionManager}.
     * The property {@link PIXI.ticker.Ticker#autoStart} is set to `true`
     * for this instance. Please follow the examples for usage, including
     * how to opt-out of auto-starting the shared ticker.
     *
     * @example
     * let ticker = PIXI.ticker.shared;
     * // Set this to prevent starting this ticker when listeners are added.
     * // By default this is true only for the PIXI.ticker.shared instance.
     * ticker.autoStart = false;
     * // FYI, call this to ensure the ticker is stopped. It should be stopped
     * // if you have not attempted to render anything yet.
     * ticker.stop();
     * // Call this when you are ready for a running shared ticker.
     * ticker.start();
     *
     * @example
     * // You may use the shared ticker to render...
     * let renderer = PIXI.autoDetectRenderer(800, 600);
     * let stage = new PIXI.Container();
     * let interactionManager = PIXI.interaction.InteractionManager(renderer);
     * document.body.appendChild(renderer.view);
     * ticker.add(function (time) {
     *     renderer.render(stage);
     * });
     *
     * @example
     * // Or you can just update it manually.
     * ticker.autoStart = false;
     * ticker.stop();
     * function animate(time) {
     *     ticker.update(time);
     *     renderer.render(stage);
     *     requestAnimationFrame(animate);
     * }
     * animate(performance.now());
     *
     * @type {PIXI.ticker.Ticker}
     * @memberof PIXI.ticker
     */
    var shared = new _Ticker2.default();
    
    shared.autoStart = true;
    shared.destroy = function () {
      // protect destroying shared ticker
      // this is used by other internal systems
      // like AnimatedSprite and InteractionManager
    };
    
    /**
     * This namespace contains an API for interacting with PIXI's internal global update loop.
     *
     * This ticker is used for rendering, {@link PIXI.extras.AnimatedSprite AnimatedSprite},
     * {@link PIXI.interaction.InteractionManager InteractionManager} and many other time-based PIXI systems.
     * @example
     * const ticker = new PIXI.ticker.Ticker();
     * ticker.stop();
     * ticker.add((deltaTime) => {
     *   // do something every frame
     * });
     * ticker.start();
     * @namespace PIXI.ticker
     */
    exports.shared = shared;
    exports.Ticker = _Ticker2.default;
    
    /***/ }),
    /* 29 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _BaseRenderTexture = __webpack_require__(53);
    
    var _BaseRenderTexture2 = _interopRequireDefault(_BaseRenderTexture);
    
    var _Texture2 = __webpack_require__(8);
    
    var _Texture3 = _interopRequireDefault(_Texture2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.
     *
     * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded
     * otherwise black rectangles will be drawn instead.
     *
     * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:
     *
     * ```js
     * let renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
     * let renderTexture = PIXI.RenderTexture.create(800, 600);
     * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
     *
     * sprite.position.x = 800/2;
     * sprite.position.y = 600/2;
     * sprite.anchor.x = 0.5;
     * sprite.anchor.y = 0.5;
     *
     * renderer.render(sprite, renderTexture);
     * ```
     *
     * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
     * you can clear the transform
     *
     * ```js
     *
     * sprite.setTransform()
     *
     * let renderTexture = new PIXI.RenderTexture.create(100, 100);
     *
     * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
     * ```
     *
     * @class
     * @extends PIXI.Texture
     * @memberof PIXI
     */
    var RenderTexture = function (_Texture) {
        _inherits(RenderTexture, _Texture);
    
        /**
         * @param {PIXI.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture
         * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show
         */
        function RenderTexture(baseRenderTexture, frame) {
            _classCallCheck(this, RenderTexture);
    
            // support for legacy..
            var _legacyRenderer = null;
    
            if (!(baseRenderTexture instanceof _BaseRenderTexture2.default)) {
                /* eslint-disable prefer-rest-params, no-console */
                var width = arguments[1];
                var height = arguments[2];
                var scaleMode = arguments[3];
                var resolution = arguments[4];
    
                // we have an old render texture..
                console.warn('Please use RenderTexture.create(' + width + ', ' + height + ') instead of the ctor directly.');
                _legacyRenderer = arguments[0];
                /* eslint-enable prefer-rest-params, no-console */
    
                frame = null;
                baseRenderTexture = new _BaseRenderTexture2.default(width, height, scaleMode, resolution);
            }
    
            /**
             * The base texture object that this texture uses
             *
             * @member {BaseTexture}
             */
    
            var _this = _possibleConstructorReturn(this, _Texture.call(this, baseRenderTexture, frame));
    
            _this.legacyRenderer = _legacyRenderer;
    
            /**
             * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
             *
             * @member {boolean}
             */
            _this.valid = true;
    
            _this._updateUvs();
            return _this;
        }
    
        /**
         * Resizes the RenderTexture.
         *
         * @param {number} width - The width to resize to.
         * @param {number} height - The height to resize to.
         * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?
         */
    
    
        RenderTexture.prototype.resize = function resize(width, height, doNotResizeBaseTexture) {
            // TODO - could be not required..
            this.valid = width > 0 && height > 0;
    
            this._frame.width = this.orig.width = width;
            this._frame.height = this.orig.height = height;
    
            if (!doNotResizeBaseTexture) {
                this.baseTexture.resize(width, height);
            }
    
            this._updateUvs();
        };
    
        /**
         * A short hand way of creating a render texture.
         *
         * @param {number} [width=100] - The width of the render texture
         * @param {number} [height=100] - The height of the render texture
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
         * @return {PIXI.RenderTexture} The new render texture
         */
    
    
        RenderTexture.create = function create(width, height, scaleMode, resolution) {
            return new RenderTexture(new _BaseRenderTexture2.default(width, height, scaleMode, resolution));
        };
    
        return RenderTexture;
    }(_Texture3.default);
    
    exports.default = RenderTexture;
    
    /***/ }),
    /* 30 */
    /***/ (function(module, exports, __webpack_require__) {
    
    /* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
    
      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
    
      return parts;
    }
    
    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe =
        /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };
    
    // path.resolve([from ...], to)
    // posix version
    exports.resolve = function() {
      var resolvedPath = '',
          resolvedAbsolute = false;
    
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : process.cwd();
    
        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
    
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
    
      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
    
      // Normalize the path
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
    
      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    };
    
    // path.normalize(path)
    // posix version
    exports.normalize = function(path) {
      var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
    
      // Normalize the path
      path = normalizeArray(filter(path.split('/'), function(p) {
        return !!p;
      }), !isAbsolute).join('/');
    
      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }
    
      return (isAbsolute ? '/' : '') + path;
    };
    
    // posix version
    exports.isAbsolute = function(path) {
      return path.charAt(0) === '/';
    };
    
    // posix version
    exports.join = function() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };
    
    
    // path.relative(from, to)
    // posix version
    exports.relative = function(from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);
    
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }
    
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }
    
        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }
    
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
    
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
    
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
    
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
    
      return outputParts.join('/');
    };
    
    exports.sep = '/';
    exports.delimiter = ':';
    
    exports.dirname = function(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];
    
      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }
    
      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }
    
      return root + dir;
    };
    
    
    exports.basename = function(path, ext) {
      var f = splitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    
    
    exports.extname = function(path) {
      return splitPath(path)[3];
    };
    
    function filter (xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
        }
        return res;
    }
    
    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b'
        ? function (str, start, len) { return str.substr(start, len) }
        : function (str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
        }
    ;
    
    /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(121)))
    
    /***/ }),
    /* 31 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _parseUri = __webpack_require__(74);
    
    var _parseUri2 = _interopRequireDefault(_parseUri);
    
    var _miniSignals = __webpack_require__(73);
    
    var _miniSignals2 = _interopRequireDefault(_miniSignals);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    // tests is CORS is supported in XHR, if not we need to use XDR
    var useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));
    var tempAnchor = null;
    
    // some status constants
    var STATUS_NONE = 0;
    var STATUS_OK = 200;
    var STATUS_EMPTY = 204;
    var STATUS_IE_BUG_EMPTY = 1223;
    var STATUS_TYPE_OK = 2;
    
    // noop
    function _noop() {} /* empty */
    
    /**
     * Manages the state and loading of a resource and all child resources.
     *
     * @class
     */
    
    var Resource = function () {
        /**
         * Sets the load type to be used for a specific extension.
         *
         * @static
         * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
         * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.
         */
        Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {
            setExtMap(Resource._loadTypeMap, extname, loadType);
        };
    
        /**
         * Sets the load type to be used for a specific extension.
         *
         * @static
         * @param {string} extname - The extension to set the type for, e.g. "png" or "fnt"
         * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.
         */
    
    
        Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {
            setExtMap(Resource._xhrTypeMap, extname, xhrType);
        };
    
        /**
         * @param {string} name - The name of the resource to load.
         * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass
         *      an array of sources.
         * @param {object} [options] - The options for the load.
         * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to
         *      determine automatically.
         * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource
         *      be loaded?
         * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How
         *      should the data being loaded be interpreted when using XHR?
         * @param {object} [options.metadata] - Extra configuration for middleware and the Resource object.
         * @param {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [options.metadata.loadElement=null] - The
         *      element to use for loading, instead of creating one.
         * @param {boolean} [options.metadata.skipSource=false] - Skips adding source(s) to the load element. This
         *      is useful if you want to pass in a `loadElement` that you already added load sources to.
         * @param {string|string[]} [options.metadata.mimeType] - The mime type to use for the source element of a video/audio
         *      elment. If the urls are an array, you can pass this as an array as well where each index is the mime type to
         *      use for the corresponding url index.
         */
    
    
        function Resource(name, url, options) {
            _classCallCheck(this, Resource);
    
            if (typeof name !== 'string' || typeof url !== 'string') {
                throw new Error('Both name and url are required for constructing a resource.');
            }
    
            options = options || {};
    
            /**
             * The state flags of this resource.
             *
             * @member {number}
             */
            this._flags = 0;
    
            // set data url flag, needs to be set early for some _determineX checks to work.
            this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);
    
            /**
             * The name of this resource.
             *
             * @member {string}
             * @readonly
             */
            this.name = name;
    
            /**
             * The url used to load this resource.
             *
             * @member {string}
             * @readonly
             */
            this.url = url;
    
            /**
             * The extension used to load this resource.
             *
             * @member {string}
             * @readonly
             */
            this.extension = this._getExtension();
    
            /**
             * The data that was loaded by the resource.
             *
             * @member {any}
             */
            this.data = null;
    
            /**
             * Is this request cross-origin? If unset, determined automatically.
             *
             * @member {string}
             */
            this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;
    
            /**
             * The method of loading to use for this resource.
             *
             * @member {Resource.LOAD_TYPE}
             */
            this.loadType = options.loadType || this._determineLoadType();
    
            /**
             * The type used to load the resource via XHR. If unset, determined automatically.
             *
             * @member {string}
             */
            this.xhrType = options.xhrType;
    
            /**
             * Extra info for middleware, and controlling specifics about how the resource loads.
             *
             * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.
             * Meaning it will modify it as it sees fit.
             *
             * @member {object}
             * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
             *  element to use for loading, instead of creating one.
             * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
             *  is useful if you want to pass in a `loadElement` that you already added load sources
             *  to.
             */
            this.metadata = options.metadata || {};
    
            /**
             * The error that occurred while loading (if any).
             *
             * @member {Error}
             * @readonly
             */
            this.error = null;
    
            /**
             * The XHR object that was used to load this resource. This is only set
             * when `loadType` is `Resource.LOAD_TYPE.XHR`.
             *
             * @member {XMLHttpRequest}
             * @readonly
             */
            this.xhr = null;
    
            /**
             * The child resources this resource owns.
             *
             * @member {Resource[]}
             * @readonly
             */
            this.children = [];
    
            /**
             * The resource type.
             *
             * @member {Resource.TYPE}
             * @readonly
             */
            this.type = Resource.TYPE.UNKNOWN;
    
            /**
             * The progress chunk owned by this resource.
             *
             * @member {number}
             * @readonly
             */
            this.progressChunk = 0;
    
            /**
             * The `dequeue` method that will be used a storage place for the async queue dequeue method
             * used privately by the loader.
             *
             * @private
             * @member {function}
             */
            this._dequeue = _noop;
    
            /**
             * Used a storage place for the on load binding used privately by the loader.
             *
             * @private
             * @member {function}
             */
            this._onLoadBinding = null;
    
            /**
             * The `complete` function bound to this resource's context.
             *
             * @private
             * @member {function}
             */
            this._boundComplete = this.complete.bind(this);
    
            /**
             * The `_onError` function bound to this resource's context.
             *
             * @private
             * @member {function}
             */
            this._boundOnError = this._onError.bind(this);
    
            /**
             * The `_onProgress` function bound to this resource's context.
             *
             * @private
             * @member {function}
             */
            this._boundOnProgress = this._onProgress.bind(this);
    
            // xhr callbacks
            this._boundXhrOnError = this._xhrOnError.bind(this);
            this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
            this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
            this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);
    
            /**
             * Dispatched when the resource beings to load.
             *
             * The callback looks like {@link Resource.OnStartSignal}.
             *
             * @member {Signal}
             */
            this.onStart = new _miniSignals2.default();
    
            /**
             * Dispatched each time progress of this resource load updates.
             * Not all resources types and loader systems can support this event
             * so sometimes it may not be available. If the resource
             * is being loaded on a modern browser, using XHR, and the remote server
             * properly sets Content-Length headers, then this will be available.
             *
             * The callback looks like {@link Resource.OnProgressSignal}.
             *
             * @member {Signal}
             */
            this.onProgress = new _miniSignals2.default();
    
            /**
             * Dispatched once this resource has loaded, if there was an error it will
             * be in the `error` property.
             *
             * The callback looks like {@link Resource.OnCompleteSignal}.
             *
             * @member {Signal}
             */
            this.onComplete = new _miniSignals2.default();
    
            /**
             * Dispatched after this resource has had all the *after* middleware run on it.
             *
             * The callback looks like {@link Resource.OnCompleteSignal}.
             *
             * @member {Signal}
             */
            this.onAfterMiddleware = new _miniSignals2.default();
    
            /**
             * When the resource starts to load.
             *
             * @memberof Resource
             * @callback OnStartSignal
             * @param {Resource} resource - The resource that the event happened on.
             */
    
            /**
             * When the resource reports loading progress.
             *
             * @memberof Resource
             * @callback OnProgressSignal
             * @param {Resource} resource - The resource that the event happened on.
             * @param {number} percentage - The progress of the load in the range [0, 1].
             */
    
            /**
             * When the resource finishes loading.
             *
             * @memberof Resource
             * @callback OnCompleteSignal
             * @param {Resource} resource - The resource that the event happened on.
             */
        }
    
        /**
         * Stores whether or not this url is a data url.
         *
         * @member {boolean}
         * @readonly
         */
    
    
        /**
         * Marks the resource as complete.
         *
         */
        Resource.prototype.complete = function complete() {
            // TODO: Clean this up in a wrapper or something...gross....
            if (this.data && this.data.removeEventListener) {
                this.data.removeEventListener('error', this._boundOnError, false);
                this.data.removeEventListener('load', this._boundComplete, false);
                this.data.removeEventListener('progress', this._boundOnProgress, false);
                this.data.removeEventListener('canplaythrough', this._boundComplete, false);
            }
    
            if (this.xhr) {
                if (this.xhr.removeEventListener) {
                    this.xhr.removeEventListener('error', this._boundXhrOnError, false);
                    this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
                    this.xhr.removeEventListener('progress', this._boundOnProgress, false);
                    this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
                } else {
                    this.xhr.onerror = null;
                    this.xhr.ontimeout = null;
                    this.xhr.onprogress = null;
                    this.xhr.onload = null;
                }
            }
    
            if (this.isComplete) {
                throw new Error('Complete called again for an already completed resource.');
            }
    
            this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);
            this._setFlag(Resource.STATUS_FLAGS.LOADING, false);
    
            this.onComplete.dispatch(this);
        };
    
        /**
         * Aborts the loading of this resource, with an optional message.
         *
         * @param {string} message - The message to use for the error
         */
    
    
        Resource.prototype.abort = function abort(message) {
            // abort can be called multiple times, ignore subsequent calls.
            if (this.error) {
                return;
            }
    
            // store error
            this.error = new Error(message);
    
            // abort the actual loading
            if (this.xhr) {
                this.xhr.abort();
            } else if (this.xdr) {
                this.xdr.abort();
            } else if (this.data) {
                // single source
                if (this.data.src) {
                    this.data.src = Resource.EMPTY_GIF;
                }
                // multi-source
                else {
                        while (this.data.firstChild) {
                            this.data.removeChild(this.data.firstChild);
                        }
                    }
            }
    
            // done now.
            this.complete();
        };
    
        /**
         * Kicks off loading of this resource. This method is asynchronous.
         *
         * @param {function} [cb] - Optional callback to call once the resource is loaded.
         */
    
    
        Resource.prototype.load = function load(cb) {
            var _this = this;
    
            if (this.isLoading) {
                return;
            }
    
            if (this.isComplete) {
                if (cb) {
                    setTimeout(function () {
                        return cb(_this);
                    }, 1);
                }
    
                return;
            } else if (cb) {
                this.onComplete.once(cb);
            }
    
            this._setFlag(Resource.STATUS_FLAGS.LOADING, true);
    
            this.onStart.dispatch(this);
    
            // if unset, determine the value
            if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {
                this.crossOrigin = this._determineCrossOrigin(this.url);
            }
    
            switch (this.loadType) {
                case Resource.LOAD_TYPE.IMAGE:
                    this.type = Resource.TYPE.IMAGE;
                    this._loadElement('image');
                    break;
    
                case Resource.LOAD_TYPE.AUDIO:
                    this.type = Resource.TYPE.AUDIO;
                    this._loadSourceElement('audio');
                    break;
    
                case Resource.LOAD_TYPE.VIDEO:
                    this.type = Resource.TYPE.VIDEO;
                    this._loadSourceElement('video');
                    break;
    
                case Resource.LOAD_TYPE.XHR:
                /* falls through */
                default:
                    if (useXdr && this.crossOrigin) {
                        this._loadXdr();
                    } else {
                        this._loadXhr();
                    }
                    break;
            }
        };
    
        /**
         * Checks if the flag is set.
         *
         * @private
         * @param {number} flag - The flag to check.
         * @return {boolean} True if the flag is set.
         */
    
    
        Resource.prototype._hasFlag = function _hasFlag(flag) {
            return !!(this._flags & flag);
        };
    
        /**
         * (Un)Sets the flag.
         *
         * @private
         * @param {number} flag - The flag to (un)set.
         * @param {boolean} value - Whether to set or (un)set the flag.
         */
    
    
        Resource.prototype._setFlag = function _setFlag(flag, value) {
            this._flags = value ? this._flags | flag : this._flags & ~flag;
        };
    
        /**
         * Loads this resources using an element that has a single source,
         * like an HTMLImageElement.
         *
         * @private
         * @param {string} type - The type of element to use.
         */
    
    
        Resource.prototype._loadElement = function _loadElement(type) {
            if (this.metadata.loadElement) {
                this.data = this.metadata.loadElement;
            } else if (type === 'image' && typeof window.Image !== 'undefined') {
                this.data = new Image();
            } else {
                this.data = document.createElement(type);
            }
    
            if (this.crossOrigin) {
                this.data.crossOrigin = this.crossOrigin;
            }
    
            if (!this.metadata.skipSource) {
                this.data.src = this.url;
            }
    
            this.data.addEventListener('error', this._boundOnError, false);
            this.data.addEventListener('load', this._boundComplete, false);
            this.data.addEventListener('progress', this._boundOnProgress, false);
        };
    
        /**
         * Loads this resources using an element that has multiple sources,
         * like an HTMLAudioElement or HTMLVideoElement.
         *
         * @private
         * @param {string} type - The type of element to use.
         */
    
    
        Resource.prototype._loadSourceElement = function _loadSourceElement(type) {
            if (this.metadata.loadElement) {
                this.data = this.metadata.loadElement;
            } else if (type === 'audio' && typeof window.Audio !== 'undefined') {
                this.data = new Audio();
            } else {
                this.data = document.createElement(type);
            }
    
            if (this.data === null) {
                this.abort('Unsupported element: ' + type);
    
                return;
            }
    
            if (!this.metadata.skipSource) {
                // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
                if (navigator.isCocoonJS) {
                    this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
                } else if (Array.isArray(this.url)) {
                    var mimeTypes = this.metadata.mimeType;
    
                    for (var i = 0; i < this.url.length; ++i) {
                        this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
                    }
                } else {
                    var _mimeTypes = this.metadata.mimeType;
    
                    this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
                }
            }
    
            this.data.addEventListener('error', this._boundOnError, false);
            this.data.addEventListener('load', this._boundComplete, false);
            this.data.addEventListener('progress', this._boundOnProgress, false);
            this.data.addEventListener('canplaythrough', this._boundComplete, false);
    
            this.data.load();
        };
    
        /**
         * Loads this resources using an XMLHttpRequest.
         *
         * @private
         */
    
    
        Resource.prototype._loadXhr = function _loadXhr() {
            // if unset, determine the value
            if (typeof this.xhrType !== 'string') {
                this.xhrType = this._determineXhrType();
            }
    
            var xhr = this.xhr = new XMLHttpRequest();
    
            // set the request type and url
            xhr.open('GET', this.url, true);
    
            // load json as text and parse it ourselves. We do this because some browsers
            // *cough* safari *cough* can't deal with it.
            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
                xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;
            } else {
                xhr.responseType = this.xhrType;
            }
    
            xhr.addEventListener('error', this._boundXhrOnError, false);
            xhr.addEventListener('abort', this._boundXhrOnAbort, false);
            xhr.addEventListener('progress', this._boundOnProgress, false);
            xhr.addEventListener('load', this._boundXhrOnLoad, false);
    
            xhr.send();
        };
    
        /**
         * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
         *
         * @private
         */
    
    
        Resource.prototype._loadXdr = function _loadXdr() {
            // if unset, determine the value
            if (typeof this.xhrType !== 'string') {
                this.xhrType = this._determineXhrType();
            }
    
            var xdr = this.xhr = new XDomainRequest();
    
            // XDomainRequest has a few quirks. Occasionally it will abort requests
            // A way to avoid this is to make sure ALL callbacks are set even if not used
            // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
            xdr.timeout = 5000;
    
            xdr.onerror = this._boundXhrOnError;
            xdr.ontimeout = this._boundXdrOnTimeout;
            xdr.onprogress = this._boundOnProgress;
            xdr.onload = this._boundXhrOnLoad;
    
            xdr.open('GET', this.url, true);
    
            // Note: The xdr.send() call is wrapped in a timeout to prevent an
            // issue with the interface where some requests are lost if multiple
            // XDomainRequests are being sent at the same time.
            // Some info here: https://github.com/photonstorm/phaser/issues/1248
            setTimeout(function () {
                return xdr.send();
            }, 1);
        };
    
        /**
         * Creates a source used in loading via an element.
         *
         * @private
         * @param {string} type - The element type (video or audio).
         * @param {string} url - The source URL to load from.
         * @param {string} [mime] - The mime type of the video
         * @return {HTMLSourceElement} The source element.
         */
    
    
        Resource.prototype._createSource = function _createSource(type, url, mime) {
            if (!mime) {
                mime = type + '/' + this._getExtension(url);
            }
    
            var source = document.createElement('source');
    
            source.src = url;
            source.type = mime;
    
            return source;
        };
    
        /**
         * Called if a load errors out.
         *
         * @param {Event} event - The error event from the element that emits it.
         * @private
         */
    
    
        Resource.prototype._onError = function _onError(event) {
            this.abort('Failed to load element using: ' + event.target.nodeName);
        };
    
        /**
         * Called if a load progress event fires for xhr/xdr.
         *
         * @private
         * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.
         */
    
    
        Resource.prototype._onProgress = function _onProgress(event) {
            if (event && event.lengthComputable) {
                this.onProgress.dispatch(this, event.loaded / event.total);
            }
        };
    
        /**
         * Called if an error event fires for xhr/xdr.
         *
         * @private
         * @param {XMLHttpRequestErrorEvent|Event} event - Error event.
         */
    
    
        Resource.prototype._xhrOnError = function _xhrOnError() {
            var xhr = this.xhr;
    
            this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
        };
    
        /**
         * Called if an abort event fires for xhr.
         *
         * @private
         * @param {XMLHttpRequestAbortEvent} event - Abort Event
         */
    
    
        Resource.prototype._xhrOnAbort = function _xhrOnAbort() {
            this.abort(reqType(this.xhr) + ' Request was aborted by the user.');
        };
    
        /**
         * Called if a timeout event fires for xdr.
         *
         * @private
         * @param {Event} event - Timeout event.
         */
    
    
        Resource.prototype._xdrOnTimeout = function _xdrOnTimeout() {
            this.abort(reqType(this.xhr) + ' Request timed out.');
        };
    
        /**
         * Called when data successfully loads from an xhr/xdr request.
         *
         * @private
         * @param {XMLHttpRequestLoadEvent|Event} event - Load event
         */
    
    
        Resource.prototype._xhrOnLoad = function _xhrOnLoad() {
            var xhr = this.xhr;
            var text = '';
            var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.
    
            // responseText is accessible only if responseType is '' or 'text' and on older browsers
            if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {
                text = xhr.responseText;
            }
    
            // status can be 0 when using the `file://` protocol so we also check if a response is set.
            // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
            if (status === STATUS_NONE && text.length > 0) {
                status = STATUS_OK;
            }
            // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
            else if (status === STATUS_IE_BUG_EMPTY) {
                    status = STATUS_EMPTY;
                }
    
            var statusType = status / 100 | 0;
    
            if (statusType === STATUS_TYPE_OK) {
                // if text, just return it
                if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {
                    this.data = text;
                    this.type = Resource.TYPE.TEXT;
                }
                // if json, parse into json object
                else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {
                        try {
                            this.data = JSON.parse(text);
                            this.type = Resource.TYPE.JSON;
                        } catch (e) {
                            this.abort('Error trying to parse loaded json: ' + e);
    
                            return;
                        }
                    }
                    // if xml, parse into an xml document or div element
                    else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
                            try {
                                if (window.DOMParser) {
                                    var domparser = new DOMParser();
    
                                    this.data = domparser.parseFromString(text, 'text/xml');
                                } else {
                                    var div = document.createElement('div');
    
                                    div.innerHTML = text;
    
                                    this.data = div;
                                }
    
                                this.type = Resource.TYPE.XML;
                            } catch (e) {
                                this.abort('Error trying to parse loaded xml: ' + e);
    
                                return;
                            }
                        }
                        // other types just return the response
                        else {
                                this.data = xhr.response || text;
                            }
            } else {
                this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);
    
                return;
            }
    
            this.complete();
        };
    
        /**
         * Sets the `crossOrigin` property for this resource based on if the url
         * for this resource is cross-origin. If crossOrigin was manually set, this
         * function does nothing.
         *
         * @private
         * @param {string} url - The url to test.
         * @param {object} [loc=window.location] - The location object to test against.
         * @return {string} The crossOrigin value to use (or empty string for none).
         */
    
    
        Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {
            // data: and javascript: urls are considered same-origin
            if (url.indexOf('data:') === 0) {
                return '';
            }
    
            // default is window.location
            loc = loc || window.location;
    
            if (!tempAnchor) {
                tempAnchor = document.createElement('a');
            }
    
            // let the browser determine the full href for the url of this resource and then
            // parse with the node url lib, we can't use the properties of the anchor element
            // because they don't work in IE9 :(
            tempAnchor.href = url;
            url = (0, _parseUri2.default)(tempAnchor.href, { strictMode: true });
    
            var samePort = !url.port && loc.port === '' || url.port === loc.port;
            var protocol = url.protocol ? url.protocol + ':' : '';
    
            // if cross origin
            if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
                return 'anonymous';
            }
    
            return '';
        };
    
        /**
         * Determines the responseType of an XHR request based on the extension of the
         * resource being loaded.
         *
         * @private
         * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
         */
    
    
        Resource.prototype._determineXhrType = function _determineXhrType() {
            return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;
        };
    
        /**
         * Determines the loadType of a resource based on the extension of the
         * resource being loaded.
         *
         * @private
         * @return {Resource.LOAD_TYPE} The loadType to use.
         */
    
    
        Resource.prototype._determineLoadType = function _determineLoadType() {
            return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;
        };
    
        /**
         * Extracts the extension (sans '.') of the file being loaded by the resource.
         *
         * @private
         * @return {string} The extension.
         */
    
    
        Resource.prototype._getExtension = function _getExtension() {
            var url = this.url;
            var ext = '';
    
            if (this.isDataUrl) {
                var slashIndex = url.indexOf('/');
    
                ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
            } else {
                var queryStart = url.indexOf('?');
                var hashStart = url.indexOf('#');
                var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);
    
                url = url.substring(0, index);
                ext = url.substring(url.lastIndexOf('.') + 1);
            }
    
            return ext.toLowerCase();
        };
    
        /**
         * Determines the mime type of an XHR request based on the responseType of
         * resource being loaded.
         *
         * @private
         * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
         * @return {string} The mime type to use.
         */
    
    
        Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) {
            switch (type) {
                case Resource.XHR_RESPONSE_TYPE.BUFFER:
                    return 'application/octet-binary';
    
                case Resource.XHR_RESPONSE_TYPE.BLOB:
                    return 'application/blob';
    
                case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
                    return 'application/xml';
    
                case Resource.XHR_RESPONSE_TYPE.JSON:
                    return 'application/json';
    
                case Resource.XHR_RESPONSE_TYPE.DEFAULT:
                case Resource.XHR_RESPONSE_TYPE.TEXT:
                /* falls through */
                default:
                    return 'text/plain';
    
            }
        };
    
        _createClass(Resource, [{
            key: 'isDataUrl',
            get: function get() {
                return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);
            }
    
            /**
             * Describes if this resource has finished loading. Is true when the resource has completely
             * loaded.
             *
             * @member {boolean}
             * @readonly
             */
    
        }, {
            key: 'isComplete',
            get: function get() {
                return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);
            }
    
            /**
             * Describes if this resource is currently loading. Is true when the resource starts loading,
             * and is false again when complete.
             *
             * @member {boolean}
             * @readonly
             */
    
        }, {
            key: 'isLoading',
            get: function get() {
                return this._hasFlag(Resource.STATUS_FLAGS.LOADING);
            }
        }]);
    
        return Resource;
    }();
    
    /**
     * The types of resources a resource could represent.
     *
     * @static
     * @readonly
     * @enum {number}
     */
    
    
    exports.default = Resource;
    Resource.STATUS_FLAGS = {
        NONE: 0,
        DATA_URL: 1 << 0,
        COMPLETE: 1 << 1,
        LOADING: 1 << 2
    };
    
    /**
     * The types of resources a resource could represent.
     *
     * @static
     * @readonly
     * @enum {number}
     */
    Resource.TYPE = {
        UNKNOWN: 0,
        JSON: 1,
        XML: 2,
        IMAGE: 3,
        AUDIO: 4,
        VIDEO: 5,
        TEXT: 6
    };
    
    /**
     * The types of loading a resource can use.
     *
     * @static
     * @readonly
     * @enum {number}
     */
    Resource.LOAD_TYPE = {
        /** Uses XMLHttpRequest to load the resource. */
        XHR: 1,
        /** Uses an `Image` object to load the resource. */
        IMAGE: 2,
        /** Uses an `Audio` object to load the resource. */
        AUDIO: 3,
        /** Uses a `Video` object to load the resource. */
        VIDEO: 4
    };
    
    /**
     * The XHR ready states, used internally.
     *
     * @static
     * @readonly
     * @enum {string}
     */
    Resource.XHR_RESPONSE_TYPE = {
        /** string */
        DEFAULT: 'text',
        /** ArrayBuffer */
        BUFFER: 'arraybuffer',
        /** Blob */
        BLOB: 'blob',
        /** Document */
        DOCUMENT: 'document',
        /** Object */
        JSON: 'json',
        /** String */
        TEXT: 'text'
    };
    
    Resource._loadTypeMap = {
        // images
        gif: Resource.LOAD_TYPE.IMAGE,
        png: Resource.LOAD_TYPE.IMAGE,
        bmp: Resource.LOAD_TYPE.IMAGE,
        jpg: Resource.LOAD_TYPE.IMAGE,
        jpeg: Resource.LOAD_TYPE.IMAGE,
        tif: Resource.LOAD_TYPE.IMAGE,
        tiff: Resource.LOAD_TYPE.IMAGE,
        webp: Resource.LOAD_TYPE.IMAGE,
        tga: Resource.LOAD_TYPE.IMAGE,
        svg: Resource.LOAD_TYPE.IMAGE,
        'svg+xml': Resource.LOAD_TYPE.IMAGE, // for SVG data urls
    
        // audio
        mp3: Resource.LOAD_TYPE.AUDIO,
        ogg: Resource.LOAD_TYPE.AUDIO,
        wav: Resource.LOAD_TYPE.AUDIO,
    
        // videos
        mp4: Resource.LOAD_TYPE.VIDEO,
        webm: Resource.LOAD_TYPE.VIDEO
    };
    
    Resource._xhrTypeMap = {
        // xml
        xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
        svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    
        // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
        // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
        // this should probably be fine.
        tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,
    
        // images
        gif: Resource.XHR_RESPONSE_TYPE.BLOB,
        png: Resource.XHR_RESPONSE_TYPE.BLOB,
        bmp: Resource.XHR_RESPONSE_TYPE.BLOB,
        jpg: Resource.XHR_RESPONSE_TYPE.BLOB,
        jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,
        tif: Resource.XHR_RESPONSE_TYPE.BLOB,
        tiff: Resource.XHR_RESPONSE_TYPE.BLOB,
        webp: Resource.XHR_RESPONSE_TYPE.BLOB,
        tga: Resource.XHR_RESPONSE_TYPE.BLOB,
    
        // json
        json: Resource.XHR_RESPONSE_TYPE.JSON,
    
        // text
        text: Resource.XHR_RESPONSE_TYPE.TEXT,
        txt: Resource.XHR_RESPONSE_TYPE.TEXT,
    
        // fonts
        ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,
        otf: Resource.XHR_RESPONSE_TYPE.BUFFER
    };
    
    // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif
    Resource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';
    
    /**
     * Quick helper to set a value on one of the extension maps. Ensures there is no
     * dot at the start of the extension.
     *
     * @ignore
     * @param {object} map - The map to set on.
     * @param {string} extname - The extension (or key) to set.
     * @param {number} val - The value to set.
     */
    function setExtMap(map, extname, val) {
        if (extname && extname.indexOf('.') === 0) {
            extname = extname.substring(1);
        }
    
        if (!extname) {
            return;
        }
    
        map[extname] = val;
    }
    
    /**
     * Quick helper to get string xhr type.
     *
     * @ignore
     * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
     * @return {string} The type.
     */
    function reqType(xhr) {
        return xhr.toString().replace('object ', '');
    }
    //# sourceMappingURL=Resource.js.map
    
    /***/ }),
    /* 32 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    var _TextureTransform = __webpack_require__(156);
    
    var _TextureTransform2 = _interopRequireDefault(_TextureTransform);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var tempPoint = new core.Point();
    var tempPolygon = new core.Polygon();
    
    /**
     * Base mesh class
     * @class
     * @extends PIXI.Container
     * @memberof PIXI.mesh
     */
    
    var Mesh = function (_core$Container) {
      _inherits(Mesh, _core$Container);
    
      /**
       * @param {PIXI.Texture} texture - The texture to use
       * @param {Float32Array} [vertices] - if you want to specify the vertices
       * @param {Float32Array} [uvs] - if you want to specify the uvs
       * @param {Uint16Array} [indices] - if you want to specify the indices
       * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts
       */
      function Mesh(texture, vertices, uvs, indices, drawMode) {
        _classCallCheck(this, Mesh);
    
        /**
         * The texture of the Mesh
         *
         * @member {PIXI.Texture}
         * @private
         */
        var _this = _possibleConstructorReturn(this, _core$Container.call(this));
    
        _this._texture = texture;
    
        /**
         * The Uvs of the Mesh
         *
         * @member {Float32Array}
         */
        _this.uvs = uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    
        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        _this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);
    
        /**
         * An array containing the indices of the vertices
         *
         * @member {Uint16Array}
         */
        //  TODO auto generate this based on draw mode!
        _this.indices = indices || new Uint16Array([0, 1, 3, 2]);
    
        /**
         * Version of mesh uvs are dirty or not
         *
         * @member {number}
         */
        _this.dirty = 0;
    
        /**
         * Version of mesh indices
         *
         * @member {number}
         */
        _this.indexDirty = 0;
    
        /**
         * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove
         * any blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        _this.blendMode = core.BLEND_MODES.NORMAL;
    
        /**
         * Triangles in canvas mode are automatically antialiased, use this value to force triangles
         * to overlap a bit with each other.
         *
         * @member {number}
         */
        _this.canvasPadding = 0;
    
        /**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts
         *
         * @member {number}
         * @see PIXI.mesh.Mesh.DRAW_MODES
         */
        _this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;
    
        /**
         * The default shader that is used if a mesh doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        _this.shader = null;
    
        /**
         * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any
         * tint effect.
         *
         * @member {number}
         */
        _this.tintRgb = new Float32Array([1, 1, 1]);
    
        /**
         * A map of renderer IDs to webgl render data
         *
         * @private
         * @member {object<number, object>}
         */
        _this._glDatas = {};
    
        /**
         * transform that is applied to UV to get the texture coords
         * its updated independently from texture uvTransform
         * updates of uvs are tied to that thing
         *
         * @member {PIXI.extras.TextureTransform}
         * @private
         */
        _this._uvTransform = new _TextureTransform2.default(texture);
    
        /**
         * whether or not upload uvTransform to shader
         * if its false, then uvs should be pre-multiplied
         * if you change it for generated mesh, please call 'refresh(true)'
         * @member {boolean}
         * @default false
         */
        _this.uploadUvTransform = false;
    
        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
         * @member {string}
         * @default 'mesh'
         */
        _this.pluginName = 'mesh';
        return _this;
      }
    
      /**
       * Renders the object using the WebGL renderer
       *
       * @private
       * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer
       */
    
    
      Mesh.prototype._renderWebGL = function _renderWebGL(renderer) {
        this.refresh();
        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
      };
    
      /**
       * Renders the object using the Canvas renderer
       *
       * @private
       * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.
       */
    
    
      Mesh.prototype._renderCanvas = function _renderCanvas(renderer) {
        this.refresh();
        renderer.plugins[this.pluginName].render(this);
      };
    
      /**
       * When the texture is updated, this event will fire to update the scale and frame
       *
       * @private
       */
    
    
      Mesh.prototype._onTextureUpdate = function _onTextureUpdate() {
        this._uvTransform.texture = this._texture;
        this.refresh();
      };
    
      /**
       * multiplies uvs only if uploadUvTransform is false
       * call it after you change uvs manually
       * make sure that texture is valid
       */
    
    
      Mesh.prototype.multiplyUvs = function multiplyUvs() {
        if (!this.uploadUvTransform) {
          this._uvTransform.multiplyUvs(this.uvs);
        }
      };
    
      /**
       * Refreshes uvs for generated meshes (rope, plane)
       * sometimes refreshes vertices too
       *
       * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case
       */
    
    
      Mesh.prototype.refresh = function refresh(forceUpdate) {
        if (this._uvTransform.update(forceUpdate)) {
          this._refresh();
        }
      };
    
      /**
       * re-calculates mesh coords
       * @protected
       */
    
    
      Mesh.prototype._refresh = function _refresh() {}
      /* empty */
    
    
      /**
       * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
       *
       */
      ;
    
      Mesh.prototype._calculateBounds = function _calculateBounds() {
        // TODO - we can cache local bounds and use them if they are dirty (like graphics)
        this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);
      };
    
      /**
       * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH
       *
       * @param {PIXI.Point} point - the point to test
       * @return {boolean} the result of the test
       */
    
    
      Mesh.prototype.containsPoint = function containsPoint(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return false;
        }
    
        this.worldTransform.applyInverse(point, tempPoint);
    
        var vertices = this.vertices;
        var points = tempPolygon.points;
        var indices = this.indices;
        var len = this.indices.length;
        var step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;
    
        for (var i = 0; i + 2 < len; i += step) {
          var ind0 = indices[i] * 2;
          var ind1 = indices[i + 1] * 2;
          var ind2 = indices[i + 2] * 2;
    
          points[0] = vertices[ind0];
          points[1] = vertices[ind0 + 1];
          points[2] = vertices[ind1];
          points[3] = vertices[ind1 + 1];
          points[4] = vertices[ind2];
          points[5] = vertices[ind2 + 1];
    
          if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
            return true;
          }
        }
    
        return false;
      };
    
      /**
       * The texture that the mesh uses.
       *
       * @member {PIXI.Texture}
       */
    
    
      _createClass(Mesh, [{
        key: 'texture',
        get: function get() {
          return this._texture;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
          if (this._texture === value) {
            return;
          }
    
          this._texture = value;
    
          if (value) {
            // wait for the texture to load
            if (value.baseTexture.hasLoaded) {
              this._onTextureUpdate();
            } else {
              value.once('update', this._onTextureUpdate, this);
            }
          }
        }
    
        /**
         * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @member {number}
         * @default 0xFFFFFF
         */
    
      }, {
        key: 'tint',
        get: function get() {
          return core.utils.rgb2hex(this.tintRgb);
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
          this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);
        }
      }]);
    
      return Mesh;
    }(core.Container);
    
    /**
     * Different drawing buffer modes supported
     *
     * @static
     * @constant
     * @type {object}
     * @property {number} TRIANGLE_MESH
     * @property {number} TRIANGLES
     */
    
    
    exports.default = Mesh;
    Mesh.DRAW_MODES = {
      TRIANGLE_MESH: 0,
      TRIANGLES: 1
    };
    
    /***/ }),
    /* 33 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _transition = __webpack_require__(20);
    
    var _transition2 = _interopRequireDefault(_transition);
    
    var _utils = __webpack_require__(19);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var tau = Math.PI * 2;
    var rad2percents = 100.0 / tau;
    var percents2rad = tau / 100;
    
    var RotatablePoint = function () {
        function RotatablePoint(pivot, baseRadius, orbitCoeff, initRotation, speed) {
            _classCallCheck(this, RotatablePoint);
    
            this._pivot = pivot || new RotatablePoint({ x: 0, y: 0 });
    
            this._baseRadius = baseRadius || 0;
            this._orbitCoeff = orbitCoeff || 0;
            this._initAngle = initRotation % tau || 0;
            this._rotatingAngle = 0;
            this._speed = speed || 0;
    
            this._initPosition();
    
            this.beforeUpdate = null;
        }
    
        RotatablePoint.prototype.isStatic = function isStatic() {
            return !this._speed || !this._orbitCoeff;
        };
    
        RotatablePoint.prototype.update = function update(deltaTime) {
            this._makeTransition(deltaTime);
            if (!deltaTime || this.isStatic()) {
                return;
            }
            var deltaAngle = deltaTime * this._speed;
            this._rotatingAngle += deltaAngle;
            this._rotatingAngle %= tau;
            this._updateRotation();
        };
    
        RotatablePoint.prototype.getState = function getState() {
            return {
                orbit: this.orbit,
                speed: this.speed,
                pace: this.pace,
                initRotation: this.initRotation
            };
        };
    
        RotatablePoint.prototype.setState = function setState(settings) {
            if ((typeof settings === "undefined" ? "undefined" : _typeof(settings)) !== "object") {
                throw new Error("Unable to setup state with non-object settings");
            }
            this.orbit = settings.orbit || 0;
            this.initRotation = settings.initRotation || 0;
            if (settings.hasOwnProperty("speed")) {
                this.speed = settings.speed;
            } else {
                this.pace = settings.pace || 0;
            }
        };
    
        RotatablePoint.prototype.transitTo = function transitTo(state, duration) {
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var easeType = arguments[3];
    
            if (!state) {
                return;
            }
            var transition = new _transition2.default(this, duration, delay, easeType);
            for (var key in state) {
                if (key === "initRotation") {
                    transition.tweenRotation(key, state[key], 100);
                    continue;
                }
                if (key === "pace") {
                    var targetSpeed = (0, _utils.convertSpeedPace)(state.pace);
                    transition.tween("speed", targetSpeed);
                    continue;
                }
                transition.tween(key, state[key]);
            }
        };
    
        RotatablePoint.prototype._updateRotation = function _updateRotation() {
            var angle = this._initAngle + this._rotatingAngle;
            var xOffset = this._orbit * Math.cos(angle);
            var yOffset = this._orbit * Math.sin(angle);
            this._position = {
                x: xOffset,
                y: yOffset
            };
        };
    
        RotatablePoint.prototype._initPosition = function _initPosition() {
            this._orbit = this._orbitCoeff * this._baseRadius;
            this._updateRotation();
        };
    
        RotatablePoint.prototype._makeTransition = function _makeTransition(deltaTime) {
            if (!this.__transition) {
                return;
            }
            this.__transition.tick(deltaTime);
        };
    
        _createClass(RotatablePoint, [{
            key: "orbit",
            get: function get() {
                return this._orbitCoeff * 100;
            },
            set: function set(value) {
                this._orbitCoeff = (value || 0) / 100;
                this._orbit = this._orbitCoeff * this._baseRadius;
                this._updateRotation();
            }
        }, {
            key: "initRotation",
            get: function get() {
                return this._initAngle * rad2percents;
            },
            set: function set(value) {
                this._initAngle = value % 100 * percents2rad;
                this._updateRotation();
            }
        }, {
            key: "speed",
            get: function get() {
                return this._speed;
            },
            set: function set(value) {
                this._speed = value || 0;
            }
        }, {
            key: "pace",
            get: function get() {
                if (!this._speed) {
                    return 0;
                }
                return (0, _utils.convertSpeedPace)(this._speed);
            },
            set: function set(value) {
                if (!value) {
                    this._speed = 0;
                } else {
                    this._speed = (0, _utils.convertSpeedPace)(value);
                }
            }
        }, {
            key: "x",
            get: function get() {
                return Math.floor(this._position.x + this._pivot.x);
            }
        }, {
            key: "y",
            get: function get() {
                return Math.floor(this._position.y + this._pivot.y);
            }
        }]);
    
        return RotatablePoint;
    }();
    
    exports.default = RotatablePoint;
    
    /***/ }),
    /* 34 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Matrix = __webpack_require__(22);
    
    var _Matrix2 = _interopRequireDefault(_Matrix);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16
    
    var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    var tempMatrices = [];
    
    var mul = [];
    
    function signum(x) {
        if (x < 0) {
            return -1;
        }
        if (x > 0) {
            return 1;
        }
    
        return 0;
    }
    
    function init() {
        for (var i = 0; i < 16; i++) {
            var row = [];
    
            mul.push(row);
    
            for (var j = 0; j < 16; j++) {
                var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
                var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
                var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
                var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
    
                for (var k = 0; k < 16; k++) {
                    if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
                        row.push(k);
                        break;
                    }
                }
            }
        }
    
        for (var _i = 0; _i < 16; _i++) {
            var mat = new _Matrix2.default();
    
            mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);
            tempMatrices.push(mat);
        }
    }
    
    init();
    
    /**
     * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},
     * D8 is the same but with diagonals. Used for texture rotations.
     *
     * Vector xX(i), xY(i) is U-axis of sprite with rotation i
     * Vector yY(i), yY(i) is V-axis of sprite with rotation i
     * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)
     * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)
     * This is the small part of gameofbombs.com portal system. It works.
     *
     * @author Ivan @ivanpopelyshev
     * @class
     * @memberof PIXI
     */
    var GroupD8 = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MIRROR_HORIZONTAL: 12,
        uX: function uX(ind) {
            return ux[ind];
        },
        uY: function uY(ind) {
            return uy[ind];
        },
        vX: function vX(ind) {
            return vx[ind];
        },
        vY: function vY(ind) {
            return vy[ind];
        },
        inv: function inv(rotation) {
            if (rotation & 8) {
                return rotation & 15;
            }
    
            return -rotation & 7;
        },
        add: function add(rotationSecond, rotationFirst) {
            return mul[rotationSecond][rotationFirst];
        },
        sub: function sub(rotationSecond, rotationFirst) {
            return mul[rotationSecond][GroupD8.inv(rotationFirst)];
        },
    
        /**
         * Adds 180 degrees to rotation. Commutative operation.
         *
         * @memberof PIXI.GroupD8
         * @param {number} rotation - The number to rotate.
         * @returns {number} rotated number
         */
        rotate180: function rotate180(rotation) {
            return rotation ^ 4;
        },
    
        /**
         * I dont know why sometimes width and heights needs to be swapped. We'll fix it later.
         *
         * @memberof PIXI.GroupD8
         * @param {number} rotation - The number to check.
         * @returns {boolean} Whether or not the width/height should be swapped.
         */
        isSwapWidthHeight: function isSwapWidthHeight(rotation) {
            return (rotation & 3) === 2;
        },
    
        /**
         * @memberof PIXI.GroupD8
         * @param {number} dx - TODO
         * @param {number} dy - TODO
         *
         * @return {number} TODO
         */
        byDirection: function byDirection(dx, dy) {
            if (Math.abs(dx) * 2 <= Math.abs(dy)) {
                if (dy >= 0) {
                    return GroupD8.S;
                }
    
                return GroupD8.N;
            } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
                if (dx > 0) {
                    return GroupD8.E;
                }
    
                return GroupD8.W;
            } else if (dy > 0) {
                if (dx > 0) {
                    return GroupD8.SE;
                }
    
                return GroupD8.SW;
            } else if (dx > 0) {
                return GroupD8.NE;
            }
    
            return GroupD8.NW;
        },
    
        /**
         * Helps sprite to compensate texture packer rotation.
         *
         * @memberof PIXI.GroupD8
         * @param {PIXI.Matrix} matrix - sprite world matrix
         * @param {number} rotation - The rotation factor to use.
         * @param {number} tx - sprite anchoring
         * @param {number} ty - sprite anchoring
         */
        matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) {
            var tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    
            // Packer used "rotation", we use "inv(rotation)"
            var mat = tempMatrices[GroupD8.inv(rotation)];
    
            mat.tx = tx;
            mat.ty = ty;
            matrix.append(mat);
        }
    };
    
    exports.default = GroupD8;
    
    /***/ }),
    /* 35 */
    /***/ (function(module, exports) {
    
    // var GL_MAP = {};
    
    /**
     * @param gl {WebGLRenderingContext} The current WebGL context
     * @param attribs {*}
     * @param state {*}
     */
    var setVertexAttribArrays = function (gl, attribs, state)
    {
        var i;
        if(state)
        {
            var tempAttribState = state.tempAttribState,
                attribState = state.attribState;
    
            for (i = 0; i < tempAttribState.length; i++)
            {
                tempAttribState[i] = false;
            }
    
            // set the new attribs
            for (i = 0; i < attribs.length; i++)
            {
                tempAttribState[attribs[i].attribute.location] = true;
            }
    
            for (i = 0; i < attribState.length; i++)
            {
                if (attribState[i] !== tempAttribState[i])
                {
                    attribState[i] = tempAttribState[i];
    
                    if (state.attribState[i])
                    {
                        gl.enableVertexAttribArray(i);
                    }
                    else
                    {
                        gl.disableVertexAttribArray(i);
                    }
                }
            }
    
        }
        else
        {
            for (i = 0; i < attribs.length; i++)
            {
                var attrib = attribs[i];
                gl.enableVertexAttribArray(attrib.attribute.location);
            }
        }
    };
    
    module.exports = setVertexAttribArrays;
    
    
    /***/ }),
    /* 36 */
    /***/ (function(module, exports) {
    
    
    /**
     * Helper class to create a WebGL Texture
     *
     * @class
     * @memberof PIXI.glCore
     * @param gl {WebGLRenderingContext} The current WebGL context
     * @param width {number} the width of the texture
     * @param height {number} the height of the texture
     * @param format {number} the pixel format of the texture. defaults to gl.RGBA
     * @param type {number} the gl type of the texture. defaults to gl.UNSIGNED_BYTE
     */
    var Texture = function(gl, width, height, format, type)
    {
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
    
        /**
         * The WebGL texture
         *
         * @member {WebGLTexture}
         */
        this.texture = gl.createTexture();
    
        /**
         * If mipmapping was used for this texture, enable and disable with enableMipmap()
         *
         * @member {Boolean}
         */
        // some settings..
        this.mipmap = false;
    
    
        /**
         * Set to true to enable pre-multiplied alpha
         *
         * @member {Boolean}
         */
        this.premultiplyAlpha = false;
    
        /**
         * The width of texture
         *
         * @member {Number}
         */
        this.width = width || -1;
        /**
         * The height of texture
         *
         * @member {Number}
         */
        this.height = height || -1;
    
        /**
         * The pixel format of the texture. defaults to gl.RGBA
         *
         * @member {Number}
         */
        this.format = format || gl.RGBA;
    
        /**
         * The gl type of the texture. defaults to gl.UNSIGNED_BYTE
         *
         * @member {Number}
         */
        this.type = type || gl.UNSIGNED_BYTE;
    
    
    };
    
    /**
     * Uploads this texture to the GPU
     * @param source {HTMLImageElement|ImageData|HTMLVideoElement} the source image of the texture
     */
    Texture.prototype.upload = function(source)
    {
        this.bind();
    
        var gl = this.gl;
    
    
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
    
        var newWidth = source.videoWidth || source.width;
        var newHeight = source.videoHeight || source.height;
    
        if(newHeight !== this.height || newWidth !== this.width)
        {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source);
        }
        else
        {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source);
        }
    
        // if the source is a video, we need to use the videoWidth / videoHeight properties as width / height will be incorrect.
        this.width = newWidth;
        this.height = newHeight;
    
    };
    
    var FLOATING_POINT_AVAILABLE = false;
    
    /**
     * Use a data source and uploads this texture to the GPU
     * @param data {TypedArray} the data to upload to the texture
     * @param width {number} the new width of the texture
     * @param height {number} the new height of the texture
     */
    Texture.prototype.uploadData = function(data, width, height)
    {
        this.bind();
    
        var gl = this.gl;
    
    
        if(data instanceof Float32Array)
        {
            if(!FLOATING_POINT_AVAILABLE)
            {
                var ext = gl.getExtension("OES_texture_float");
    
                if(ext)
                {
                    FLOATING_POINT_AVAILABLE = true;
                }
                else
                {
                    throw new Error('floating point textures not available');
                }
            }
    
            this.type = gl.FLOAT;
        }
        else
        {
            // TODO support for other types
            this.type = this.type || gl.UNSIGNED_BYTE;
        }
    
        // what type of data?
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
    
    
        if(width !== this.width || height !== this.height)
        {
            gl.texImage2D(gl.TEXTURE_2D, 0, this.format,  width, height, 0, this.format, this.type, data || null);
        }
        else
        {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null);
        }
    
        this.width = width;
        this.height = height;
    
    
    //	texSubImage2D
    };
    
    /**
     * Binds the texture
     * @param  location
     */
    Texture.prototype.bind = function(location)
    {
        var gl = this.gl;
    
        if(location !== undefined)
        {
            gl.activeTexture(gl.TEXTURE0 + location);
        }
    
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    };
    
    /**
     * Unbinds the texture
     */
    Texture.prototype.unbind = function()
    {
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    
    /**
     * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
     */
    Texture.prototype.minFilter = function( linear )
    {
        var gl = this.gl;
    
        this.bind();
    
        if(this.mipmap)
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
        }
        else
        {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST);
        }
    };
    
    /**
     * @param linear {Boolean} if we want to use linear filtering or nearest neighbour interpolation
     */
    Texture.prototype.magFilter = function( linear )
    {
        var gl = this.gl;
    
        this.bind();
    
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST);
    };
    
    /**
     * Enables mipmapping
     */
    Texture.prototype.enableMipmap = function()
    {
        var gl = this.gl;
    
        this.bind();
    
        this.mipmap = true;
    
        gl.generateMipmap(gl.TEXTURE_2D);
    };
    
    /**
     * Enables linear filtering
     */
    Texture.prototype.enableLinearScaling = function()
    {
        this.minFilter(true);
        this.magFilter(true);
    };
    
    /**
     * Enables nearest neighbour interpolation
     */
    Texture.prototype.enableNearestScaling = function()
    {
        this.minFilter(false);
        this.magFilter(false);
    };
    
    /**
     * Enables clamping on the texture so WebGL will not repeat it
     */
    Texture.prototype.enableWrapClamp = function()
    {
        var gl = this.gl;
    
        this.bind();
    
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    };
    
    /**
     * Enable tiling on the texture
     */
    Texture.prototype.enableWrapRepeat = function()
    {
        var gl = this.gl;
    
        this.bind();
    
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    };
    
    Texture.prototype.enableWrapMirrorRepeat = function()
    {
        var gl = this.gl;
    
        this.bind();
    
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
    };
    
    
    /**
     * Destroys this texture
     */
    Texture.prototype.destroy = function()
    {
        var gl = this.gl;
        //TODO
        gl.deleteTexture(this.texture);
    };
    
    /**
     * @static
     * @param gl {WebGLRenderingContext} The current WebGL context
     * @param source {HTMLImageElement|ImageData} the source image of the texture
     * @param premultiplyAlpha {Boolean} If we want to use pre-multiplied alpha
     */
    Texture.fromSource = function(gl, source, premultiplyAlpha)
    {
        var texture = new Texture(gl);
        texture.premultiplyAlpha = premultiplyAlpha || false;
        texture.upload(source);
    
        return texture;
    };
    
    /**
     * @static
     * @param gl {WebGLRenderingContext} The current WebGL context
     * @param data {TypedArray} the data to upload to the texture
     * @param width {number} the new width of the texture
     * @param height {number} the new height of the texture
     */
    Texture.fromData = function(gl, data, width, height)
    {
        //console.log(data, width, height);
        var texture = new Texture(gl);
        texture.uploadData(data, width, height);
    
        return texture;
    };
    
    
    module.exports = Texture;
    
    
    /***/ }),
    /* 37 */
    /***/ (function(module, exports) {
    
    
    /**
     * @class
     * @memberof PIXI.glCore.shader
     * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
     * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
     * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
     * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
     * @return {WebGLProgram} the shader program
     */
    var compileProgram = function(gl, vertexSrc, fragmentSrc, attributeLocations)
    {
        var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
    
        var program = gl.createProgram();
    
        gl.attachShader(program, glVertShader);
        gl.attachShader(program, glFragShader);
    
        // optionally, set the attributes manually for the program rather than letting WebGL decide..
        if(attributeLocations)
        {
            for(var i in attributeLocations)
            {
                gl.bindAttribLocation(program, attributeLocations[i], i);
            }
        }
    
    
        gl.linkProgram(program);
    
        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(program, gl.LINK_STATUS))
        {
            console.error('Pixi.js Error: Could not initialize shader.');
            console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
            console.error('gl.getError()', gl.getError());
    
            // if there is a program info log, log it
            if (gl.getProgramInfoLog(program) !== '')
            {
                console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
            }
    
            gl.deleteProgram(program);
            program = null;
        }
    
        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
    
        return program;
    };
    
    /**
     * @private
     * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
     * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
     * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
     * @return {WebGLShader} the shader
     */
    var compileShader = function (gl, type, src)
    {
        var shader = gl.createShader(type);
    
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
    
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        {
            console.log(gl.getShaderInfoLog(shader));
            return null;
        }
    
        return shader;
    };
    
    module.exports = compileProgram;
    
    
    /***/ }),
    /* 38 */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    var mapType = __webpack_require__(24);
    var mapSize = __webpack_require__(39);
    
    /**
     * Extracts the attributes
     * @class
     * @memberof PIXI.glCore.shader
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     * @param program {WebGLProgram} The shader program to get the attributes from
     * @return attributes {Object}
     */
    var extractAttributes = function(gl, program)
    {
        var attributes = {};
    
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    
        for (var i = 0; i < totalAttributes; i++)
        {
            var attribData = gl.getActiveAttrib(program, i);
            var type = mapType(gl, attribData.type);
    
            attributes[attribData.name] = {
                type:type,
                size:mapSize(type),
                location:gl.getAttribLocation(program, attribData.name),
                //TODO - make an attribute object
                pointer: pointer
            };
        }
    
        return attributes;
    };
    
    var pointer = function(type, normalized, stride, start){
        // console.log(this.location)
        gl.vertexAttribPointer(this.location,this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0);
    };
    
    module.exports = extractAttributes;
    
    
    /***/ }),
    /* 39 */
    /***/ (function(module, exports) {
    
    /**
     * @class
     * @memberof PIXI.glCore.shader
     * @param type {String}
     * @return {Number}
     */
    var mapSize = function(type) 
    { 
        return GLSL_TO_SIZE[type];
    };
    
    
    var GLSL_TO_SIZE = {
        'float':    1,
        'vec2':     2,
        'vec3':     3,
        'vec4':     4,
    
        'int':      1,
        'ivec2':    2,
        'ivec3':    3,
        'ivec4':    4,
    
        'bool':     1,
        'bvec2':    2,
        'bvec3':    3,
        'bvec4':    4,
    
        'mat2':     4,
        'mat3':     9,
        'mat4':     16,
    
        'sampler2D':  1
    };
    
    module.exports = mapSize;
    
    
    /***/ }),
    /* 40 */
    /***/ (function(module, exports, __webpack_require__) {
    
    var mapType = __webpack_require__(24);
    var defaultValue = __webpack_require__(41);
    
    /**
     * Extracts the uniforms
     * @class
     * @memberof PIXI.glCore.shader
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     * @param program {WebGLProgram} The shader program to get the uniforms from
     * @return uniforms {Object}
     */
    var extractUniforms = function(gl, program)
    {
        var uniforms = {};
    
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    
        for (var i = 0; i < totalUniforms; i++)
        {
            var uniformData = gl.getActiveUniform(program, i);
            var name = uniformData.name.replace(/\[.*?\]/, "");
            var type = mapType(gl, uniformData.type );
    
            uniforms[name] = {
                type:type,
                size:uniformData.size,
                location:gl.getUniformLocation(program, name),
                value:defaultValue(type, uniformData.size)
            };
        }
    
        return uniforms;
    };
    
    module.exports = extractUniforms;
    
    
    /***/ }),
    /* 41 */
    /***/ (function(module, exports) {
    
    /**
     * @class
     * @memberof PIXI.glCore.shader
     * @param type {String} Type of value
     * @param size {Number}
     */
    var defaultValue = function(type, size) 
    {
        switch (type)
        {
            case 'float':
                return 0;
    
            case 'vec2': 
                return new Float32Array(2 * size);
    
            case 'vec3':
                return new Float32Array(3 * size);
    
            case 'vec4':     
                return new Float32Array(4 * size);
                
            case 'int':
            case 'sampler2D':
                return 0;
    
            case 'ivec2':   
                return new Int32Array(2 * size);
    
            case 'ivec3':
                return new Int32Array(3 * size);
    
            case 'ivec4': 
                return new Int32Array(4 * size);
    
            case 'bool':     
                return false;
    
            case 'bvec2':
    
                return booleanArray( 2 * size);
    
            case 'bvec3':
                return booleanArray(3 * size);
    
            case 'bvec4':
                return booleanArray(4 * size);
    
            case 'mat2':
                return new Float32Array([1, 0,
                                         0, 1]);
    
            case 'mat3': 
                return new Float32Array([1, 0, 0,
                                         0, 1, 0,
                                         0, 0, 1]);
    
            case 'mat4':
                return new Float32Array([1, 0, 0, 0,
                                         0, 1, 0, 0,
                                         0, 0, 1, 0,
                                         0, 0, 0, 1]);
        }
    };
    
    var booleanArray = function(size)
    {
        var array = new Array(size);
    
        for (var i = 0; i < array.length; i++) 
        {
            array[i] = false;
        }
    
        return array;
    };
    
    module.exports = defaultValue;
    
    
    /***/ }),
    /* 42 */
    /***/ (function(module, exports) {
    
    /**
     * Sets the float precision on the shader. If the precision is already present this function will do nothing
     * @param {string} src       the shader source
     * @param {string} precision The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
     *
     * @return {string} modified shader source
     */
    var setPrecision = function(src, precision)
    {
        if(src.substring(0, 9) !== 'precision')
        {
            return 'precision ' + precision + ' float;\n' + src;
        }
    
        return src;
    };
    
    module.exports = setPrecision;
    
    
    /***/ }),
    /* 43 */
    /***/ (function(module, exports) {
    
    /**
     * Extracts the attributes
     * @class
     * @memberof PIXI.glCore.shader
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     * @param uniforms {Array} @mat ?
     * @return attributes {Object}
     */
    var generateUniformAccessObject = function(gl, uniformData)
    {
        // this is the object we will be sending back.
        // an object hierachy will be created for structs
        var uniforms = {data:{}};
    
        uniforms.gl = gl;
    
        var uniformKeys= Object.keys(uniformData);
    
        for (var i = 0; i < uniformKeys.length; i++)
        {
            var fullName = uniformKeys[i];
    
            var nameTokens = fullName.split('.');
            var name = nameTokens[nameTokens.length - 1];
    
    
            var uniformGroup = getUniformGroup(nameTokens, uniforms);
    
            var uniform =  uniformData[fullName];
            uniformGroup.data[name] = uniform;
    
            uniformGroup.gl = gl;
    
            Object.defineProperty(uniformGroup, name, {
                get: generateGetter(name),
                set: generateSetter(name, uniform)
            });
        }
    
        return uniforms;
    };
    
    var generateGetter = function(name)
    {
        var template = getterTemplate.replace('%%', name);
        return new Function(template); // jshint ignore:line
    };
    
    var generateSetter = function(name, uniform)
    {
        var template = setterTemplate.replace(/%%/g, name);
        var setTemplate;
    
        if(uniform.size === 1)
        {
            setTemplate = GLSL_TO_SINGLE_SETTERS[uniform.type];
        }
        else
        {
            setTemplate = GLSL_TO_ARRAY_SETTERS[uniform.type];
        }
    
        if(setTemplate)
        {
            template += "\nthis.gl." + setTemplate + ";";
        }
    
          return new Function('value', template); // jshint ignore:line
    };
    
    var getUniformGroup = function(nameTokens, uniform)
    {
        var cur = uniform;
    
        for (var i = 0; i < nameTokens.length - 1; i++)
        {
            var o = cur[nameTokens[i]] || {data:{}};
            cur[nameTokens[i]] = o;
            cur = o;
        }
    
        return cur;
    };
    
    var getterTemplate = [
        'return this.data.%%.value;',
    ].join('\n');
    
    var setterTemplate = [
        'this.data.%%.value = value;',
        'var location = this.data.%%.location;'
    ].join('\n');
    
    
    var GLSL_TO_SINGLE_SETTERS = {
    
        'float':    'uniform1f(location, value)',
    
        'vec2':     'uniform2f(location, value[0], value[1])',
        'vec3':     'uniform3f(location, value[0], value[1], value[2])',
        'vec4':     'uniform4f(location, value[0], value[1], value[2], value[3])',
    
        'int':      'uniform1i(location, value)',
        'ivec2':    'uniform2i(location, value[0], value[1])',
        'ivec3':    'uniform3i(location, value[0], value[1], value[2])',
        'ivec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',
    
        'bool':     'uniform1i(location, value)',
        'bvec2':    'uniform2i(location, value[0], value[1])',
        'bvec3':    'uniform3i(location, value[0], value[1], value[2])',
        'bvec4':    'uniform4i(location, value[0], value[1], value[2], value[3])',
    
        'mat2':     'uniformMatrix2fv(location, false, value)',
        'mat3':     'uniformMatrix3fv(location, false, value)',
        'mat4':     'uniformMatrix4fv(location, false, value)',
    
        'sampler2D':'uniform1i(location, value)'
    };
    
    var GLSL_TO_ARRAY_SETTERS = {
    
        'float':    'uniform1fv(location, value)',
    
        'vec2':     'uniform2fv(location, value)',
        'vec3':     'uniform3fv(location, value)',
        'vec4':     'uniform4fv(location, value)',
    
        'int':      'uniform1iv(location, value)',
        'ivec2':    'uniform2iv(location, value)',
        'ivec3':    'uniform3iv(location, value)',
        'ivec4':    'uniform4iv(location, value)',
    
        'bool':     'uniform1iv(location, value)',
        'bvec2':    'uniform2iv(location, value)',
        'bvec3':    'uniform3iv(location, value)',
        'bvec4':    'uniform4iv(location, value)',
    
        'sampler2D':'uniform1iv(location, value)'
    };
    
    module.exports = generateUniformAccessObject;
    
    
    /***/ }),
    /* 44 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _eventemitter = __webpack_require__(6);
    
    var _eventemitter2 = _interopRequireDefault(_eventemitter);
    
    var _const = __webpack_require__(0);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _TransformStatic = __webpack_require__(46);
    
    var _TransformStatic2 = _interopRequireDefault(_TransformStatic);
    
    var _Transform = __webpack_require__(47);
    
    var _Transform2 = _interopRequireDefault(_Transform);
    
    var _Bounds = __webpack_require__(25);
    
    var _Bounds2 = _interopRequireDefault(_Bounds);
    
    var _math = __webpack_require__(2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    // _tempDisplayObjectParent = new DisplayObject();
    
    /**
     * The base class for all objects that are rendered on the screen.
     * This is an abstract class and should not be used on its own rather it should be extended.
     *
     * @class
     * @extends EventEmitter
     * @memberof PIXI
     */
    var DisplayObject = function (_EventEmitter) {
        _inherits(DisplayObject, _EventEmitter);
    
        /**
         *
         */
        function DisplayObject() {
            _classCallCheck(this, DisplayObject);
    
            var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
    
            var TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;
    
            _this.tempDisplayObjectParent = null;
    
            // TODO: need to create Transform from factory
            /**
             * World transform and local transform of this object.
             * This will become read-only later, please do not assign anything there unless you know what are you doing
             *
             * @member {PIXI.TransformBase}
             */
            _this.transform = new TransformClass();
    
            /**
             * The opacity of the object.
             *
             * @member {number}
             */
            _this.alpha = 1;
    
            /**
             * The visibility of the object. If false the object will not be drawn, and
             * the updateTransform function will not be called.
             *
             * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually
             *
             * @member {boolean}
             */
            _this.visible = true;
    
            /**
             * Can this object be rendered, if false the object will not be drawn but the updateTransform
             * methods will still be called.
             *
             * Only affects recursive calls from parent. You can ask for bounds manually
             *
             * @member {boolean}
             */
            _this.renderable = true;
    
            /**
             * The display object container that contains this display object.
             *
             * @member {PIXI.Container}
             * @readonly
             */
            _this.parent = null;
    
            /**
             * The multiplied alpha of the displayObject
             *
             * @member {number}
             * @readonly
             */
            _this.worldAlpha = 1;
    
            /**
             * The area the filter is applied to. This is used as more of an optimisation
             * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle
             *
             * Also works as an interaction mask
             *
             * @member {PIXI.Rectangle}
             */
            _this.filterArea = null;
    
            _this._filters = null;
            _this._enabledFilters = null;
    
            /**
             * The bounds object, this is used to calculate and store the bounds of the displayObject
             *
             * @member {PIXI.Rectangle}
             * @private
             */
            _this._bounds = new _Bounds2.default();
            _this._boundsID = 0;
            _this._lastBoundsID = -1;
            _this._boundsRect = null;
            _this._localBoundsRect = null;
    
            /**
             * The original, cached mask of the object
             *
             * @member {PIXI.Graphics|PIXI.Sprite}
             * @private
             */
            _this._mask = null;
    
            /**
             * If the object has been destroyed via destroy(). If true, it should not be used.
             *
             * @member {boolean}
             * @private
             * @readonly
             */
            _this._destroyed = false;
    
            /**
             * Fired when this DisplayObject is added to a Container.
             *
             * @event PIXI.DisplayObject#added
             * @param {PIXI.Container} container - The container added to.
             */
    
            /**
             * Fired when this DisplayObject is removed from a Container.
             *
             * @event PIXI.DisplayObject#removed
             * @param {PIXI.Container} container - The container removed from.
             */
            return _this;
        }
    
        /**
         * @private
         * @member {PIXI.DisplayObject}
         */
    
    
        /**
         * Updates the object transform for rendering
         *
         * TODO - Optimization pass!
         */
        DisplayObject.prototype.updateTransform = function updateTransform() {
            this.transform.updateTransform(this.parent.transform);
            // multiply the alphas..
            this.worldAlpha = this.alpha * this.parent.worldAlpha;
    
            this._bounds.updateID++;
        };
    
        /**
         * recursively updates transform of all objects from the root to this one
         * internal function for toLocal()
         */
    
    
        DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() {
            if (this.parent) {
                this.parent._recursivePostUpdateTransform();
                this.transform.updateTransform(this.parent.transform);
            } else {
                this.transform.updateTransform(this._tempDisplayObjectParent.transform);
            }
        };
    
        /**
         * Retrieves the bounds of the displayObject as a rectangle object.
         *
         * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from
         *  being updated. This means the calculation returned MAY be out of date BUT will give you a
         *  nice performance boost
         * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation
         * @return {PIXI.Rectangle} the rectangular bounding area
         */
    
    
        DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {
            if (!skipUpdate) {
                if (!this.parent) {
                    this.parent = this._tempDisplayObjectParent;
                    this.updateTransform();
                    this.parent = null;
                } else {
                    this._recursivePostUpdateTransform();
                    this.updateTransform();
                }
            }
    
            if (this._boundsID !== this._lastBoundsID) {
                this.calculateBounds();
            }
    
            if (!rect) {
                if (!this._boundsRect) {
                    this._boundsRect = new _math.Rectangle();
                }
    
                rect = this._boundsRect;
            }
    
            return this._bounds.getRectangle(rect);
        };
    
        /**
         * Retrieves the local bounds of the displayObject as a rectangle object
         *
         * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation
         * @return {PIXI.Rectangle} the rectangular bounding area
         */
    
    
        DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {
            var transformRef = this.transform;
            var parentRef = this.parent;
    
            this.parent = null;
            this.transform = this._tempDisplayObjectParent.transform;
    
            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new _math.Rectangle();
                }
    
                rect = this._localBoundsRect;
            }
    
            var bounds = this.getBounds(false, rect);
    
            this.parent = parentRef;
            this.transform = transformRef;
    
            return bounds;
        };
    
        /**
         * Calculates the global position of the display object
         *
         * @param {PIXI.Point} position - The world origin to calculate from
         * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
         *  (otherwise will create a new Point)
         * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
         * @return {PIXI.Point} A point object representing the position of this object
         */
    
    
        DisplayObject.prototype.toGlobal = function toGlobal(position, point) {
            var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    
            if (!skipUpdate) {
                this._recursivePostUpdateTransform();
    
                // this parent check is for just in case the item is a root object.
                // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
                // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
                if (!this.parent) {
                    this.parent = this._tempDisplayObjectParent;
                    this.displayObjectUpdateTransform();
                    this.parent = null;
                } else {
                    this.displayObjectUpdateTransform();
                }
            }
    
            // don't need to update the lot
            return this.worldTransform.apply(position, point);
        };
    
        /**
         * Calculates the local position of the display object relative to another point
         *
         * @param {PIXI.Point} position - The world origin to calculate from
         * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from
         * @param {PIXI.Point} [point] - A Point object in which to store the value, optional
         *  (otherwise will create a new Point)
         * @param {boolean} [skipUpdate=false] - Should we skip the update transform
         * @return {PIXI.Point} A point object representing the position of this object
         */
    
    
        DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {
            if (from) {
                position = from.toGlobal(position, point, skipUpdate);
            }
    
            if (!skipUpdate) {
                this._recursivePostUpdateTransform();
    
                // this parent check is for just in case the item is a root object.
                // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
                // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
                if (!this.parent) {
                    this.parent = this._tempDisplayObjectParent;
                    this.displayObjectUpdateTransform();
                    this.parent = null;
                } else {
                    this.displayObjectUpdateTransform();
                }
            }
    
            // simply apply the matrix..
            return this.worldTransform.applyInverse(position, point);
        };
    
        /**
         * Renders the object using the WebGL renderer
         *
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */
    
    
        DisplayObject.prototype.renderWebGL = function renderWebGL(renderer) // eslint-disable-line no-unused-vars
        {}
        // OVERWRITE;
    
    
        /**
         * Renders the object using the Canvas renderer
         *
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */
        ;
    
        DisplayObject.prototype.renderCanvas = function renderCanvas(renderer) // eslint-disable-line no-unused-vars
        {}
        // OVERWRITE;
    
    
        /**
         * Set the parent Container of this DisplayObject
         *
         * @param {PIXI.Container} container - The Container to add this DisplayObject to
         * @return {PIXI.Container} The Container that this DisplayObject was added to
         */
        ;
    
        DisplayObject.prototype.setParent = function setParent(container) {
            if (!container || !container.addChild) {
                throw new Error('setParent: Argument must be a Container');
            }
    
            container.addChild(this);
    
            return container;
        };
    
        /**
         * Convenience function to set the position, scale, skew and pivot at once.
         *
         * @param {number} [x=0] - The X position
         * @param {number} [y=0] - The Y position
         * @param {number} [scaleX=1] - The X scale value
         * @param {number} [scaleY=1] - The Y scale value
         * @param {number} [rotation=0] - The rotation
         * @param {number} [skewX=0] - The X skew value
         * @param {number} [skewY=0] - The Y skew value
         * @param {number} [pivotX=0] - The X pivot value
         * @param {number} [pivotY=0] - The Y pivot value
         * @return {PIXI.DisplayObject} The DisplayObject instance
         */
    
    
        DisplayObject.prototype.setTransform = function setTransform() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
            var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
            var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
            var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
            var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    
            this.position.x = x;
            this.position.y = y;
            this.scale.x = !scaleX ? 1 : scaleX;
            this.scale.y = !scaleY ? 1 : scaleY;
            this.rotation = rotation;
            this.skew.x = skewX;
            this.skew.y = skewY;
            this.pivot.x = pivotX;
            this.pivot.y = pivotY;
    
            return this;
        };
    
        /**
         * Base destroy method for generic display objects. This will automatically
         * remove the display object from its parent Container as well as remove
         * all current event listeners and internal references. Do not use a DisplayObject
         * after calling `destroy`.
         *
         */
    
    
        DisplayObject.prototype.destroy = function destroy() {
            this.removeAllListeners();
            if (this.parent) {
                this.parent.removeChild(this);
            }
            this.transform = null;
    
            this.parent = null;
    
            this._bounds = null;
            this._currentBounds = null;
            this._mask = null;
    
            this.filterArea = null;
    
            this.interactive = false;
            this.interactiveChildren = false;
    
            this._destroyed = true;
        };
    
        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         * An alias to position.x
         *
         * @member {number}
         */
    
    
        _createClass(DisplayObject, [{
            key: '_tempDisplayObjectParent',
            get: function get() {
                if (this.tempDisplayObjectParent === null) {
                    this.tempDisplayObjectParent = new DisplayObject();
                }
    
                return this.tempDisplayObjectParent;
            }
        }, {
            key: 'x',
            get: function get() {
                return this.position.x;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.transform.position.x = value;
            }
    
            /**
             * The position of the displayObject on the y axis relative to the local coordinates of the parent.
             * An alias to position.y
             *
             * @member {number}
             */
    
        }, {
            key: 'y',
            get: function get() {
                return this.position.y;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.transform.position.y = value;
            }
    
            /**
             * Current transform of the object based on world (parent) factors
             *
             * @member {PIXI.Matrix}
             * @readonly
             */
    
        }, {
            key: 'worldTransform',
            get: function get() {
                return this.transform.worldTransform;
            }
    
            /**
             * Current transform of the object based on local factors: position, scale, other stuff
             *
             * @member {PIXI.Matrix}
             * @readonly
             */
    
        }, {
            key: 'localTransform',
            get: function get() {
                return this.transform.localTransform;
            }
    
            /**
             * The coordinate of the object relative to the local coordinates of the parent.
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.Point|PIXI.ObservablePoint}
             */
    
        }, {
            key: 'position',
            get: function get() {
                return this.transform.position;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.transform.position.copy(value);
            }
    
            /**
             * The scale factor of the object.
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.Point|PIXI.ObservablePoint}
             */
    
        }, {
            key: 'scale',
            get: function get() {
                return this.transform.scale;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.transform.scale.copy(value);
            }
    
            /**
             * The pivot point of the displayObject that it rotates around
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.Point|PIXI.ObservablePoint}
             */
    
        }, {
            key: 'pivot',
            get: function get() {
                return this.transform.pivot;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.transform.pivot.copy(value);
            }
    
            /**
             * The skew factor for the object in radians.
             * Assignment by value since pixi-v4.
             *
             * @member {PIXI.ObservablePoint}
             */
    
        }, {
            key: 'skew',
            get: function get() {
                return this.transform.skew;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.transform.skew.copy(value);
            }
    
            /**
             * The rotation of the object in radians.
             *
             * @member {number}
             */
    
        }, {
            key: 'rotation',
            get: function get() {
                return this.transform.rotation;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.transform.rotation = value;
            }
    
            /**
             * Indicates if the object is globally visible.
             *
             * @member {boolean}
             * @readonly
             */
    
        }, {
            key: 'worldVisible',
            get: function get() {
                var item = this;
    
                do {
                    if (!item.visible) {
                        return false;
                    }
    
                    item = item.parent;
                } while (item);
    
                return true;
            }
    
            /**
             * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
             * object to the shape of the mask applied to it. In PIXI a regular mask must be a
             * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it
             * utilises shape clipping. To remove a mask, set this property to null.
             *
             * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
             *
             * @member {PIXI.Graphics|PIXI.Sprite}
             */
    
        }, {
            key: 'mask',
            get: function get() {
                return this._mask;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                if (this._mask) {
                    this._mask.renderable = true;
                }
    
                this._mask = value;
    
                if (this._mask) {
                    this._mask.renderable = false;
                }
            }
    
            /**
             * Sets the filters for the displayObject.
             * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.
             * To remove filters simply set this property to 'null'
             *
             * @member {PIXI.Filter[]}
             */
    
        }, {
            key: 'filters',
            get: function get() {
                return this._filters && this._filters.slice();
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this._filters = value && value.slice();
            }
        }]);
    
        return DisplayObject;
    }(_eventemitter2.default);
    
    // performance increase to avoid using call.. (10x faster)
    
    
    exports.default = DisplayObject;
    DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
    
    /***/ }),
    /* 45 */
    /***/ (function(module, exports, __webpack_require__) {
    
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
     * isMobile.js v0.4.1
     *
     * A simple library to detect Apple phones and tablets,
     * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
     * and any kind of seven inch device, via user agent sniffing.
     *
     * @author: Kai Mallea (kmallea@gmail.com)
     *
     * @license: http://creativecommons.org/publicdomain/zero/1.0/
     */
    (function (global) {
    
        var apple_phone         = /iPhone/i,
            apple_ipod          = /iPod/i,
            apple_tablet        = /iPad/i,
            android_phone       = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i, // Match 'Android' AND 'Mobile'
            android_tablet      = /Android/i,
            amazon_phone        = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
            amazon_tablet       = /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
            windows_phone       = /Windows Phone/i,
            windows_tablet      = /(?=.*\bWindows\b)(?=.*\bARM\b)/i, // Match 'Windows' AND 'ARM'
            other_blackberry    = /BlackBerry/i,
            other_blackberry_10 = /BB10/i,
            other_opera         = /Opera Mini/i,
            other_chrome        = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
            other_firefox       = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i, // Match 'Firefox' AND 'Mobile'
            seven_inch = new RegExp(
                '(?:' +         // Non-capturing group
    
                'Nexus 7' +     // Nexus 7
    
                '|' +           // OR
    
                'BNTV250' +     // B&N Nook Tablet 7 inch
    
                '|' +           // OR
    
                'Kindle Fire' + // Kindle Fire
    
                '|' +           // OR
    
                'Silk' +        // Kindle Fire, Silk Accelerated
    
                '|' +           // OR
    
                'GT-P1000' +    // Galaxy Tab 7 inch
    
                ')',            // End non-capturing group
    
                'i');           // Case-insensitive matching
    
        var match = function(regex, userAgent) {
            return regex.test(userAgent);
        };
    
        var IsMobileClass = function(userAgent) {
            var ua = userAgent || navigator.userAgent;
    
            // Facebook mobile app's integrated browser adds a bunch of strings that
            // match everything. Strip it out if it exists.
            var tmp = ua.split('[FBAN');
            if (typeof tmp[1] !== 'undefined') {
                ua = tmp[0];
            }
    
            // Twitter mobile app's integrated browser on iPad adds a "Twitter for
            // iPhone" string. Same probable happens on other tablet platforms.
            // This will confuse detection so strip it out if it exists.
            tmp = ua.split('Twitter');
            if (typeof tmp[1] !== 'undefined') {
                ua = tmp[0];
            }
    
            this.apple = {
                phone:  match(apple_phone, ua),
                ipod:   match(apple_ipod, ua),
                tablet: !match(apple_phone, ua) && match(apple_tablet, ua),
                device: match(apple_phone, ua) || match(apple_ipod, ua) || match(apple_tablet, ua)
            };
            this.amazon = {
                phone:  match(amazon_phone, ua),
                tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua),
                device: match(amazon_phone, ua) || match(amazon_tablet, ua)
            };
            this.android = {
                phone:  match(amazon_phone, ua) || match(android_phone, ua),
                tablet: !match(amazon_phone, ua) && !match(android_phone, ua) && (match(amazon_tablet, ua) || match(android_tablet, ua)),
                device: match(amazon_phone, ua) || match(amazon_tablet, ua) || match(android_phone, ua) || match(android_tablet, ua)
            };
            this.windows = {
                phone:  match(windows_phone, ua),
                tablet: match(windows_tablet, ua),
                device: match(windows_phone, ua) || match(windows_tablet, ua)
            };
            this.other = {
                blackberry:   match(other_blackberry, ua),
                blackberry10: match(other_blackberry_10, ua),
                opera:        match(other_opera, ua),
                firefox:      match(other_firefox, ua),
                chrome:       match(other_chrome, ua),
                device:       match(other_blackberry, ua) || match(other_blackberry_10, ua) || match(other_opera, ua) || match(other_firefox, ua) || match(other_chrome, ua)
            };
            this.seven_inch = match(seven_inch, ua);
            this.any = this.apple.device || this.android.device || this.windows.device || this.other.device || this.seven_inch;
    
            // excludes 'other' devices and ipods, targeting touchscreen phones
            this.phone = this.apple.phone || this.android.phone || this.windows.phone;
    
            // excludes 7 inch devices, classifying as phone or tablet is left to the user
            this.tablet = this.apple.tablet || this.android.tablet || this.windows.tablet;
    
            if (typeof window === 'undefined') {
                return this;
            }
        };
    
        var instantiate = function() {
            var IM = new IsMobileClass();
            IM.Class = IsMobileClass;
            return IM;
        };
    
        if (typeof module !== 'undefined' && module.exports && typeof window === 'undefined') {
            //node
            module.exports = IsMobileClass;
        } else if (typeof module !== 'undefined' && module.exports && typeof window !== 'undefined') {
            //browserify
            module.exports = instantiate();
        } else if (true) {
            //AMD
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (global.isMobile = instantiate()),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                    (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
            global.isMobile = instantiate();
        }
    
    })(this);
    
    
    /***/ }),
    /* 46 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _math = __webpack_require__(2);
    
    var _TransformBase2 = __webpack_require__(26);
    
    var _TransformBase3 = _interopRequireDefault(_TransformBase2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * Transform that takes care about its versions
     *
     * @class
     * @extends PIXI.TransformBase
     * @memberof PIXI
     */
    var TransformStatic = function (_TransformBase) {
        _inherits(TransformStatic, _TransformBase);
    
        /**
         *
         */
        function TransformStatic() {
            _classCallCheck(this, TransformStatic);
    
            /**
            * The coordinate of the object relative to the local coordinates of the parent.
            *
            * @member {PIXI.ObservablePoint}
            */
            var _this = _possibleConstructorReturn(this, _TransformBase.call(this));
    
            _this.position = new _math.ObservablePoint(_this.onChange, _this, 0, 0);
    
            /**
             * The scale factor of the object.
             *
             * @member {PIXI.ObservablePoint}
             */
            _this.scale = new _math.ObservablePoint(_this.onChange, _this, 1, 1);
    
            /**
             * The pivot point of the displayObject that it rotates around
             *
             * @member {PIXI.ObservablePoint}
             */
            _this.pivot = new _math.ObservablePoint(_this.onChange, _this, 0, 0);
    
            /**
             * The skew amount, on the x and y axis.
             *
             * @member {PIXI.ObservablePoint}
             */
            _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);
    
            _this._rotation = 0;
    
            _this._cx = 1; // cos rotation + skewY;
            _this._sx = 0; // sin rotation + skewY;
            _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
            _this._sy = 1; // sin rotation + Math.PI/2 - skewX;
    
            _this._localID = 0;
            _this._currentLocalID = 0;
            return _this;
        }
    
        /**
         * Called when a value changes.
         *
         * @private
         */
    
    
        TransformStatic.prototype.onChange = function onChange() {
            this._localID++;
        };
    
        /**
         * Called when skew or rotation changes
         *
         * @private
         */
    
    
        TransformStatic.prototype.updateSkew = function updateSkew() {
            this._cx = Math.cos(this._rotation + this.skew._y);
            this._sx = Math.sin(this._rotation + this.skew._y);
            this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
            this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
    
            this._localID++;
        };
    
        /**
         * Updates only local matrix
         */
    
    
        TransformStatic.prototype.updateLocalTransform = function updateLocalTransform() {
            var lt = this.localTransform;
    
            if (this._localID !== this._currentLocalID) {
                // get the matrix values of the displayobject based on its transform properties..
                lt.a = this._cx * this.scale._x;
                lt.b = this._sx * this.scale._x;
                lt.c = this._cy * this.scale._y;
                lt.d = this._sy * this.scale._y;
    
                lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
                lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
                this._currentLocalID = this._localID;
    
                // force an update..
                this._parentID = -1;
            }
        };
    
        /**
         * Updates the values of the object and applies the parent's transform.
         *
         * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
         */
    
    
        TransformStatic.prototype.updateTransform = function updateTransform(parentTransform) {
            var lt = this.localTransform;
    
            if (this._localID !== this._currentLocalID) {
                // get the matrix values of the displayobject based on its transform properties..
                lt.a = this._cx * this.scale._x;
                lt.b = this._sx * this.scale._x;
                lt.c = this._cy * this.scale._y;
                lt.d = this._sy * this.scale._y;
    
                lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
                lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
                this._currentLocalID = this._localID;
    
                // force an update..
                this._parentID = -1;
            }
    
            if (this._parentID !== parentTransform._worldID) {
                // concat the parent matrix with the objects transform.
                var pt = parentTransform.worldTransform;
                var wt = this.worldTransform;
    
                wt.a = lt.a * pt.a + lt.b * pt.c;
                wt.b = lt.a * pt.b + lt.b * pt.d;
                wt.c = lt.c * pt.a + lt.d * pt.c;
                wt.d = lt.c * pt.b + lt.d * pt.d;
                wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
                wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
    
                this._parentID = parentTransform._worldID;
    
                // update the id of the transform..
                this._worldID++;
            }
        };
    
        /**
         * Decomposes a matrix and sets the transforms properties based on it.
         *
         * @param {PIXI.Matrix} matrix - The matrix to decompose
         */
    
    
        TransformStatic.prototype.setFromMatrix = function setFromMatrix(matrix) {
            matrix.decompose(this);
            this._localID++;
        };
    
        /**
         * The rotation of the object in radians.
         *
         * @member {number}
         */
    
    
        _createClass(TransformStatic, [{
            key: 'rotation',
            get: function get() {
                return this._rotation;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this._rotation = value;
                this.updateSkew();
            }
        }]);
    
        return TransformStatic;
    }(_TransformBase3.default);
    
    exports.default = TransformStatic;
    
    /***/ }),
    /* 47 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _math = __webpack_require__(2);
    
    var _TransformBase2 = __webpack_require__(26);
    
    var _TransformBase3 = _interopRequireDefault(_TransformBase2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * Generic class to deal with traditional 2D matrix transforms
     * local transformation is calculated from position,scale,skew and rotation
     *
     * @class
     * @extends PIXI.TransformBase
     * @memberof PIXI
     */
    var Transform = function (_TransformBase) {
      _inherits(Transform, _TransformBase);
    
      /**
       *
       */
      function Transform() {
        _classCallCheck(this, Transform);
    
        /**
        * The coordinate of the object relative to the local coordinates of the parent.
        *
        * @member {PIXI.Point}
        */
        var _this = _possibleConstructorReturn(this, _TransformBase.call(this));
    
        _this.position = new _math.Point(0, 0);
    
        /**
         * The scale factor of the object.
         *
         * @member {PIXI.Point}
         */
        _this.scale = new _math.Point(1, 1);
    
        /**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */
        _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);
    
        /**
         * The pivot point of the displayObject that it rotates around
         *
         * @member {PIXI.Point}
         */
        _this.pivot = new _math.Point(0, 0);
    
        /**
         * The rotation value of the object, in radians
         *
         * @member {Number}
         * @private
         */
        _this._rotation = 0;
    
        _this._cx = 1; // cos rotation + skewY;
        _this._sx = 0; // sin rotation + skewY;
        _this._cy = 0; // cos rotation + Math.PI/2 - skewX;
        _this._sy = 1; // sin rotation + Math.PI/2 - skewX;
        return _this;
      }
    
      /**
       * Updates the skew values when the skew or rotation changes.
       *
       * @private
       */
    
    
      Transform.prototype.updateSkew = function updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew._y);
        this._sx = Math.sin(this._rotation + this.skew._y);
        this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
        this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
      };
    
      /**
       * Updates only local matrix
       */
    
    
      Transform.prototype.updateLocalTransform = function updateLocalTransform() {
        var lt = this.localTransform;
    
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
    
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      };
    
      /**
       * Updates the values of the object and applies the parent's transform.
       *
       * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
       */
    
    
      Transform.prototype.updateTransform = function updateTransform(parentTransform) {
        var lt = this.localTransform;
    
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
    
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
    
        // concat the parent matrix with the objects transform.
        var pt = parentTransform.worldTransform;
        var wt = this.worldTransform;
    
        wt.a = lt.a * pt.a + lt.b * pt.c;
        wt.b = lt.a * pt.b + lt.b * pt.d;
        wt.c = lt.c * pt.a + lt.d * pt.c;
        wt.d = lt.c * pt.b + lt.d * pt.d;
        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
    
        this._worldID++;
      };
    
      /**
       * Decomposes a matrix and sets the transforms properties based on it.
       *
       * @param {PIXI.Matrix} matrix - The matrix to decompose
       */
    
    
      Transform.prototype.setFromMatrix = function setFromMatrix(matrix) {
        matrix.decompose(this);
      };
    
      /**
       * The rotation of the object in radians.
       *
       * @member {number}
       */
    
    
      _createClass(Transform, [{
        key: 'rotation',
        get: function get() {
          return this._rotation;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
          this._rotation = value;
          this.updateSkew();
        }
      }]);
    
      return Transform;
    }(_TransformBase3.default);
    
    exports.default = Transform;
    
    /***/ }),
    /* 48 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _math = __webpack_require__(2);
    
    var _utils = __webpack_require__(1);
    
    var _const = __webpack_require__(0);
    
    var _Texture = __webpack_require__(8);
    
    var _Texture2 = _interopRequireDefault(_Texture);
    
    var _Container2 = __webpack_require__(7);
    
    var _Container3 = _interopRequireDefault(_Container2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var tempPoint = new _math.Point();
    
    /**
     * The Sprite object is the base for all textured objects that are rendered to the screen
     *
     * A sprite can be created directly from an image like this:
     *
     * ```js
     * let sprite = new PIXI.Sprite.fromImage('assets/image.png');
     * ```
     *
     * @class
     * @extends PIXI.Container
     * @memberof PIXI
     */
    
    var Sprite = function (_Container) {
        _inherits(Sprite, _Container);
    
        /**
         * @param {PIXI.Texture} texture - The texture for this sprite
         */
        function Sprite(texture) {
            _classCallCheck(this, Sprite);
    
            /**
             * The anchor sets the origin point of the texture.
             * The default is 0,0 this means the texture's origin is the top left
             * Setting the anchor to 0.5,0.5 means the texture's origin is centered
             * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
             *
             * @member {PIXI.ObservablePoint}
             * @private
             */
            var _this = _possibleConstructorReturn(this, _Container.call(this));
    
            _this._anchor = new _math.ObservablePoint(_this._onAnchorUpdate, _this);
    
            /**
             * The texture that the sprite is using
             *
             * @private
             * @member {PIXI.Texture}
             */
            _this._texture = null;
    
            /**
             * The width of the sprite (this is initially set by the texture)
             *
             * @private
             * @member {number}
             */
            _this._width = 0;
    
            /**
             * The height of the sprite (this is initially set by the texture)
             *
             * @private
             * @member {number}
             */
            _this._height = 0;
    
            /**
             * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
             *
             * @private
             * @member {number}
             * @default 0xFFFFFF
             */
            _this._tint = null;
            _this._tintRGB = null;
            _this.tint = 0xFFFFFF;
    
            /**
             * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
             *
             * @member {number}
             * @default PIXI.BLEND_MODES.NORMAL
             * @see PIXI.BLEND_MODES
             */
            _this.blendMode = _const.BLEND_MODES.NORMAL;
    
            /**
             * The shader that will be used to render the sprite. Set to null to remove a current shader.
             *
             * @member {PIXI.Filter|PIXI.Shader}
             */
            _this.shader = null;
    
            /**
             * An internal cached value of the tint.
             *
             * @private
             * @member {number}
             * @default 0xFFFFFF
             */
            _this.cachedTint = 0xFFFFFF;
    
            // call texture setter
            _this.texture = texture || _Texture2.default.EMPTY;
    
            /**
             * this is used to store the vertex data of the sprite (basically a quad)
             *
             * @private
             * @member {Float32Array}
             */
            _this.vertexData = new Float32Array(8);
    
            /**
             * This is used to calculate the bounds of the object IF it is a trimmed sprite
             *
             * @private
             * @member {Float32Array}
             */
            _this.vertexTrimmedData = null;
    
            _this._transformID = -1;
            _this._textureID = -1;
    
            _this._transformTrimmedID = -1;
            _this._textureTrimmedID = -1;
    
            /**
             * Plugin that is responsible for rendering this element.
             * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.
             *
             * @member {string}
             * @default 'sprite'
             */
            _this.pluginName = 'sprite';
            return _this;
        }
    
        /**
         * When the texture is updated, this event will fire to update the scale and frame
         *
         * @private
         */
    
    
        Sprite.prototype._onTextureUpdate = function _onTextureUpdate() {
            this._textureID = -1;
            this._textureTrimmedID = -1;
    
            // so if _width is 0 then width was not set..
            if (this._width) {
                this.scale.x = (0, _utils.sign)(this.scale.x) * this._width / this._texture.orig.width;
            }
    
            if (this._height) {
                this.scale.y = (0, _utils.sign)(this.scale.y) * this._height / this._texture.orig.height;
            }
        };
    
        /**
         * Called when the anchor position updates.
         *
         * @private
         */
    
    
        Sprite.prototype._onAnchorUpdate = function _onAnchorUpdate() {
            this._transformID = -1;
            this._transformTrimmedID = -1;
        };
    
        /**
         * calculates worldTransform * vertices, store it in vertexData
         */
    
    
        Sprite.prototype.calculateVertices = function calculateVertices() {
            if (this._transformID === this.transform._worldID && this._textureID === this._texture._updateID) {
                return;
            }
    
            this._transformID = this.transform._worldID;
            this._textureID = this._texture._updateID;
    
            // set the vertex data
    
            var texture = this._texture;
            var wt = this.transform.worldTransform;
            var a = wt.a;
            var b = wt.b;
            var c = wt.c;
            var d = wt.d;
            var tx = wt.tx;
            var ty = wt.ty;
            var vertexData = this.vertexData;
            var trim = texture.trim;
            var orig = texture.orig;
            var anchor = this._anchor;
    
            var w0 = 0;
            var w1 = 0;
            var h0 = 0;
            var h1 = 0;
    
            if (trim) {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
                // space before transforming the sprite coords.
                w1 = trim.x - anchor._x * orig.width;
                w0 = w1 + trim.width;
    
                h1 = trim.y - anchor._y * orig.height;
                h0 = h1 + trim.height;
            } else {
                w1 = -anchor._x * orig.width;
                w0 = w1 + orig.width;
    
                h1 = -anchor._y * orig.height;
                h0 = h1 + orig.height;
            }
    
            // xy
            vertexData[0] = a * w1 + c * h1 + tx;
            vertexData[1] = d * h1 + b * w1 + ty;
    
            // xy
            vertexData[2] = a * w0 + c * h1 + tx;
            vertexData[3] = d * h1 + b * w0 + ty;
    
            // xy
            vertexData[4] = a * w0 + c * h0 + tx;
            vertexData[5] = d * h0 + b * w0 + ty;
    
            // xy
            vertexData[6] = a * w1 + c * h0 + tx;
            vertexData[7] = d * h0 + b * w1 + ty;
        };
    
        /**
         * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
         * This is used to ensure that the true width and height of a trimmed texture is respected
         */
    
    
        Sprite.prototype.calculateTrimmedVertices = function calculateTrimmedVertices() {
            if (!this.vertexTrimmedData) {
                this.vertexTrimmedData = new Float32Array(8);
            } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
                return;
            }
    
            this._transformTrimmedID = this.transform._worldID;
            this._textureTrimmedID = this._texture._updateID;
    
            // lets do some special trim code!
            var texture = this._texture;
            var vertexData = this.vertexTrimmedData;
            var orig = texture.orig;
            var anchor = this._anchor;
    
            // lets calculate the new untrimmed bounds..
            var wt = this.transform.worldTransform;
            var a = wt.a;
            var b = wt.b;
            var c = wt.c;
            var d = wt.d;
            var tx = wt.tx;
            var ty = wt.ty;
    
            var w1 = -anchor._x * orig.width;
            var w0 = w1 + orig.width;
    
            var h1 = -anchor._y * orig.height;
            var h0 = h1 + orig.height;
    
            // xy
            vertexData[0] = a * w1 + c * h1 + tx;
            vertexData[1] = d * h1 + b * w1 + ty;
    
            // xy
            vertexData[2] = a * w0 + c * h1 + tx;
            vertexData[3] = d * h1 + b * w0 + ty;
    
            // xy
            vertexData[4] = a * w0 + c * h0 + tx;
            vertexData[5] = d * h0 + b * w0 + ty;
    
            // xy
            vertexData[6] = a * w1 + c * h0 + tx;
            vertexData[7] = d * h0 + b * w1 + ty;
        };
    
        /**
        *
        * Renders the object using the WebGL renderer
        *
        * @private
        * @param {PIXI.WebGLRenderer} renderer - The webgl renderer to use.
        */
    
    
        Sprite.prototype._renderWebGL = function _renderWebGL(renderer) {
            this.calculateVertices();
    
            renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
            renderer.plugins[this.pluginName].render(this);
        };
    
        /**
        * Renders the object using the Canvas renderer
        *
        * @private
        * @param {PIXI.CanvasRenderer} renderer - The renderer
        */
    
    
        Sprite.prototype._renderCanvas = function _renderCanvas(renderer) {
            renderer.plugins[this.pluginName].render(this);
        };
    
        /**
         * Updates the bounds of the sprite.
         *
         * @private
         */
    
    
        Sprite.prototype._calculateBounds = function _calculateBounds() {
            var trim = this._texture.trim;
            var orig = this._texture.orig;
    
            // First lets check to see if the current texture has a trim..
            if (!trim || trim.width === orig.width && trim.height === orig.height) {
                // no trim! lets use the usual calculations..
                this.calculateVertices();
                this._bounds.addQuad(this.vertexData);
            } else {
                // lets calculate a special trimmed bounds...
                this.calculateTrimmedVertices();
                this._bounds.addQuad(this.vertexTrimmedData);
            }
        };
    
        /**
         * Gets the local bounds of the sprite object.
         *
         * @param {PIXI.Rectangle} rect - The output rectangle.
         * @return {PIXI.Rectangle} The bounds.
         */
    
    
        Sprite.prototype.getLocalBounds = function getLocalBounds(rect) {
            // we can do a fast local bounds if the sprite has no children!
            if (this.children.length === 0) {
                this._bounds.minX = this._texture.orig.width * -this._anchor._x;
                this._bounds.minY = this._texture.orig.height * -this._anchor._y;
                this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
                this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._x);
    
                if (!rect) {
                    if (!this._localBoundsRect) {
                        this._localBoundsRect = new _math.Rectangle();
                    }
    
                    rect = this._localBoundsRect;
                }
    
                return this._bounds.getRectangle(rect);
            }
    
            return _Container.prototype.getLocalBounds.call(this, rect);
        };
    
        /**
         * Tests if a point is inside this sprite
         *
         * @param {PIXI.Point} point - the point to test
         * @return {boolean} the result of the test
         */
    
    
        Sprite.prototype.containsPoint = function containsPoint(point) {
            this.worldTransform.applyInverse(point, tempPoint);
    
            var width = this._texture.orig.width;
            var height = this._texture.orig.height;
            var x1 = -width * this.anchor.x;
            var y1 = 0;
    
            if (tempPoint.x > x1 && tempPoint.x < x1 + width) {
                y1 = -height * this.anchor.y;
    
                if (tempPoint.y > y1 && tempPoint.y < y1 + height) {
                    return true;
                }
            }
    
            return false;
        };
    
        /**
         * Destroys this sprite and optionally its texture and children
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
         *  have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
         *      method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
         * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
         */
    
    
        Sprite.prototype.destroy = function destroy(options) {
            _Container.prototype.destroy.call(this, options);
    
            this._anchor = null;
    
            var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;
    
            if (destroyTexture) {
                var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;
    
                this._texture.destroy(!!destroyBaseTexture);
            }
    
            this._texture = null;
            this.shader = null;
        };
    
        // some helper functions..
    
        /**
         * Helper function that creates a new sprite based on the source you provide.
         * The source can be - frame id, image url, video url, canvas element, video element, base texture
         *
         * @static
         * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
         * @return {PIXI.Sprite} The newly created sprite
         */
    
    
        Sprite.from = function from(source) {
            return new Sprite(_Texture2.default.from(source));
        };
    
        /**
         * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId
         * The frame ids are created when a Texture packer file has been loaded
         *
         * @static
         * @param {string} frameId - The frame Id of the texture in the cache
         * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the frameId
         */
    
    
        Sprite.fromFrame = function fromFrame(frameId) {
            var texture = _utils.TextureCache[frameId];
    
            if (!texture) {
                throw new Error('The frameId "' + frameId + '" does not exist in the texture cache');
            }
    
            return new Sprite(texture);
        };
    
        /**
         * Helper function that creates a sprite that will contain a texture based on an image url
         * If the image is not in the texture cache it will be loaded
         *
         * @static
         * @param {string} imageId - The image url of the texture
         * @param {boolean} [crossorigin=(auto)] - if you want to specify the cross-origin parameter
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,
         *  see {@link PIXI.SCALE_MODES} for possible values
         * @return {PIXI.Sprite} A new Sprite using a texture from the texture cache matching the image id
         */
    
    
        Sprite.fromImage = function fromImage(imageId, crossorigin, scaleMode) {
            return new Sprite(_Texture2.default.fromImage(imageId, crossorigin, scaleMode));
        };
    
        /**
         * The width of the sprite, setting this will actually modify the scale to achieve the value set
         *
         * @member {number}
         */
    
    
        _createClass(Sprite, [{
            key: 'width',
            get: function get() {
                return Math.abs(this.scale.x) * this._texture.orig.width;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                var s = (0, _utils.sign)(this.scale.x) || 1;
    
                this.scale.x = s * value / this._texture.orig.width;
                this._width = value;
            }
    
            /**
             * The height of the sprite, setting this will actually modify the scale to achieve the value set
             *
             * @member {number}
             */
    
        }, {
            key: 'height',
            get: function get() {
                return Math.abs(this.scale.y) * this._texture.orig.height;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                var s = (0, _utils.sign)(this.scale.y) || 1;
    
                this.scale.y = s * value / this._texture.orig.height;
                this._height = value;
            }
    
            /**
             * The anchor sets the origin point of the texture.
             * The default is 0,0 this means the texture's origin is the top left
             * Setting the anchor to 0.5,0.5 means the texture's origin is centered
             * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner
             *
             * @member {PIXI.ObservablePoint}
             */
    
        }, {
            key: 'anchor',
            get: function get() {
                return this._anchor;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this._anchor.copy(value);
            }
    
            /**
             * The tint applied to the sprite. This is a hex value.
             * A value of 0xFFFFFF will remove any tint effect.
             *
             * @member {number}
             * @default 0xFFFFFF
             */
    
        }, {
            key: 'tint',
            get: function get() {
                return this._tint;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this._tint = value;
                this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
            }
    
            /**
             * The texture that the sprite is using
             *
             * @member {PIXI.Texture}
             */
    
        }, {
            key: 'texture',
            get: function get() {
                return this._texture;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                if (this._texture === value) {
                    return;
                }
    
                this._texture = value;
                this.cachedTint = 0xFFFFFF;
    
                this._textureID = -1;
                this._textureTrimmedID = -1;
    
                if (value) {
                    // wait for the texture to load
                    if (value.baseTexture.hasLoaded) {
                        this._onTextureUpdate();
                    } else {
                        value.once('update', this._onTextureUpdate, this);
                    }
                }
            }
        }]);
    
        return Sprite;
    }(_Container3.default);
    
    exports.default = Sprite;
    
    /***/ }),
    /* 49 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    
    var punycode = __webpack_require__(107);
    var util = __webpack_require__(109);
    
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    
    exports.Url = Url;
    
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    
    // Reference: RFC 3986, RFC 1808, RFC 2396
    
    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,
    
        // Special case for a simple path URL
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    
        // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    
        // RFC 2396: characters not allowed for various reasons.
        unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    
        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = ['\''].concat(unwise),
        // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
        hostEndingChars = ['/', '?', '#'],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
        unsafeProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that never have a hostname.
        hostlessProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that always contain a // bit.
        slashedProtocol = {
          'http': true,
          'https': true,
          'ftp': true,
          'gopher': true,
          'file': true,
          'http:': true,
          'https:': true,
          'ftp:': true,
          'gopher:': true,
          'file:': true
        },
        querystring = __webpack_require__(110);
    
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url) return url;
    
      var u = new Url;
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
    
      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
          splitter =
              (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
          uSplit = url.split(splitter),
          slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);
    
      var rest = url;
    
      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();
    
      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          return this;
        }
      }
    
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
    
      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
    
      if (!hostlessProtocol[proto] &&
          (slashes || (proto && !slashedProtocol[proto]))) {
    
        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c
    
        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.
    
        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
    
        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }
    
        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
    
        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1)
          hostEnd = rest.length;
    
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
    
        // pull out port.
        this.parseHost();
    
        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';
    
        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' &&
            this.hostname[this.hostname.length - 1] === ']';
    
        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }
    
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        } else {
          // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase();
        }
    
        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          this.hostname = punycode.toASCII(this.hostname);
        }
    
        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;
    
        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }
    
      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {
    
        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
    
    
      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
      }
      if (rest) this.pathname = rest;
      if (slashedProtocol[lowerProto] &&
          this.hostname && !this.pathname) {
        this.pathname = '/';
      }
    
      //to support http.request
      if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
      }
    
      // finally, reconstruct the href based on what has been validated.
      this.href = this.format();
      return this;
    };
    
    // format a parsed object into a url string
    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (util.isString(obj)) obj = urlParse(obj);
      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
      return obj.format();
    }
    
    Url.prototype.format = function() {
      var auth = this.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }
    
      var protocol = this.protocol || '',
          pathname = this.pathname || '',
          hash = this.hash || '',
          host = false,
          query = '';
    
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ?
            this.hostname :
            '[' + this.hostname + ']');
        if (this.port) {
          host += ':' + this.port;
        }
      }
    
      if (this.query &&
          util.isObject(this.query) &&
          Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
    
      var search = this.search || (query && ('?' + query)) || '';
    
      if (protocol && protocol.substr(-1) !== ':') protocol += ':';
    
      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (this.slashes ||
          (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }
    
      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;
    
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');
    
      return protocol + host + pathname + search + hash;
    };
    
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    
    function urlResolveObject(source, relative) {
      if (!source) return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
    
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
    
      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;
    
      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }
    
      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
        }
    
        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] &&
            result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }
    
        result.href = result.format();
        return result;
      }
    
      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
    
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
    
      var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
          isRelAbs = (
              relative.host ||
              relative.pathname && relative.pathname.charAt(0) === '/'
          ),
          mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname)),
          removeAllDots = mustEndAbs,
          srcPath = result.pathname && result.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol];
    
      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;
          else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;
            else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }
    
      if (isRelAbs) {
        // it's absolute.
        result.host = (relative.host || relative.host === '') ?
                      relative.host : result.host;
        result.hostname = (relative.hostname || relative.hostname === '') ?
                          relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ?
                           result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }
    
      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
    
      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (
          (result.host || relative.host || srcPath.length > 1) &&
          (last === '.' || last === '..') || last === '');
    
      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
    
      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }
    
      if (mustEndAbs && srcPath[0] !== '' &&
          (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }
    
      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('');
      }
    
      var isAbsolute = srcPath[0] === '' ||
          (srcPath[0] && srcPath[0].charAt(0) === '/');
    
      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' :
                                        srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                         result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
    
      mustEndAbs = mustEndAbs || (result.host && srcPath.length);
    
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }
    
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }
    
      //to support request.http
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
                      (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) this.hostname = host;
    };
    
    
    /***/ }),
    /* 50 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _BaseTexture2 = __webpack_require__(9);
    
    var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);
    
    var _utils = __webpack_require__(1);
    
    var _ticker = __webpack_require__(28);
    
    var _const = __webpack_require__(0);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * A texture of a [playing] Video.
     *
     * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.
     *
     * This can be used in several ways, such as:
     *
     * ```js
     * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');
     *
     * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });
     *
     * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);
     *
     * let texture = PIXI.VideoBaseTexture.fromUrls([
     *     { src: '/video.webm', mime: 'video/webm' },
     *     { src: '/video.mp4', mime: 'video/mp4' }
     * ]);
     * ```
     *
     * See the ["deus" demo](http://www.goodboydigital.com/pixijs/examples/deus/).
     *
     * @class
     * @extends PIXI.BaseTexture
     * @memberof PIXI
     */
    var VideoBaseTexture = function (_BaseTexture) {
        _inherits(VideoBaseTexture, _BaseTexture);
    
        /**
         * @param {HTMLVideoElement} source - Video source
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         */
        function VideoBaseTexture(source, scaleMode) {
            _classCallCheck(this, VideoBaseTexture);
    
            if (!source) {
                throw new Error('No video source element specified.');
            }
    
            // hook in here to check if video is already available.
            // BaseTexture looks for a source.complete boolean, plus width & height.
    
            if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
                source.complete = true;
            }
    
            var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));
    
            _this.width = source.videoWidth;
            _this.height = source.videoHeight;
    
            _this._autoUpdate = true;
            _this._isAutoUpdating = false;
    
            /**
             * When set to true will automatically play videos used by this texture once
             * they are loaded. If false, it will not modify the playing state.
             *
             * @member {boolean}
             * @default true
             */
            _this.autoPlay = true;
    
            _this.update = _this.update.bind(_this);
            _this._onCanPlay = _this._onCanPlay.bind(_this);
    
            source.addEventListener('play', _this._onPlayStart.bind(_this));
            source.addEventListener('pause', _this._onPlayStop.bind(_this));
            _this.hasLoaded = false;
            _this.__loaded = false;
    
            if (!_this._isSourceReady()) {
                source.addEventListener('canplay', _this._onCanPlay);
                source.addEventListener('canplaythrough', _this._onCanPlay);
            } else {
                _this._onCanPlay();
            }
            return _this;
        }
    
        /**
         * Returns true if the underlying source is playing.
         *
         * @private
         * @return {boolean} True if playing.
         */
    
    
        VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() {
            var source = this.source;
    
            return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
        };
    
        /**
         * Returns true if the underlying source is ready for playing.
         *
         * @private
         * @return {boolean} True if ready.
         */
    
    
        VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() {
            return this.source.readyState === 3 || this.source.readyState === 4;
        };
    
        /**
         * Runs the update loop when the video is ready to play
         *
         * @private
         */
    
    
        VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {
            // Just in case the video has not received its can play even yet..
            if (!this.hasLoaded) {
                this._onCanPlay();
            }
    
            if (!this._isAutoUpdating && this.autoUpdate) {
                _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
                this._isAutoUpdating = true;
            }
        };
    
        /**
         * Fired when a pause event is triggered, stops the update loop
         *
         * @private
         */
    
    
        VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() {
            if (this._isAutoUpdating) {
                _ticker.shared.remove(this.update, this);
                this._isAutoUpdating = false;
            }
        };
    
        /**
         * Fired when the video is loaded and ready to play
         *
         * @private
         */
    
    
        VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {
            this.hasLoaded = true;
    
            if (this.source) {
                this.source.removeEventListener('canplay', this._onCanPlay);
                this.source.removeEventListener('canplaythrough', this._onCanPlay);
    
                this.width = this.source.videoWidth;
                this.height = this.source.videoHeight;
    
                // prevent multiple loaded dispatches..
                if (!this.__loaded) {
                    this.__loaded = true;
                    this.emit('loaded', this);
                }
    
                if (this._isSourcePlaying()) {
                    this._onPlayStart();
                } else if (this.autoPlay) {
                    this.source.play();
                }
            }
        };
    
        /**
         * Destroys this texture
         *
         */
    
    
        VideoBaseTexture.prototype.destroy = function destroy() {
            if (this._isAutoUpdating) {
                _ticker.shared.remove(this.update, this);
            }
    
            if (this.source && this.source._pixiId) {
                _BaseTexture3.default.removeFromCache(this.source._pixiId);
                delete this.source._pixiId;
            }
    
            _BaseTexture.prototype.destroy.call(this);
        };
    
        /**
         * Mimic Pixi BaseTexture.from.... method.
         *
         * @static
         * @param {HTMLVideoElement} video - Video to create texture from
         * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
         * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
         */
    
    
        VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode) {
            if (!video._pixiId) {
                video._pixiId = 'video_' + (0, _utils.uid)();
            }
    
            var baseTexture = _utils.BaseTextureCache[video._pixiId];
    
            if (!baseTexture) {
                baseTexture = new VideoBaseTexture(video, scaleMode);
                _BaseTexture3.default.addToCache(baseTexture, video._pixiId);
            }
    
            return baseTexture;
        };
    
        /**
         * Helper function that creates a new BaseTexture based on the given video element.
         * This BaseTexture can then be used to create a texture
         *
         * @static
         * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.
         * @param {string} [videoSrc.src] - One of the source urls for the video
         * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified
         *  the url's extension will be used as the second part of the mime type.
         * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values
         * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture
         */
    
    
        VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode) {
            var video = document.createElement('video');
    
            video.setAttribute('webkit-playsinline', '');
            video.setAttribute('playsinline', '');
    
            // array of objects or strings
            if (Array.isArray(videoSrc)) {
                for (var i = 0; i < videoSrc.length; ++i) {
                    video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));
                }
            }
            // single object or string
            else {
                    video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));
                }
    
            video.load();
    
            return VideoBaseTexture.fromVideo(video, scaleMode);
        };
    
        /**
         * Should the base texture automatically update itself, set to true by default
         *
         * @member {boolean}
         */
    
    
        _createClass(VideoBaseTexture, [{
            key: 'autoUpdate',
            get: function get() {
                return this._autoUpdate;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                if (value !== this._autoUpdate) {
                    this._autoUpdate = value;
    
                    if (!this._autoUpdate && this._isAutoUpdating) {
                        _ticker.shared.remove(this.update, this);
                        this._isAutoUpdating = false;
                    } else if (this._autoUpdate && !this._isAutoUpdating) {
                        _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
                        this._isAutoUpdating = true;
                    }
                }
            }
        }]);
    
        return VideoBaseTexture;
    }(_BaseTexture3.default);
    
    exports.default = VideoBaseTexture;
    
    
    VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;
    
    function createSource(path, type) {
        if (!type) {
            type = 'video/' + path.substr(path.lastIndexOf('.') + 1);
        }
    
        var source = document.createElement('source');
    
        source.src = path;
        source.type = type;
    
        return source;
    }
    
    /***/ }),
    /* 51 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _GroupD = __webpack_require__(34);
    
    var _GroupD2 = _interopRequireDefault(_GroupD);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * A standard object to store the Uvs of a texture
     *
     * @class
     * @private
     * @memberof PIXI
     */
    var TextureUvs = function () {
        /**
         *
         */
        function TextureUvs() {
            _classCallCheck(this, TextureUvs);
    
            this.x0 = 0;
            this.y0 = 0;
    
            this.x1 = 1;
            this.y1 = 0;
    
            this.x2 = 1;
            this.y2 = 1;
    
            this.x3 = 0;
            this.y3 = 1;
    
            this.uvsUint32 = new Uint32Array(4);
        }
    
        /**
         * Sets the texture Uvs based on the given frame information.
         *
         * @private
         * @param {PIXI.Rectangle} frame - The frame of the texture
         * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
         * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
         */
    
    
        TextureUvs.prototype.set = function set(frame, baseFrame, rotate) {
            var tw = baseFrame.width;
            var th = baseFrame.height;
    
            if (rotate) {
                // width and height div 2 div baseFrame size
                var w2 = frame.width / 2 / tw;
                var h2 = frame.height / 2 / th;
    
                // coordinates of center
                var cX = frame.x / tw + w2;
                var cY = frame.y / th + h2;
    
                rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW); // NW is top-left corner
                this.x0 = cX + w2 * _GroupD2.default.uX(rotate);
                this.y0 = cY + h2 * _GroupD2.default.uY(rotate);
    
                rotate = _GroupD2.default.add(rotate, 2); // rotate 90 degrees clockwise
                this.x1 = cX + w2 * _GroupD2.default.uX(rotate);
                this.y1 = cY + h2 * _GroupD2.default.uY(rotate);
    
                rotate = _GroupD2.default.add(rotate, 2);
                this.x2 = cX + w2 * _GroupD2.default.uX(rotate);
                this.y2 = cY + h2 * _GroupD2.default.uY(rotate);
    
                rotate = _GroupD2.default.add(rotate, 2);
                this.x3 = cX + w2 * _GroupD2.default.uX(rotate);
                this.y3 = cY + h2 * _GroupD2.default.uY(rotate);
            } else {
                this.x0 = frame.x / tw;
                this.y0 = frame.y / th;
    
                this.x1 = (frame.x + frame.width) / tw;
                this.y1 = frame.y / th;
    
                this.x2 = (frame.x + frame.width) / tw;
                this.y2 = (frame.y + frame.height) / th;
    
                this.x3 = frame.x / tw;
                this.y3 = (frame.y + frame.height) / th;
            }
    
            this.uvsUint32[0] = (this.y0 * 65535 & 0xFFFF) << 16 | this.x0 * 65535 & 0xFFFF;
            this.uvsUint32[1] = (this.y1 * 65535 & 0xFFFF) << 16 | this.x1 * 65535 & 0xFFFF;
            this.uvsUint32[2] = (this.y2 * 65535 & 0xFFFF) << 16 | this.x2 * 65535 & 0xFFFF;
            this.uvsUint32[3] = (this.y3 * 65535 & 0xFFFF) << 16 | this.x3 * 65535 & 0xFFFF;
        };
    
        return TextureUvs;
    }();
    
    exports.default = TextureUvs;
    
    /***/ }),
    /* 52 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _utils = __webpack_require__(1);
    
    var _math = __webpack_require__(2);
    
    var _const = __webpack_require__(0);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _Container = __webpack_require__(7);
    
    var _Container2 = _interopRequireDefault(_Container);
    
    var _RenderTexture = __webpack_require__(29);
    
    var _RenderTexture2 = _interopRequireDefault(_RenderTexture);
    
    var _eventemitter = __webpack_require__(6);
    
    var _eventemitter2 = _interopRequireDefault(_eventemitter);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var tempMatrix = new _math.Matrix();
    
    /**
     * The SystemRenderer is the base for a Pixi Renderer. It is extended by the {@link PIXI.CanvasRenderer}
     * and {@link PIXI.WebGLRenderer} which can be used for rendering a Pixi scene.
     *
     * @abstract
     * @class
     * @extends EventEmitter
     * @memberof PIXI
     */
    
    var SystemRenderer = function (_EventEmitter) {
      _inherits(SystemRenderer, _EventEmitter);
    
      // eslint-disable-next-line valid-jsdoc
      /**
       * @param {string} system - The name of the system this renderer is for.
       * @param {object} [options] - The optional renderer parameters
       * @param {number} [options.width=800] - the width of the screen
       * @param {number} [options.height=600] - the height of the screen
       * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
       * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
       * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false
       * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
       * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The
       *  resolution of the renderer retina would be 2.
       * @param {boolean} [options.clearBeforeRender=true] - This sets if the CanvasRenderer will clear the canvas or
       *      not before the new render pass.
       * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area
       *  (shown if not transparent).
       * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when rendering,
       *  stopping pixel interpolation.
       */
      function SystemRenderer(system, options, arg2, arg3) {
        _classCallCheck(this, SystemRenderer);
    
        var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
    
        (0, _utils.sayHello)(system);
    
        // Support for constructor(system, screenWidth, screenHeight, options)
        if (typeof options === 'number') {
          options = Object.assign({
            width: options,
            height: arg2 || _settings2.default.RENDER_OPTIONS.height
          }, arg3);
        }
    
        // Add the default render options
        options = Object.assign({}, _settings2.default.RENDER_OPTIONS, options);
    
        /**
         * The supplied constructor options.
         *
         * @member {Object}
         * @readOnly
         */
        _this.options = options;
    
        /**
         * The type of the renderer.
         *
         * @member {number}
         * @default PIXI.RENDERER_TYPE.UNKNOWN
         * @see PIXI.RENDERER_TYPE
         */
        _this.type = _const.RENDERER_TYPE.UNKNOWN;
    
        /**
         * Measurements of the screen. (0, 0, screenWidth, screenHeight)
         *
         * Its safe to use as filterArea or hitArea for whole stage
         *
         * @member {PIXI.Rectangle}
         */
        _this.screen = new _math.Rectangle(0, 0, options.width, options.height);
    
        /**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */
        _this.view = options.view || document.createElement('canvas');
    
        /**
         * The resolution / device pixel ratio of the renderer
         *
         * @member {number}
         * @default 1
         */
        _this.resolution = options.resolution || _settings2.default.RESOLUTION;
    
        /**
         * Whether the render view is transparent
         *
         * @member {boolean}
         */
        _this.transparent = options.transparent;
    
        /**
         * Whether css dimensions of canvas view should be resized to screen dimensions automatically
         *
         * @member {boolean}
         */
        _this.autoResize = options.autoResize || false;
    
        /**
         * Tracks the blend modes useful for this renderer.
         *
         * @member {object<string, mixed>}
         */
        _this.blendModes = null;
    
        /**
         * The value of the preserveDrawingBuffer flag affects whether or not the contents of
         * the stencil buffer is retained after rendering.
         *
         * @member {boolean}
         */
        _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
    
        /**
         * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.
         * If the scene is NOT transparent Pixi will use a canvas sized fillRect operation every
         * frame to set the canvas background color. If the scene is transparent Pixi will use clearRect
         * to clear the canvas every frame. Disable this by setting this to false. For example if
         * your game has a canvas filling background image you often don't need this set.
         *
         * @member {boolean}
         * @default
         */
        _this.clearBeforeRender = options.clearBeforeRender;
    
        /**
         * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Handy for crisp pixel art and speed on legacy devices.
         *
         * @member {boolean}
         */
        _this.roundPixels = options.roundPixels;
    
        /**
         * The background color as a number.
         *
         * @member {number}
         * @private
         */
        _this._backgroundColor = 0x000000;
    
        /**
         * The background color as an [R, G, B] array.
         *
         * @member {number[]}
         * @private
         */
        _this._backgroundColorRgba = [0, 0, 0, 0];
    
        /**
         * The background color as a string.
         *
         * @member {string}
         * @private
         */
        _this._backgroundColorString = '#000000';
    
        _this.backgroundColor = options.backgroundColor || _this._backgroundColor; // run bg color setter
    
        /**
         * This temporary display object used as the parent of the currently being rendered item
         *
         * @member {PIXI.DisplayObject}
         * @private
         */
        _this._tempDisplayObjectParent = new _Container2.default();
    
        /**
         * The last root object that the renderer tried to render.
         *
         * @member {PIXI.DisplayObject}
         * @private
         */
        _this._lastObjectRendered = _this._tempDisplayObjectParent;
        return _this;
      }
    
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal
       *
       * @member {number}
       * @readonly
       * @default 800
       */
    
    
      /**
       * Resizes the screen and canvas to the specified width and height
       * Canvas dimensions are multiplied by resolution
       *
       * @param {number} screenWidth - the new width of the screen
       * @param {number} screenHeight - the new height of the screen
       */
      SystemRenderer.prototype.resize = function resize(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
    
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
    
        if (this.autoResize) {
          this.view.style.width = screenWidth + 'px';
          this.view.style.height = screenHeight + 'px';
        }
      };
    
      /**
       * Useful function that returns a texture of the display object that can then be used to create sprites
       * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.
       *
       * @param {PIXI.DisplayObject} displayObject - The displayObject the object will be generated from
       * @param {number} scaleMode - Should be one of the scaleMode consts
       * @param {number} resolution - The resolution / device pixel ratio of the texture being generated
       * @return {PIXI.Texture} a texture of the graphics object
       */
    
    
      SystemRenderer.prototype.generateTexture = function generateTexture(displayObject, scaleMode, resolution) {
        var bounds = displayObject.getLocalBounds();
    
        var renderTexture = _RenderTexture2.default.create(bounds.width | 0, bounds.height | 0, scaleMode, resolution);
    
        tempMatrix.tx = -bounds.x;
        tempMatrix.ty = -bounds.y;
    
        this.render(displayObject, renderTexture, false, tempMatrix, true);
    
        return renderTexture;
      };
    
      /**
       * Removes everything from the renderer and optionally removes the Canvas DOM element.
       *
       * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
       */
    
    
      SystemRenderer.prototype.destroy = function destroy(removeView) {
        if (removeView && this.view.parentNode) {
          this.view.parentNode.removeChild(this.view);
        }
    
        this.type = _const.RENDERER_TYPE.UNKNOWN;
    
        this.view = null;
    
        this.screen = null;
    
        this.resolution = 0;
    
        this.transparent = false;
    
        this.autoResize = false;
    
        this.blendModes = null;
    
        this.options = null;
    
        this.preserveDrawingBuffer = false;
        this.clearBeforeRender = false;
    
        this.roundPixels = false;
    
        this._backgroundColor = 0;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
    
        this.backgroundColor = 0;
        this._tempDisplayObjectParent = null;
        this._lastObjectRendered = null;
      };
    
      /**
       * The background color to fill if not transparent
       *
       * @member {number}
       */
    
    
      _createClass(SystemRenderer, [{
        key: 'width',
        get: function get() {
          return this.view.width;
        }
    
        /**
         * Same as view.height, actual number of pixels in the canvas by vertical
         *
         * @member {number}
         * @readonly
         * @default 600
         */
    
      }, {
        key: 'height',
        get: function get() {
          return this.view.height;
        }
      }, {
        key: 'backgroundColor',
        get: function get() {
          return this._backgroundColor;
        },
        set: function set(value) // eslint-disable-line require-jsdoc
        {
          this._backgroundColor = value;
          this._backgroundColorString = (0, _utils.hex2string)(value);
          (0, _utils.hex2rgb)(value, this._backgroundColorRgba);
        }
      }]);
    
      return SystemRenderer;
    }(_eventemitter2.default);
    
    exports.default = SystemRenderer;
    
    /***/ }),
    /* 53 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _BaseTexture2 = __webpack_require__(9);
    
    var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * A BaseRenderTexture is a special texture that allows any Pixi display object to be rendered to it.
     *
     * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded
     * otherwise black rectangles will be drawn instead.
     *
     * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position
     * and rotation of the given Display Objects is ignored. For example:
     *
     * ```js
     * let renderer = PIXI.autoDetectRenderer(1024, 1024, { view: canvas, ratio: 1 });
     * let baseRenderTexture = new PIXI.BaseRenderTexture(renderer, 800, 600);
     * let sprite = PIXI.Sprite.fromImage("spinObj_01.png");
     *
     * sprite.position.x = 800/2;
     * sprite.position.y = 600/2;
     * sprite.anchor.x = 0.5;
     * sprite.anchor.y = 0.5;
     *
     * baseRenderTexture.render(sprite);
     * ```
     *
     * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0
     * you can clear the transform
     *
     * ```js
     *
     * sprite.setTransform()
     *
     * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);
     * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);
     *
     * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture
     * ```
     *
     * @class
     * @extends PIXI.BaseTexture
     * @memberof PIXI
     */
    var BaseRenderTexture = function (_BaseTexture) {
      _inherits(BaseRenderTexture, _BaseTexture);
    
      /**
       * @param {number} [width=100] - The width of the base render texture
       * @param {number} [height=100] - The height of the base render texture
       * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
       * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated
       */
      function BaseRenderTexture() {
        var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
        var scaleMode = arguments[2];
        var resolution = arguments[3];
    
        _classCallCheck(this, BaseRenderTexture);
    
        var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, null, scaleMode));
    
        _this.resolution = resolution || _settings2.default.RESOLUTION;
    
        _this.width = width;
        _this.height = height;
    
        _this.realWidth = _this.width * _this.resolution;
        _this.realHeight = _this.height * _this.resolution;
    
        _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
        _this.hasLoaded = true;
    
        /**
         * A map of renderer IDs to webgl renderTargets
         *
         * @private
         * @member {object<number, WebGLTexture>}
         */
        _this._glRenderTargets = {};
    
        /**
         * A reference to the canvas render target (we only need one as this can be shared across renderers)
         *
         * @private
         * @member {object<number, WebGLTexture>}
         */
        _this._canvasRenderTarget = null;
    
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        _this.valid = false;
        return _this;
      }
    
      /**
       * Resizes the BaseRenderTexture.
       *
       * @param {number} width - The width to resize to.
       * @param {number} height - The height to resize to.
       */
    
    
      BaseRenderTexture.prototype.resize = function resize(width, height) {
        if (width === this.width && height === this.height) {
          return;
        }
    
        this.valid = width > 0 && height > 0;
    
        this.width = width;
        this.height = height;
    
        this.realWidth = this.width * this.resolution;
        this.realHeight = this.height * this.resolution;
    
        if (!this.valid) {
          return;
        }
    
        this.emit('update', this);
      };
    
      /**
       * Destroys this texture
       *
       */
    
    
      BaseRenderTexture.prototype.destroy = function destroy() {
        _BaseTexture.prototype.destroy.call(this, true);
        this.renderer = null;
      };
    
      return BaseRenderTexture;
    }(_BaseTexture3.default);
    
    exports.default = BaseRenderTexture;
    
    /***/ }),
    /* 54 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Creates a Canvas element of the given size.
     *
     * @class
     * @memberof PIXI
     */
    var CanvasRenderTarget = function () {
      /**
       * @param {number} width - the width for the newly created canvas
       * @param {number} height - the height for the newly created canvas
       * @param {number} [resolution=1] - The resolution / device pixel ratio of the canvas
       */
      function CanvasRenderTarget(width, height, resolution) {
        _classCallCheck(this, CanvasRenderTarget);
    
        /**
         * The Canvas object that belongs to this CanvasRenderTarget.
         *
         * @member {HTMLCanvasElement}
         */
        this.canvas = document.createElement('canvas');
    
        /**
         * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
         *
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
    
        this.resolution = resolution || _settings2.default.RESOLUTION;
    
        this.resize(width, height);
      }
    
      /**
       * Clears the canvas that was created by the CanvasRenderTarget class.
       *
       * @private
       */
    
    
      CanvasRenderTarget.prototype.clear = function clear() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
    
      /**
       * Resizes the canvas to the specified width and height.
       *
       * @param {number} width - the new width of the canvas
       * @param {number} height - the new height of the canvas
       */
    
    
      CanvasRenderTarget.prototype.resize = function resize(width, height) {
        this.canvas.width = width * this.resolution;
        this.canvas.height = height * this.resolution;
      };
    
      /**
       * Destroys this canvas.
       *
       */
    
    
      CanvasRenderTarget.prototype.destroy = function destroy() {
        this.context = null;
        this.canvas = null;
      };
    
      /**
       * The width of the canvas buffer in pixels.
       *
       * @member {number}
       */
    
    
      _createClass(CanvasRenderTarget, [{
        key: 'width',
        get: function get() {
          return this.canvas.width;
        },
        set: function set(val) // eslint-disable-line require-jsdoc
        {
          this.canvas.width = val;
        }
    
        /**
         * The height of the canvas buffer in pixels.
         *
         * @member {number}
         */
    
      }, {
        key: 'height',
        get: function get() {
          return this.canvas.height;
        },
        set: function set(val) // eslint-disable-line require-jsdoc
        {
          this.canvas.height = val;
        }
      }]);
    
      return CanvasRenderTarget;
    }();
    
    exports.default = CanvasRenderTarget;
    
    /***/ }),
    /* 55 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = canUseNewCanvasBlendModes;
    /**
     * Creates a little colored canvas
     *
     * @ignore
     * @param {string} color - The color to make the canvas
     * @return {canvas} a small canvas element
     */
    function createColoredCanvas(color) {
        var canvas = document.createElement('canvas');
    
        canvas.width = 6;
        canvas.height = 1;
    
        var context = canvas.getContext('2d');
    
        context.fillStyle = color;
        context.fillRect(0, 0, 6, 1);
    
        return canvas;
    }
    
    /**
     * Checks whether the Canvas BlendModes are supported by the current browser
     *
     * @return {boolean} whether they are supported
     */
    function canUseNewCanvasBlendModes() {
        if (typeof document === 'undefined') {
            return false;
        }
    
        var magenta = createColoredCanvas('#ff00ff');
        var yellow = createColoredCanvas('#ffff00');
    
        var canvas = document.createElement('canvas');
    
        canvas.width = 6;
        canvas.height = 1;
    
        var context = canvas.getContext('2d');
    
        context.globalCompositeOperation = 'multiply';
        context.drawImage(magenta, 0, 0);
        context.drawImage(yellow, 2, 0);
    
        var imageData = context.getImageData(2, 0, 1, 1);
    
        if (!imageData) {
            return false;
        }
    
        var data = imageData.data;
    
        return data[0] === 255 && data[1] === 0 && data[2] === 0;
    }
    
    /***/ }),
    /* 56 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _utils = __webpack_require__(1);
    
    var _canUseNewCanvasBlendModes = __webpack_require__(55);
    
    var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * Utility methods for Sprite/Texture tinting.
     *
     * @class
     * @memberof PIXI
     */
    var CanvasTinter = {
        /**
         * Basically this method just needs a sprite and a color and tints the sprite with the given color.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Sprite} sprite - the sprite to tint
         * @param {number} color - the color to use to tint the sprite with
         * @return {HTMLCanvasElement} The tinted canvas
         */
        getTintedTexture: function getTintedTexture(sprite, color) {
            var texture = sprite._texture;
    
            color = CanvasTinter.roundColor(color);
    
            var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
    
            texture.tintCache = texture.tintCache || {};
    
            if (texture.tintCache[stringColor]) {
                return texture.tintCache[stringColor];
            }
    
            // clone texture..
            var canvas = CanvasTinter.canvas || document.createElement('canvas');
    
            // CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);
            CanvasTinter.tintMethod(texture, color, canvas);
    
            if (CanvasTinter.convertTintToImage) {
                // is this better?
                var tintImage = new Image();
    
                tintImage.src = canvas.toDataURL();
    
                texture.tintCache[stringColor] = tintImage;
            } else {
                texture.tintCache[stringColor] = canvas;
                // if we are not converting the texture to an image then we need to lose the reference to the canvas
                CanvasTinter.canvas = null;
            }
    
            return canvas;
        },
    
        /**
         * Tint a texture using the 'multiply' operation.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Texture} texture - the texture to tint
         * @param {number} color - the color to use to tint the sprite with
         * @param {HTMLCanvasElement} canvas - the current canvas
         */
        tintWithMultiply: function tintWithMultiply(texture, color, canvas) {
            var context = canvas.getContext('2d');
            var crop = texture._frame.clone();
            var resolution = texture.baseTexture.resolution;
    
            crop.x *= resolution;
            crop.y *= resolution;
            crop.width *= resolution;
            crop.height *= resolution;
    
            canvas.width = Math.ceil(crop.width);
            canvas.height = Math.ceil(crop.height);
    
            context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
    
            context.fillRect(0, 0, crop.width, crop.height);
    
            context.globalCompositeOperation = 'multiply';
    
            context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    
            context.globalCompositeOperation = 'destination-atop';
    
            context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
        },
    
        /**
         * Tint a texture using the 'overlay' operation.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Texture} texture - the texture to tint
         * @param {number} color - the color to use to tint the sprite with
         * @param {HTMLCanvasElement} canvas - the current canvas
         */
        tintWithOverlay: function tintWithOverlay(texture, color, canvas) {
            var context = canvas.getContext('2d');
            var crop = texture._frame.clone();
            var resolution = texture.baseTexture.resolution;
    
            crop.x *= resolution;
            crop.y *= resolution;
            crop.width *= resolution;
            crop.height *= resolution;
    
            canvas.width = Math.ceil(crop.width);
            canvas.height = Math.ceil(crop.height);
    
            context.globalCompositeOperation = 'copy';
            context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
            context.fillRect(0, 0, crop.width, crop.height);
    
            context.globalCompositeOperation = 'destination-atop';
            context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    
            // context.globalCompositeOperation = 'copy';
        },
    
    
        /**
         * Tint a texture pixel per pixel.
         *
         * @memberof PIXI.CanvasTinter
         * @param {PIXI.Texture} texture - the texture to tint
         * @param {number} color - the color to use to tint the sprite with
         * @param {HTMLCanvasElement} canvas - the current canvas
         */
        tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {
            var context = canvas.getContext('2d');
            var crop = texture._frame.clone();
            var resolution = texture.baseTexture.resolution;
    
            crop.x *= resolution;
            crop.y *= resolution;
            crop.width *= resolution;
            crop.height *= resolution;
    
            canvas.width = Math.ceil(crop.width);
            canvas.height = Math.ceil(crop.height);
    
            context.globalCompositeOperation = 'copy';
            context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
    
            var rgbValues = (0, _utils.hex2rgb)(color);
            var r = rgbValues[0];
            var g = rgbValues[1];
            var b = rgbValues[2];
    
            var pixelData = context.getImageData(0, 0, crop.width, crop.height);
    
            var pixels = pixelData.data;
    
            for (var i = 0; i < pixels.length; i += 4) {
                pixels[i + 0] *= r;
                pixels[i + 1] *= g;
                pixels[i + 2] *= b;
            }
    
            context.putImageData(pixelData, 0, 0);
        },
    
        /**
         * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.
         *
         * @memberof PIXI.CanvasTinter
         * @param {number} color - the color to round, should be a hex color
         * @return {number} The rounded color.
         */
        roundColor: function roundColor(color) {
            var step = CanvasTinter.cacheStepsPerColorChannel;
    
            var rgbValues = (0, _utils.hex2rgb)(color);
    
            rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
            rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
            rgbValues[2] = Math.min(255, rgbValues[2] / step * step);
    
            return (0, _utils.rgb2hex)(rgbValues);
        },
    
        /**
         * Number of steps which will be used as a cap when rounding colors.
         *
         * @memberof PIXI.CanvasTinter
         * @type {number}
         */
        cacheStepsPerColorChannel: 8,
    
        /**
         * Tint cache boolean flag.
         *
         * @memberof PIXI.CanvasTinter
         * @type {boolean}
         */
        convertTintToImage: false,
    
        /**
         * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.
         *
         * @memberof PIXI.CanvasTinter
         * @type {boolean}
         */
        canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),
    
        /**
         * The tinting method that will be used.
         *
         * @memberof PIXI.CanvasTinter
         * @type {tintMethodFunctionType}
         */
        tintMethod: 0
    };
    
    CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;
    
    /**
     * The tintMethod type.
     *
     * @memberof PIXI.CanvasTinter
     * @callback tintMethodFunctionType
     * @param texture {PIXI.Texture} the texture to tint
     * @param color {number} the color to use to tint the sprite with
     * @param canvas {HTMLCanvasElement} the current canvas
     */
    
    exports.default = CanvasTinter;
    
    /***/ }),
    /* 57 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Filter2 = __webpack_require__(58);
    
    var _Filter3 = _interopRequireDefault(_Filter2);
    
    var _math = __webpack_require__(2);
    
    var _path = __webpack_require__(30);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * The SpriteMaskFilter class
     *
     * @class
     * @extends PIXI.Filter
     * @memberof PIXI
     */
    var SpriteMaskFilter = function (_Filter) {
        _inherits(SpriteMaskFilter, _Filter);
    
        /**
         * @param {PIXI.Sprite} sprite - the target sprite
         */
        function SpriteMaskFilter(sprite) {
            _classCallCheck(this, SpriteMaskFilter);
    
            var maskMatrix = new _math.Matrix();
    
            var _this = _possibleConstructorReturn(this, _Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n\n    original *= (masky.r * masky.a * alpha * clip);\n\n    gl_FragColor = original;\n}\n'));
    
            sprite.renderable = false;
    
            _this.maskSprite = sprite;
            _this.maskMatrix = maskMatrix;
            return _this;
        }
    
        /**
         * Applies the filter
         *
         * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
         * @param {PIXI.RenderTarget} input - The input render target.
         * @param {PIXI.RenderTarget} output - The target to output to.
         */
    
    
        SpriteMaskFilter.prototype.apply = function apply(filterManager, input, output) {
            var maskSprite = this.maskSprite;
    
            this.uniforms.mask = maskSprite._texture;
            this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite);
            this.uniforms.alpha = maskSprite.worldAlpha;
    
            filterManager.applyFilter(this, input, output);
        };
    
        return SpriteMaskFilter;
    }(_Filter3.default);
    
    exports.default = SpriteMaskFilter;
    
    /***/ }),
    /* 58 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _extractUniformsFromSrc = __webpack_require__(120);
    
    var _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);
    
    var _utils = __webpack_require__(1);
    
    var _const = __webpack_require__(0);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var SOURCE_KEY_MAP = {};
    
    // let math = require('../../../math');
    /**
     * @class
     * @memberof PIXI
     * @extends PIXI.Shader
     */
    
    var Filter = function () {
      /**
       * @param {string} [vertexSrc] - The source of the vertex shader.
       * @param {string} [fragmentSrc] - The source of the fragment shader.
       * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
       */
      function Filter(vertexSrc, fragmentSrc, uniforms) {
        _classCallCheck(this, Filter);
    
        /**
         * The vertex shader.
         *
         * @member {string}
         */
        this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;
    
        /**
         * The fragment shader.
         *
         * @member {string}
         */
        this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;
    
        this.blendMode = _const.BLEND_MODES.NORMAL;
    
        this.uniformData = uniforms || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');
    
        /**
         * An object containing the current values of custom uniforms.
         * @example <caption>Updating the value of a custom uniform</caption>
         * filter.uniforms.time = performance.now();
         *
         * @member {object}
         */
        this.uniforms = {};
    
        for (var i in this.uniformData) {
          this.uniforms[i] = this.uniformData[i].value;
        }
    
        // this is where we store shader references..
        // TODO we could cache this!
        this.glShaders = {};
    
        // used for cacheing.. sure there is a better way!
        if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) {
          SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)();
        }
    
        this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];
    
        /**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */
        this.padding = 4;
    
        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */
        this.resolution = _settings2.default.RESOLUTION;
    
        /**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */
        this.enabled = true;
    
        /**
         * If enabled, pixi will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */
        this.autoFit = true;
      }
    
      /**
       * Applies the filter
       *
       * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from
       * @param {PIXI.RenderTarget} input - The input render target.
       * @param {PIXI.RenderTarget} output - The target to output to.
       * @param {boolean} clear - Should the output be cleared before rendering to it
       * @param {object} [currentState] - It's current state of filter.
       *        There are some useful properties in the currentState :
       *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
       */
    
    
      Filter.prototype.apply = function apply(filterManager, input, output, clear, currentState) // eslint-disable-line no-unused-vars
      {
        // --- //
        //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );
    
        // do as you please!
    
        filterManager.applyFilter(this, input, output, clear);
    
        // or just do a regular render..
      };
    
      /**
       * The default vertex shader source
       *
       * @static
       * @constant
       */
    
    
      _createClass(Filter, null, [{
        key: 'defaultVertexSrc',
        get: function get() {
          return ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 projectionMatrix;', 'uniform mat3 filterMatrix;', 'varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;', '   vTextureCoord = aTextureCoord ;', '}'].join('\n');
        }
    
        /**
         * The default fragment shader source
         *
         * @static
         * @constant
         */
    
      }, {
        key: 'defaultFragmentSrc',
        get: function get() {
          return ['varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'uniform sampler2D uSampler;', 'uniform sampler2D filterSampler;', 'void main(void){', '   vec4 masky = texture2D(filterSampler, vFilterCoord);', '   vec4 sample = texture2D(uSampler, vTextureCoord);', '   vec4 color;', '   if(mod(vFilterCoord.x, 1.0) > 0.5)', '   {', '     color = vec4(1.0, 0.0, 0.0, 1.0);', '   }', '   else', '   {', '     color = vec4(0.0, 1.0, 0.0, 1.0);', '   }',
          // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',
          '   gl_FragColor = mix(sample, masky, 0.5);', '   gl_FragColor *= sample.a;', '}'].join('\n');
        }
      }]);
    
      return Filter;
    }();
    
    exports.default = Filter;
    
    /***/ }),
    /* 59 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
    
    var _createIndicesForQuads = __webpack_require__(60);
    
    var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Helper class to create a quad
     *
     * @class
     * @memberof PIXI
     */
    var Quad = function () {
      /**
       * @param {WebGLRenderingContext} gl - The gl context for this quad to use.
       * @param {object} state - TODO: Description
       */
      function Quad(gl, state) {
        _classCallCheck(this, Quad);
    
        /**
         * the current WebGL drawing context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
    
        /**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */
        this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    
        this.interleaved = new Float32Array(8 * 2);
    
        for (var i = 0; i < 4; i++) {
          this.interleaved[i * 4] = this.vertices[i * 2];
          this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
          this.interleaved[i * 4 + 2] = this.uvs[i * 2];
          this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
        }
    
        /**
         * An array containing the indices of the vertices
         *
         * @member {Uint16Array}
         */
        this.indices = (0, _createIndicesForQuads2.default)(1);
    
        /**
         * The vertex buffer
         *
         * @member {glCore.GLBuffer}
         */
        this.vertexBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.interleaved, gl.STATIC_DRAW);
    
        /**
         * The index buffer
         *
         * @member {glCore.GLBuffer}
         */
        this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);
    
        /**
         * The vertex array object
         *
         * @member {glCore.VertexArrayObject}
         */
        this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, state);
      }
    
      /**
       * Initialises the vaos and uses the shader.
       *
       * @param {PIXI.Shader} shader - the shader to use
       */
    
    
      Quad.prototype.initVao = function initVao(shader) {
        this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer, shader.attributes.aVertexPosition, this.gl.FLOAT, false, 4 * 4, 0).addAttribute(this.vertexBuffer, shader.attributes.aTextureCoord, this.gl.FLOAT, false, 4 * 4, 2 * 4);
      };
    
      /**
       * Maps two Rectangle to the quad.
       *
       * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
       * @param {PIXI.Rectangle} destinationFrame - the second rectangle
       * @return {PIXI.Quad} Returns itself.
       */
    
    
      Quad.prototype.map = function map(targetTextureFrame, destinationFrame) {
        var x = 0; // destinationFrame.x / targetTextureFrame.width;
        var y = 0; // destinationFrame.y / targetTextureFrame.height;
    
        this.uvs[0] = x;
        this.uvs[1] = y;
    
        this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
        this.uvs[3] = y;
    
        this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
        this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
    
        this.uvs[6] = x;
        this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
    
        x = destinationFrame.x;
        y = destinationFrame.y;
    
        this.vertices[0] = x;
        this.vertices[1] = y;
    
        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;
    
        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;
    
        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;
    
        return this;
      };
    
      /**
       * Binds the buffer and uploads the data
       *
       * @return {PIXI.Quad} Returns itself.
       */
    
    
      Quad.prototype.upload = function upload() {
        for (var i = 0; i < 4; i++) {
          this.interleaved[i * 4] = this.vertices[i * 2];
          this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
          this.interleaved[i * 4 + 2] = this.uvs[i * 2];
          this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1];
        }
    
        this.vertexBuffer.upload(this.interleaved);
    
        return this;
      };
    
      /**
       * Removes this quad from WebGL
       */
    
    
      Quad.prototype.destroy = function destroy() {
        var gl = this.gl;
    
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.indexBuffer);
      };
    
      return Quad;
    }();
    
    exports.default = Quad;
    
    /***/ }),
    /* 60 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = createIndicesForQuads;
    /**
     * Generic Mask Stack data structure
     *
     * @memberof PIXI
     * @function createIndicesForQuads
     * @private
     * @param {number} size - Number of quads
     * @return {Uint16Array} indices
     */
    function createIndicesForQuads(size) {
        // the total number of indices in our array, there are 6 points per quad.
    
        var totalIndices = size * 6;
    
        var indices = new Uint16Array(totalIndices);
    
        // fill the indices with the quads to draw
        for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;
            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }
    
        return indices;
    }
    
    /***/ }),
    /* 61 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * A GraphicsData object.
     *
     * @class
     * @memberof PIXI
     */
    var GraphicsData = function () {
      /**
       *
       * @param {number} lineWidth - the width of the line to draw
       * @param {number} lineColor - the color of the line to draw
       * @param {number} lineAlpha - the alpha of the line to draw
       * @param {number} fillColor - the color of the fill
       * @param {number} fillAlpha - the alpha of the fill
       * @param {boolean} fill - whether or not the shape is filled with a colour
       * @param {boolean} nativeLines - the method for drawing lines
       * @param {PIXI.Circle|PIXI.Rectangle|PIXI.Ellipse|PIXI.Polygon} shape - The shape object to draw.
       */
      function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, nativeLines, shape) {
        _classCallCheck(this, GraphicsData);
    
        /**
         * @member {number} the width of the line to draw
         */
        this.lineWidth = lineWidth;
        /**
         * @member {boolean} if true the liens will be draw using LINES instead of TRIANGLE_STRIP
         */
        this.nativeLines = nativeLines;
    
        /**
         * @member {number} the color of the line to draw
         */
        this.lineColor = lineColor;
    
        /**
         * @member {number} the alpha of the line to draw
         */
        this.lineAlpha = lineAlpha;
    
        /**
         * @member {number} cached tint of the line to draw
         */
        this._lineTint = lineColor;
    
        /**
         * @member {number} the color of the fill
         */
        this.fillColor = fillColor;
    
        /**
         * @member {number} the alpha of the fill
         */
        this.fillAlpha = fillAlpha;
    
        /**
         * @member {number} cached tint of the fill
         */
        this._fillTint = fillColor;
    
        /**
         * @member {boolean} whether or not the shape is filled with a colour
         */
        this.fill = fill;
    
        this.holes = [];
    
        /**
         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} The shape object to draw.
         */
        this.shape = shape;
    
        /**
         * @member {number} The type of the shape, see the Const.Shapes file for all the existing types,
         */
        this.type = shape.type;
      }
    
      /**
       * Creates a new GraphicsData object with the same values as this one.
       *
       * @return {PIXI.GraphicsData} Cloned GraphicsData object
       */
    
    
      GraphicsData.prototype.clone = function clone() {
        return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.nativeLines, this.shape);
      };
    
      /**
       * Adds a hole to the shape.
       *
       * @param {PIXI.Rectangle|PIXI.Circle} shape - The shape of the hole.
       */
    
    
      GraphicsData.prototype.addHole = function addHole(shape) {
        this.holes.push(shape);
      };
    
      /**
       * Destroys the Graphics data.
       */
    
    
      GraphicsData.prototype.destroy = function destroy() {
        this.shape = null;
        this.holes = null;
      };
    
      return GraphicsData;
    }();
    
    exports.default = GraphicsData;
    
    /***/ }),
    /* 62 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    module.exports = earcut;
    
    function earcut(data, holeIndices, dim) {
    
        dim = dim || 2;
    
        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = linkedList(data, 0, outerLen, dim, true),
            triangles = [];
    
        if (!outerNode) return triangles;
    
        var minX, minY, maxX, maxY, x, y, size;
    
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
    
            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
    
            // minX, minY and size are later used to transform coords into integers for z-order calculation
            size = Math.max(maxX - minX, maxY - minY);
        }
    
        earcutLinked(outerNode, triangles, dim, minX, minY, size);
    
        return triangles;
    }
    
    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;
    
        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }
    
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
    
        return last;
    }
    
    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;
    
        var p = start,
            again;
        do {
            again = false;
    
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) return null;
                again = true;
    
            } else {
                p = p.next;
            }
        } while (again || p !== end);
    
        return end;
    }
    
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
        if (!ear) return;
    
        // interlink polygon nodes in z-order
        if (!pass && size) indexCurve(ear, minX, minY, size);
    
        var stop = ear,
            prev, next;
    
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
    
            if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
    
                removeNode(ear);
    
                // skipping the next vertice leads to less sliver triangles
                ear = next.next;
                stop = next.next;
    
                continue;
            }
    
            ear = next;
    
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
    
                // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);
    
                // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, size);
                }
    
                break;
            }
        }
    }
    
    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
    
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
    
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }
    
        return true;
    }
    
    function isEarHashed(ear, minX, minY, size) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
    
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
    
        // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, size),
            maxZ = zOrder(maxTX, maxTY, minX, minY, size);
    
        // first look for points inside the triangle in increasing z-order
        var p = ear.nextZ;
    
        while (p && p.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.nextZ;
        }
    
        // then look for points in decreasing z-order
        p = ear.prevZ;
    
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }
    
        return true;
    }
    
    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;
    
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
    
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
    
                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);
    
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
    
        return p;
    }
    
    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, size) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);
    
                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
    
                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, size);
                    earcutLinked(c, triangles, dim, minX, minY, size);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    
    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;
    
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }
    
        queue.sort(compareX);
    
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
    
        return outerNode;
    }
    
    function compareX(a, b) {
        return a.x - b.x;
    }
    
    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;
    
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
    
        if (!m) return null;
    
        if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
    
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
    
        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;
    
        p = m.next;
    
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx &&
                    pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
    
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
    
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
    
            p = p.next;
        }
    
        return m;
    }
    
    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, size) {
        var p = start;
        do {
            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
    
        p.prevZ.nextZ = null;
        p.prevZ = null;
    
        sortLinked(p);
    }
    
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;
    
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
    
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
    
                qSize = inSize;
    
                while (pSize > 0 || (qSize > 0 && q)) {
    
                    if (pSize === 0) {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    } else if (qSize === 0 || !q) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else if (p.z <= q.z) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
    
                    if (tail) tail.nextZ = e;
                    else list = e;
    
                    e.prevZ = tail;
                    tail = e;
                }
    
                p = q;
            }
    
            tail.nextZ = null;
            inSize *= 2;
    
        } while (numMerges > 1);
    
        return list;
    }
    
    // z-order of a point given coords and size of the data bounding box
    function zOrder(x, y, minX, minY, size) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) / size;
        y = 32767 * (y - minY) / size;
    
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
    
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
    
        return x | (y << 1);
    }
    
    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x) leftmost = p;
            p = p.next;
        } while (p !== start);
    
        return leftmost;
    }
    
    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
               (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
               (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
               locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    
    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    
    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    
    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        if ((equals(p1, q1) && equals(p2, q2)) ||
            (equals(p1, q2) && equals(p2, q1))) return true;
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
               area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    
    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    intersects(p, p.next, a, b)) return true;
            p = p.next;
        } while (p !== a);
    
        return false;
    }
    
    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    
    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);
    
        return inside;
    }
    
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y),
            b2 = new Node(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;
    
        a.next = b;
        b.prev = a;
    
        a2.next = an;
        an.prev = a2;
    
        b2.next = a2;
        a2.prev = b2;
    
        bp.next = b2;
        b2.prev = bp;
    
        return b2;
    }
    
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
    
        if (!last) {
            p.prev = p;
            p.next = p;
    
        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
    
        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    
    function Node(i, x, y) {
        // vertice index in coordinates array
        this.i = i;
    
        // vertex coordinates
        this.x = x;
        this.y = y;
    
        // previous and next vertice nodes in a polygon ring
        this.prev = null;
        this.next = null;
    
        // z-order curve value
        this.z = null;
    
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
    
        // indicates whether this is a steiner point
        this.steiner = false;
    }
    
    // return a percentage difference between the polygon area and its triangulation area;
    // used to verify correctness of triangulation
    earcut.deviation = function (data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
            for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
            }
        }
    
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
            var a = triangles[i] * dim;
            var b = triangles[i + 1] * dim;
            var c = triangles[i + 2] * dim;
            trianglesArea += Math.abs(
                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }
    
        return polygonArea === 0 && trianglesArea === 0 ? 0 :
            Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    
    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    
    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
    earcut.flatten = function (data) {
        var dim = data[0][0].length,
            result = {vertices: [], holes: [], dimensions: dim},
            holeIndex = 0;
    
        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    };
    
    
    /***/ }),
    /* 63 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _autoDetectRenderer = __webpack_require__(64);
    
    var _Container = __webpack_require__(7);
    
    var _Container2 = _interopRequireDefault(_Container);
    
    var _ticker = __webpack_require__(28);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _const = __webpack_require__(0);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Convenience class to create a new PIXI application.
     * This class automatically creates the renderer, ticker
     * and root container.
     *
     * @example
     * // Create the application
     * const app = new PIXI.Application();
     *
     * // Add the view to the DOM
     * document.body.appendChild(app.view);
     *
     * // ex, add display objects
     * app.stage.addChild(PIXI.Sprite.fromImage('something.png'));
     *
     * @class
     * @memberof PIXI
     */
    var Application = function () {
        // eslint-disable-next-line valid-jsdoc
        /**
         * @param {object} [options] - The optional renderer parameters
         * @param {number} [options.width=800] - the width of the renderers view
         * @param {number} [options.height=600] - the height of the renderers view
         * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
         * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
         * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
         * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
         *      need to call toDataUrl on the webgl context
         * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
         * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present
         * @param {boolean} [options.legacy=false] - If true Pixi will aim to ensure compatibility
         * with older / less advanced devices. If you experience unexplained flickering try setting this to true.
         * @param {boolean} [options.sharedTicker=false] - `true` to use PIXI.ticker.shared, `false` to create new ticker.
         * @param {boolean} [options.sharedLoader=false] - `true` to use PIXI.loaders.shared, `false` to create new Loader.
         */
        function Application(options, arg2, arg3, arg4, arg5) {
            _classCallCheck(this, Application);
    
            // Support for constructor(width, height, options, noWebGL, useSharedTicker)
            if (typeof options === 'number') {
                options = Object.assign({
                    width: options,
                    height: arg2 || _settings2.default.RENDER_OPTIONS.height,
                    forceCanvas: !!arg4,
                    sharedTicker: !!arg5
                }, arg3);
            }
    
            /**
             * The default options, so we mixin functionality later.
             * @member {object}
             * @protected
             */
            this._options = options = Object.assign({
                sharedTicker: false,
                forceCanvas: false,
                sharedLoader: false
            }, options);
    
            /**
             * WebGL renderer if available, otherwise CanvasRenderer
             * @member {PIXI.WebGLRenderer|PIXI.CanvasRenderer}
             */
            this.renderer = (0, _autoDetectRenderer.autoDetectRenderer)(options);
    
            /**
             * The root display container that's rendered.
             * @member {PIXI.Container}
             */
            this.stage = new _Container2.default();
    
            /**
             * Internal reference to the ticker
             * @member {PIXI.ticker.Ticker}
             * @private
             */
            this._ticker = null;
    
            /**
             * Ticker for doing render updates.
             * @member {PIXI.ticker.Ticker}
             * @default PIXI.ticker.shared
             */
            this.ticker = options.sharedTicker ? _ticker.shared : new _ticker.Ticker();
    
            // Start the rendering
            this.start();
        }
    
        /**
         * Render the current stage.
         */
        Application.prototype.render = function render() {
            this.renderer.render(this.stage);
        };
    
        /**
         * Convenience method for stopping the render.
         */
    
    
        Application.prototype.stop = function stop() {
            this._ticker.stop();
        };
    
        /**
         * Convenience method for starting the render.
         */
    
    
        Application.prototype.start = function start() {
            this._ticker.start();
        };
    
        /**
         * Reference to the renderer's canvas element.
         * @member {HTMLCanvasElement}
         * @readonly
         */
    
    
        /**
         * Destroy and don't use after this.
         * @param {Boolean} [removeView=false] Automatically remove canvas from DOM.
         */
        Application.prototype.destroy = function destroy(removeView) {
            var oldTicker = this._ticker;
    
            this.ticker = null;
    
            oldTicker.destroy();
    
            this.stage.destroy();
            this.stage = null;
    
            this.renderer.destroy(removeView);
            this.renderer = null;
    
            this._options = null;
        };
    
        _createClass(Application, [{
            key: 'ticker',
            set: function set(ticker) // eslint-disable-line require-jsdoc
            {
                if (this._ticker) {
                    this._ticker.remove(this.render, this);
                }
                this._ticker = ticker;
                if (ticker) {
                    ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW);
                }
            },
            get: function get() // eslint-disable-line require-jsdoc
            {
                return this._ticker;
            }
        }, {
            key: 'view',
            get: function get() {
                return this.renderer.view;
            }
    
            /**
             * Reference to the renderer's screen rectangle. Its safe to use as filterArea or hitArea for whole screen
             * @member {PIXI.Rectangle}
             * @readonly
             */
    
        }, {
            key: 'screen',
            get: function get() {
                return this.renderer.screen;
            }
        }]);
    
        return Application;
    }();
    
    exports.default = Application;
    
    /***/ }),
    /* 64 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.autoDetectRenderer = autoDetectRenderer;
    
    var _utils = __webpack_require__(1);
    
    var utils = _interopRequireWildcard(_utils);
    
    var _CanvasRenderer = __webpack_require__(10);
    
    var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
    
    var _WebGLRenderer = __webpack_require__(14);
    
    var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    // eslint-disable-next-line valid-jsdoc
    /**
     * This helper function will automatically detect which renderer you should be using.
     * WebGL is the preferred renderer as it is a lot faster. If webGL is not supported by
     * the browser then this function will return a canvas renderer
     *
     * @memberof PIXI
     * @function autoDetectRenderer
     * @param {object} [options] - The optional renderer parameters
     * @param {number} [options.width=800] - the width of the renderers view
     * @param {number} [options.height=600] - the height of the renderers view
     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional
     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false
     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)
     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation, enable this if you
     *      need to call toDataUrl on the webgl context
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer, retina would be 2
     * @param {boolean} [options.forceCanvas=false] - prevents selection of WebGL renderer, even if such is present
     * @return {PIXI.WebGLRenderer|PIXI.CanvasRenderer} Returns WebGL renderer if available, otherwise CanvasRenderer
     */
    function autoDetectRenderer(options, arg1, arg2, arg3) {
        // Backward-compatible support for noWebGL option
        var forceCanvas = options && options.forceCanvas;
    
        if (arg3 !== undefined) {
            forceCanvas = arg3;
        }
    
        if (!forceCanvas && utils.isWebGLSupported()) {
            return new _WebGLRenderer2.default(options, arg1, arg2);
        }
    
        return new _CanvasRenderer2.default(options, arg1, arg2);
    }
    
    /***/ }),
    /* 65 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Holds all information related to an Interaction event
     *
     * @class
     * @memberof PIXI.interaction
     */
    var InteractionData = function () {
      /**
       *
       */
      function InteractionData() {
        _classCallCheck(this, InteractionData);
    
        /**
         * This point stores the global coords of where the touch/mouse event happened
         *
         * @member {PIXI.Point}
         */
        this.global = new core.Point();
    
        /**
         * The target DisplayObject that was interacted with
         *
         * @member {PIXI.DisplayObject}
         */
        this.target = null;
    
        /**
         * When passed to an event handler, this will be the original DOM Event that was captured
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
         * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent
         * @member {MouseEvent|TouchEvent|PointerEvent}
         */
        this.originalEvent = null;
    
        /**
         * Unique identifier for this interaction
         *
         * @member {number}
         */
        this.identifier = null;
    
        /**
         * Indicates whether or not the pointer device that created the event is the primary pointer.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
         * @type {Boolean}
         */
        this.isPrimary = false;
    
        /**
         * Indicates which button was pressed on the mouse or pointer device to trigger the event.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
         * @type {number}
         */
        this.button = 0;
    
        /**
         * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
         * @type {number}
         */
        this.buttons = 0;
    
        /**
         * The width of the pointer's contact along the x-axis, measured in CSS pixels.
         * radiusX of TouchEvents will be represented by this value.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
         * @type {number}
         */
        this.width = 0;
    
        /**
         * The height of the pointer's contact along the y-axis, measured in CSS pixels.
         * radiusY of TouchEvents will be represented by this value.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
         * @type {number}
         */
        this.height = 0;
    
        /**
         * The angle, in degrees, between the pointer device and the screen.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
         * @type {number}
         */
        this.tiltX = 0;
    
        /**
         * The angle, in degrees, between the pointer device and the screen.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
         * @type {number}
         */
        this.tiltY = 0;
    
        /**
         * The type of pointer that triggered the event.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
         * @type {string}
         */
        this.pointerType = null;
    
        /**
         * Pressure applied by the pointing device during the event. A Touch's force property
         * will be represented by this value.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
         * @type {number}
         */
        this.pressure = 0;
    
        /**
         * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle
         * @type {number}
         */
        this.rotationAngle = 0;
    
        /**
         * Twist of a stylus pointer.
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         * @type {number}
         */
        this.twist = 0;
    
        /**
         * Barrel pressure on a stylus pointer.
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         * @type {number}
         */
        this.tangentialPressure = 0;
      }
    
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @member {number}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
    
    
      /**
       * This will return the local coordinates of the specified displayObject for this InteractionData
       *
       * @param {PIXI.DisplayObject} displayObject - The DisplayObject that you would like the local
       *  coords off
       * @param {PIXI.Point} [point] - A Point object in which to store the value, optional (otherwise
       *  will create a new point)
       * @param {PIXI.Point} [globalPos] - A Point object containing your custom global coords, optional
       *  (otherwise will use the current global coords)
       * @return {PIXI.Point} A point containing the coordinates of the InteractionData position relative
       *  to the DisplayObject
       */
      InteractionData.prototype.getLocalPosition = function getLocalPosition(displayObject, point, globalPos) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
      };
    
      /**
       * Copies properties from normalized event data.
       *
       * @param {Touch|MouseEvent|PointerEvent} event The normalized event data
       * @private
       */
    
    
      InteractionData.prototype._copyEvent = function _copyEvent(event) {
        // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite
        // it with "false" on later events when our shim for it on touch events might not be
        // accurate
        if (event.isPrimary) {
          this.isPrimary = true;
        }
        this.button = event.button;
        this.buttons = event.buttons;
        this.width = event.width;
        this.height = event.height;
        this.tiltX = event.tiltX;
        this.tiltY = event.tiltY;
        this.pointerType = event.pointerType;
        this.pressure = event.pressure;
        this.rotationAngle = event.rotationAngle;
        this.twist = event.twist || 0;
        this.tangentialPressure = event.tangentialPressure || 0;
      };
    
      /**
       * Resets the data for pooling.
       *
       * @private
       */
    
    
      InteractionData.prototype._reset = function _reset() {
        // isPrimary is the only property that we really need to reset - everything else is
        // guaranteed to be overwritten
        this.isPrimary = false;
      };
    
      _createClass(InteractionData, [{
        key: 'pointerId',
        get: function get() {
          return this.identifier;
        }
      }]);
    
      return InteractionData;
    }();
    
    exports.default = InteractionData;
    
    /***/ }),
    /* 66 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    /**
     * Default property values of interactive objects
     * Used by {@link PIXI.interaction.InteractionManager} to automatically give all DisplayObjects these properties
     *
     * @private
     * @name interactiveTarget
     * @memberof PIXI.interaction
     * @example
     *      function MyObject() {}
     *
     *      Object.assign(
     *          core.DisplayObject.prototype,
     *          PIXI.interaction.interactiveTarget
     *      );
     */
    exports.default = {
    
      /**
       * Enable interaction events for the DisplayObject. Touch, pointer and mouse
       * events will not be emitted unless `interactive` is set to `true`.
       *
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.interactive = true;
       * sprite.on('tap', (event) => {
       *    //handle event
       * });
       * @member {boolean}
       * @memberof PIXI.DisplayObject#
       */
      interactive: false,
    
      /**
       * Determines if the children to the displayObject can be clicked/touched
       * Setting this to false allows pixi to bypass a recursive `hitTest` function
       *
       * @member {boolean}
       * @memberof PIXI.Container#
       */
      interactiveChildren: true,
    
      /**
       * Interaction shape. Children will be hit first, then this shape will be checked.
       * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
       *
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.interactive = true;
       * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
       * @member {PIXI.Rectangle|PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.RoundedRectangle}
       * @memberof PIXI.DisplayObject#
       */
      hitArea: null,
    
      /**
       * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
       * Setting this changes the 'cursor' property to `'pointer'`.
       *
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.interactive = true;
       * sprite.buttonMode = true;
       * @member {boolean}
       * @memberof PIXI.DisplayObject#
       */
      get buttonMode() {
        return this.cursor === 'pointer';
      },
      set buttonMode(value) {
        if (value) {
          this.cursor = 'pointer';
        } else if (this.cursor === 'pointer') {
          this.cursor = null;
        }
      },
    
      /**
       * This defines what cursor mode is used when the mouse cursor
       * is hovered over the displayObject.
       *
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.interactive = true;
       * sprite.cursor = 'wait';
       * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
       *
       * @member {string}
       * @memberof PIXI.DisplayObject#
       */
      cursor: null,
    
      /**
       * Internal set of all active pointers, by identifier
       *
       * @member {Map<number, InteractionTrackingData>}
       * @memberof PIXI.DisplayObject#
       * @private
       */
      get trackedPointers() {
        if (this._trackedPointers === undefined) this._trackedPointers = {};
    
        return this._trackedPointers;
      },
    
      /**
       * Map of all tracked pointers, by identifier. Use trackedPointers to access.
       *
       * @private
       * @type {Map<number, InteractionTrackingData>}
       */
      _trackedPointers: undefined
    };
    
    /***/ }),
    /* 67 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    var _generateBlurVertSource = __webpack_require__(68);
    
    var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);
    
    var _generateBlurFragSource = __webpack_require__(69);
    
    var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);
    
    var _getMaxBlurKernelSize = __webpack_require__(70);
    
    var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * The BlurXFilter applies a horizontal Gaussian blur to an object.
     *
     * @class
     * @extends PIXI.Filter
     * @memberof PIXI.filters
     */
    var BlurXFilter = function (_core$Filter) {
        _inherits(BlurXFilter, _core$Filter);
    
        /**
         * @param {number} strength - The strength of the blur filter.
         * @param {number} quality - The quality of the blur filter.
         * @param {number} resolution - The resolution of the blur filter.
         * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
         */
        function BlurXFilter(strength, quality, resolution, kernelSize) {
            _classCallCheck(this, BlurXFilter);
    
            kernelSize = kernelSize || 5;
            var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, true);
            var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize);
    
            var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
            // vertex shader
            vertSrc,
            // fragment shader
            fragSrc));
    
            _this.resolution = resolution || core.settings.RESOLUTION;
    
            _this._quality = 0;
    
            _this.quality = quality || 4;
            _this.strength = strength || 8;
    
            _this.firstRun = true;
            return _this;
        }
    
        /**
         * Applies the filter.
         *
         * @param {PIXI.FilterManager} filterManager - The manager.
         * @param {PIXI.RenderTarget} input - The input target.
         * @param {PIXI.RenderTarget} output - The output target.
         * @param {boolean} clear - Should the output be cleared before rendering?
         */
    
    
        BlurXFilter.prototype.apply = function apply(filterManager, input, output, clear) {
            if (this.firstRun) {
                var gl = filterManager.renderer.gl;
                var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);
    
                this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, true);
                this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);
    
                this.firstRun = false;
            }
    
            this.uniforms.strength = 1 / output.size.width * (output.size.width / input.size.width);
    
            // screen space!
            this.uniforms.strength *= this.strength;
            this.uniforms.strength /= this.passes; // / this.passes//Math.pow(1, this.passes);
    
            if (this.passes === 1) {
                filterManager.applyFilter(this, input, output, clear);
            } else {
                var renderTarget = filterManager.getRenderTarget(true);
                var flip = input;
                var flop = renderTarget;
    
                for (var i = 0; i < this.passes - 1; i++) {
                    filterManager.applyFilter(this, flip, flop, true);
    
                    var temp = flop;
    
                    flop = flip;
                    flip = temp;
                }
    
                filterManager.applyFilter(this, flip, output, clear);
    
                filterManager.returnRenderTarget(renderTarget);
            }
        };
    
        /**
         * Sets the strength of both the blur.
         *
         * @member {number}
         * @default 16
         */
    
    
        _createClass(BlurXFilter, [{
            key: 'blur',
            get: function get() {
                return this.strength;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.padding = Math.abs(value) * 2;
                this.strength = value;
            }
    
            /**
            * Sets the quality of the blur by modifying the number of passes. More passes means higher
            * quaility bluring but the lower the performance.
            *
            * @member {number}
            * @default 4
            */
    
        }, {
            key: 'quality',
            get: function get() {
                return this._quality;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this._quality = value;
                this.passes = value;
            }
        }]);
    
        return BlurXFilter;
    }(core.Filter);
    
    exports.default = BlurXFilter;
    
    /***/ }),
    /* 68 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = generateVertBlurSource;
    var vertTemplate = ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform float strength;', 'uniform mat3 projectionMatrix;', 'varying vec2 vBlurTexCoords[%size%];', 'void main(void)', '{', 'gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);', '%blur%', '}'].join('\n');
    
    function generateVertBlurSource(kernelSize, x) {
        var halfLength = Math.ceil(kernelSize / 2);
    
        var vertSource = vertTemplate;
    
        var blurLoop = '';
        var template = void 0;
        // let value;
    
        if (x) {
            template = 'vBlurTexCoords[%index%] = aTextureCoord + vec2(%sampleIndex% * strength, 0.0);';
        } else {
            template = 'vBlurTexCoords[%index%] = aTextureCoord + vec2(0.0, %sampleIndex% * strength);';
        }
    
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i);
    
            // value = i;
    
            // if(i >= halfLength)
            // {
            //     value = kernelSize - i - 1;
            // }
    
            blur = blur.replace('%sampleIndex%', i - (halfLength - 1) + '.0');
    
            blurLoop += blur;
            blurLoop += '\n';
        }
    
        vertSource = vertSource.replace('%blur%', blurLoop);
        vertSource = vertSource.replace('%size%', kernelSize);
    
        return vertSource;
    }
    
    /***/ }),
    /* 69 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = generateFragBlurSource;
    var GAUSSIAN_VALUES = {
        5: [0.153388, 0.221461, 0.250301],
        7: [0.071303, 0.131514, 0.189879, 0.214607],
        9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
        11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
        13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
        15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
    };
    
    var fragTemplate = ['varying vec2 vBlurTexCoords[%size%];', 'uniform sampler2D uSampler;', 'void main(void)', '{', '    gl_FragColor = vec4(0.0);', '    %blur%', '}'].join('\n');
    
    function generateFragBlurSource(kernelSize) {
        var kernel = GAUSSIAN_VALUES[kernelSize];
        var halfLength = kernel.length;
    
        var fragSource = fragTemplate;
    
        var blurLoop = '';
        var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
        var value = void 0;
    
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i);
    
            value = i;
    
            if (i >= halfLength) {
                value = kernelSize - i - 1;
            }
    
            blur = blur.replace('%value%', kernel[value]);
    
            blurLoop += blur;
            blurLoop += '\n';
        }
    
        fragSource = fragSource.replace('%blur%', blurLoop);
        fragSource = fragSource.replace('%size%', kernelSize);
    
        return fragSource;
    }
    
    /***/ }),
    /* 70 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = getMaxKernelSize;
    function getMaxKernelSize(gl) {
        var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        var kernelSize = 15;
    
        while (kernelSize > maxVaryings) {
            kernelSize -= 2;
        }
    
        return kernelSize;
    }
    
    /***/ }),
    /* 71 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    var _generateBlurVertSource = __webpack_require__(68);
    
    var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);
    
    var _generateBlurFragSource = __webpack_require__(69);
    
    var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);
    
    var _getMaxBlurKernelSize = __webpack_require__(70);
    
    var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * The BlurYFilter applies a horizontal Gaussian blur to an object.
     *
     * @class
     * @extends PIXI.Filter
     * @memberof PIXI.filters
     */
    var BlurYFilter = function (_core$Filter) {
        _inherits(BlurYFilter, _core$Filter);
    
        /**
         * @param {number} strength - The strength of the blur filter.
         * @param {number} quality - The quality of the blur filter.
         * @param {number} resolution - The resolution of the blur filter.
         * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
         */
        function BlurYFilter(strength, quality, resolution, kernelSize) {
            _classCallCheck(this, BlurYFilter);
    
            kernelSize = kernelSize || 5;
            var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, false);
            var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize);
    
            var _this = _possibleConstructorReturn(this, _core$Filter.call(this,
            // vertex shader
            vertSrc,
            // fragment shader
            fragSrc));
    
            _this.resolution = resolution || core.settings.RESOLUTION;
    
            _this._quality = 0;
    
            _this.quality = quality || 4;
            _this.strength = strength || 8;
    
            _this.firstRun = true;
            return _this;
        }
    
        /**
         * Applies the filter.
         *
         * @param {PIXI.FilterManager} filterManager - The manager.
         * @param {PIXI.RenderTarget} input - The input target.
         * @param {PIXI.RenderTarget} output - The output target.
         * @param {boolean} clear - Should the output be cleared before rendering?
         */
    
    
        BlurYFilter.prototype.apply = function apply(filterManager, input, output, clear) {
            if (this.firstRun) {
                var gl = filterManager.renderer.gl;
                var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);
    
                this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, false);
                this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);
    
                this.firstRun = false;
            }
    
            this.uniforms.strength = 1 / output.size.height * (output.size.height / input.size.height);
    
            this.uniforms.strength *= this.strength;
            this.uniforms.strength /= this.passes;
    
            if (this.passes === 1) {
                filterManager.applyFilter(this, input, output, clear);
            } else {
                var renderTarget = filterManager.getRenderTarget(true);
                var flip = input;
                var flop = renderTarget;
    
                for (var i = 0; i < this.passes - 1; i++) {
                    filterManager.applyFilter(this, flip, flop, true);
    
                    var temp = flop;
    
                    flop = flip;
                    flip = temp;
                }
    
                filterManager.applyFilter(this, flip, output, clear);
    
                filterManager.returnRenderTarget(renderTarget);
            }
        };
    
        /**
         * Sets the strength of both the blur.
         *
         * @member {number}
         * @default 2
         */
    
    
        _createClass(BlurYFilter, [{
            key: 'blur',
            get: function get() {
                return this.strength;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.padding = Math.abs(value) * 2;
                this.strength = value;
            }
    
            /**
             * Sets the quality of the blur by modifying the number of passes. More passes means higher
             * quaility bluring but the lower the performance.
             *
             * @member {number}
             * @default 4
             */
    
        }, {
            key: 'quality',
            get: function get() {
                return this._quality;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this._quality = value;
                this.passes = value;
            }
        }]);
    
        return BlurYFilter;
    }(core.Filter);
    
    exports.default = BlurYFilter;
    
    /***/ }),
    /* 72 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    exports.default = function () {
        return function spritesheetParser(resource, next) {
            var imageResourceName = resource.name + '_image';
    
            // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists
            if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.JSON || !resource.data.frames || this.resources[imageResourceName]) {
                next();
    
                return;
            }
    
            var loadOptions = {
                crossOrigin: resource.crossOrigin,
                loadType: _resourceLoader.Resource.LOAD_TYPE.IMAGE,
                metadata: resource.metadata.imageMetadata,
                parentResource: resource
            };
    
            var resourcePath = getResourcePath(resource, this.baseUrl);
    
            // load the image for this sheet
            this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
                var spritesheet = new _core.Spritesheet(res.texture.baseTexture, resource.data, resource.url);
    
                spritesheet.parse(function () {
                    resource.spritesheet = spritesheet;
                    resource.textures = spritesheet.textures;
                    next();
                });
            });
        };
    };
    
    exports.getResourcePath = getResourcePath;
    
    var _resourceLoader = __webpack_require__(18);
    
    var _url = __webpack_require__(49);
    
    var _url2 = _interopRequireDefault(_url);
    
    var _core = __webpack_require__(4);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function getResourcePath(resource, baseUrl) {
        // Prepend url path unless the resource image is a data url
        if (resource.isDataUrl) {
            return resource.data.meta.image;
        }
    
        return _url2.default.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);
    }
    
    /***/ }),
    /* 73 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
    
    var MiniSignalBinding = (function () {
      function MiniSignalBinding(fn, once, thisArg) {
        if (once === undefined) once = false;
    
        _classCallCheck(this, MiniSignalBinding);
    
        this._fn = fn;
        this._once = once;
        this._thisArg = thisArg;
        this._next = this._prev = this._owner = null;
      }
    
      _createClass(MiniSignalBinding, [{
        key: 'detach',
        value: function detach() {
          if (this._owner === null) return false;
          this._owner.detach(this);
          return true;
        }
      }]);
    
      return MiniSignalBinding;
    })();
    
    function _addMiniSignalBinding(self, node) {
      if (!self._head) {
        self._head = node;
        self._tail = node;
      } else {
        self._tail._next = node;
        node._prev = self._tail;
        self._tail = node;
      }
    
      node._owner = self;
    
      return node;
    }
    
    var MiniSignal = (function () {
      function MiniSignal() {
        _classCallCheck(this, MiniSignal);
    
        this._head = this._tail = undefined;
      }
    
      _createClass(MiniSignal, [{
        key: 'handlers',
        value: function handlers() {
          var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
    
          var node = this._head;
    
          if (exists) return !!node;
    
          var ee = [];
    
          while (node) {
            ee.push(node);
            node = node._next;
          }
    
          return ee;
        }
      }, {
        key: 'has',
        value: function has(node) {
          if (!(node instanceof MiniSignalBinding)) {
            throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.');
          }
    
          return node._owner === this;
        }
      }, {
        key: 'dispatch',
        value: function dispatch() {
          var node = this._head;
    
          if (!node) return false;
    
          while (node) {
            if (node._once) this.detach(node);
            node._fn.apply(node._thisArg, arguments);
            node = node._next;
          }
    
          return true;
        }
      }, {
        key: 'add',
        value: function add(fn) {
          var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    
          if (typeof fn !== 'function') {
            throw new Error('MiniSignal#add(): First arg must be a Function.');
          }
          return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
        }
      }, {
        key: 'once',
        value: function once(fn) {
          var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    
          if (typeof fn !== 'function') {
            throw new Error('MiniSignal#once(): First arg must be a Function.');
          }
          return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
        }
      }, {
        key: 'detach',
        value: function detach(node) {
          if (!(node instanceof MiniSignalBinding)) {
            throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.');
          }
          if (node._owner !== this) return this;
    
          if (node._prev) node._prev._next = node._next;
          if (node._next) node._next._prev = node._prev;
    
          if (node === this._head) {
            this._head = node._next;
            if (node._next === null) {
              this._tail = null;
            }
          } else if (node === this._tail) {
            this._tail = node._prev;
            this._tail._next = null;
          }
    
          node._owner = null;
          return this;
        }
      }, {
        key: 'detachAll',
        value: function detachAll() {
          var node = this._head;
          if (!node) return this;
    
          this._head = this._tail = null;
    
          while (node) {
            node._owner = null;
            node = node._next;
          }
          return this;
        }
      }]);
    
      return MiniSignal;
    })();
    
    MiniSignal.MiniSignalBinding = MiniSignalBinding;
    
    exports['default'] = MiniSignal;
    module.exports = exports['default'];
    
    
    /***/ }),
    /* 74 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    module.exports = function parseURI (str, opts) {
      opts = opts || {}
    
      var o = {
        key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
        q: {
          name: 'queryKey',
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      }
    
      var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)
      var uri = {}
      var i = 14
    
      while (i--) uri[o.key[i]] = m[i] || ''
    
      uri[o.q.name] = {}
      uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
        if ($1) uri[o.q.name][$1] = $2
      })
    
      return uri
    }
    
    
    /***/ }),
    /* 75 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.eachSeries = eachSeries;
    exports.queue = queue;
    /**
     * Smaller version of the async library constructs.
     *
     */
    function _noop() {} /* empty */
    
    /**
     * Iterates an array in series.
     *
     * @param {Array.<*>} array - Array to iterate.
     * @param {function} iterator - Function to call for each element.
     * @param {function} callback - Function to call when done, or on error.
     * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.
     */
    function eachSeries(array, iterator, callback, deferNext) {
        var i = 0;
        var len = array.length;
    
        (function next(err) {
            if (err || i === len) {
                if (callback) {
                    callback(err);
                }
    
                return;
            }
    
            if (deferNext) {
                setTimeout(function () {
                    iterator(array[i++], next);
                }, 1);
            } else {
                iterator(array[i++], next);
            }
        })();
    }
    
    /**
     * Ensures a function is only called once.
     *
     * @param {function} fn - The function to wrap.
     * @return {function} The wrapping function.
     */
    function onlyOnce(fn) {
        return function onceWrapper() {
            if (fn === null) {
                throw new Error('Callback was already called.');
            }
    
            var callFn = fn;
    
            fn = null;
            callFn.apply(this, arguments);
        };
    }
    
    /**
     * Async queue implementation,
     *
     * @param {function} worker - The worker function to call for each task.
     * @param {number} concurrency - How many workers to run in parrallel.
     * @return {*} The async queue object.
     */
    function queue(worker, concurrency) {
        if (concurrency == null) {
            // eslint-disable-line no-eq-null,eqeqeq
            concurrency = 1;
        } else if (concurrency === 0) {
            throw new Error('Concurrency must not be zero');
        }
    
        var workers = 0;
        var q = {
            _tasks: [],
            concurrency: concurrency,
            saturated: _noop,
            unsaturated: _noop,
            buffer: concurrency / 4,
            empty: _noop,
            drain: _noop,
            error: _noop,
            started: false,
            paused: false,
            push: function push(data, callback) {
                _insert(data, false, callback);
            },
            kill: function kill() {
                workers = 0;
                q.drain = _noop;
                q.started = false;
                q._tasks = [];
            },
            unshift: function unshift(data, callback) {
                _insert(data, true, callback);
            },
            process: function process() {
                while (!q.paused && workers < q.concurrency && q._tasks.length) {
                    var task = q._tasks.shift();
    
                    if (q._tasks.length === 0) {
                        q.empty();
                    }
    
                    workers += 1;
    
                    if (workers === q.concurrency) {
                        q.saturated();
                    }
    
                    worker(task.data, onlyOnce(_next(task)));
                }
            },
            length: function length() {
                return q._tasks.length;
            },
            running: function running() {
                return workers;
            },
            idle: function idle() {
                return q._tasks.length + workers === 0;
            },
            pause: function pause() {
                if (q.paused === true) {
                    return;
                }
    
                q.paused = true;
            },
            resume: function resume() {
                if (q.paused === false) {
                    return;
                }
    
                q.paused = false;
    
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= q.concurrency; w++) {
                    q.process();
                }
            }
        };
    
        function _insert(data, insertAtFront, callback) {
            if (callback != null && typeof callback !== 'function') {
                // eslint-disable-line no-eq-null,eqeqeq
                throw new Error('task callback must be a function');
            }
    
            q.started = true;
    
            if (data == null && q.idle()) {
                // eslint-disable-line no-eq-null,eqeqeq
                // call drain immediately if there are no tasks
                setTimeout(function () {
                    return q.drain();
                }, 1);
    
                return;
            }
    
            var item = {
                data: data,
                callback: typeof callback === 'function' ? callback : _noop
            };
    
            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }
    
            setTimeout(function () {
                return q.process();
            }, 1);
        }
    
        function _next(task) {
            return function next() {
                workers -= 1;
    
                task.callback.apply(task, arguments);
    
                if (arguments[0] != null) {
                    // eslint-disable-line no-eq-null,eqeqeq
                    q.error(arguments[0], task.data);
                }
    
                if (workers <= q.concurrency - q.buffer) {
                    q.unsaturated();
                }
    
                if (q.idle()) {
                    q.drain();
                }
    
                q.process();
            };
        }
    
        return q;
    }
    //# sourceMappingURL=async.js.map
    
    /***/ }),
    /* 76 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.encodeBinary = encodeBinary;
    var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    
    function encodeBinary(input) {
        var output = '';
        var inx = 0;
    
        while (inx < input.length) {
            // Fill byte buffer array
            var bytebuffer = [0, 0, 0];
            var encodedCharIndexes = [0, 0, 0, 0];
    
            for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
                if (inx < input.length) {
                    // throw away high-order byte, as documented at:
                    // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data
                    bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;
                } else {
                    bytebuffer[jnx] = 0;
                }
            }
    
            // Get each encoded character, 6 bits at a time
            // index 1: first 6 bits
            encodedCharIndexes[0] = bytebuffer[0] >> 2;
    
            // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)
            encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4;
    
            // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)
            encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6;
    
            // index 3: forth 6 bits (6 least significant bits from input byte 3)
            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;
    
            // Determine whether padding happened, and adjust accordingly
            var paddingBytes = inx - (input.length - 1);
    
            switch (paddingBytes) {
                case 2:
                    // Set last 2 characters to padding char
                    encodedCharIndexes[3] = 64;
                    encodedCharIndexes[2] = 64;
                    break;
    
                case 1:
                    // Set last character to padding char
                    encodedCharIndexes[3] = 64;
                    break;
    
                default:
                    break; // No padding - proceed
            }
    
            // Now we will grab each appropriate character out of our keystring
            // based on our index array and append it to the output string
            for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {
                output += _keyStr.charAt(encodedCharIndexes[_jnx]);
            }
        }
    
        return output;
    }
    //# sourceMappingURL=b64.js.map
    
    /***/ }),
    /* 77 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    exports.default = function () {
        return function textureParser(resource, next) {
            // create a new texture if the data is an Image object
            if (resource.data && resource.type === _resourceLoader.Resource.TYPE.IMAGE) {
                resource.texture = _Texture2.default.fromLoader(resource.data, resource.url, resource.name);
            }
            next();
        };
    };
    
    var _resourceLoader = __webpack_require__(18);
    
    var _Texture = __webpack_require__(8);
    
    var _Texture2 = _interopRequireDefault(_Texture);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /***/ }),
    /* 78 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _logoLayer = __webpack_require__(159);
    
    var _logoLayer2 = _interopRequireDefault(_logoLayer);
    
    var _logoLayer3 = __webpack_require__(170);
    
    var _logoLayer4 = _interopRequireDefault(_logoLayer3);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var spritesheetTilemap = "assets/layers/layers.json";
    
    var LogoTexture = function () {
        function LogoTexture(app, size, onReady) {
            _classCallCheck(this, LogoTexture);
    
            this.size = size || 300;
            this.renderer = app.renderer;
            this.isReady = false;
    
            this.layers = {};
            this.textureContainer = null;
            this.resultTexture = null;
    
            this.init(onReady);
        }
    
        LogoTexture.prototype.init = function init(onReady) {
            var self = this;
            PIXI.loader.add("spritesheet", spritesheetTilemap).load(function (loader, resources) {
                self.prepareLayers(resources.spritesheet);
                self.setupResultTexture();
                self.isReady = true;
                if (typeof onReady === "function") {
                    onReady();
                }
            });
        };
    
        LogoTexture.prototype.isCanvas = function isCanvas() {
            return this.renderer instanceof PIXI.CanvasRenderer;
        };
    
        LogoTexture.prototype.prepareLayers = function prepareLayers(spritesheet) {
            var textures = spritesheet.textures;
            var frames = spritesheet.data.frames;
            var LogoLayer = this.isCanvas() ? _logoLayer2.default : _logoLayer4.default;
            var rotationStep = Math.PI * 2 / frames.length;
            var currentRotation = 0;
            for (var key in textures) {
                var frameId = parseInt(key);
                var name = frames[frameId].filename.toLowerCase();
                var isBackground = name.startsWith("background");
                var layer = new LogoLayer(textures[key], this.size, this.renderer);
                if (isBackground) {
                    layer.color = 0x999999;
                    layer.alpha = 100.0;
                } else {
                    layer.alpha = 50.0;
                }
                layer.initRotation = currentRotation;
                this.layers[name] = layer;
                currentRotation += rotationStep;
            }
        };
    
        LogoTexture.prototype.setupResultTexture = function setupResultTexture() {
            var names = Object.keys(this.layers);
            names.sort(function (a, b) {
                if (a.startsWith("background")) {
                    return -1;
                }
                if (b.startsWith("background")) {
                    return 1;
                }
                return 0;
            });
            this.textureContainer = new PIXI.Container();
            for (var i = 0; i < names.length; i++) {
                var curr = this.layers[names[i]];
                var item = curr.getLayer();
                this.textureContainer.addChild(item);
            }
            var baseTexture = new PIXI.BaseRenderTexture(this.size, this.size, PIXI.SCALE_MODES.LINEAR, 1);
            this.resultTexture = new PIXI.RenderTexture(baseTexture);
            this.renderer.render(this.textureContainer, this.resultTexture);
        };
    
        LogoTexture.prototype.update = function update(deltaTime, time) {
            for (var key in this.layers) {
                this.layers[key].update(deltaTime, time);
            }
            this.renderer.render(this.textureContainer, this.resultTexture);
        };
    
        LogoTexture.prototype.get = function get() {
            return this.resultTexture;
        };
    
        LogoTexture.prototype.getState = function getState() {
            var state = {};
            for (var key in this.layers) {
                var layer = this.layers[key];
                state[key] = layer.getState();
            }
            return state;
        };
    
        LogoTexture.prototype.setState = function setState(settings) {
            if (!settings) {
                return;
            }
            for (var key in this.layers) {
                var layerSettings = settings[key];
                if (!layerSettings) {
                    continue;
                }
                var layer = this.layers[key];
                layer.setState(layerSettings);
            }
        };
    
        LogoTexture.prototype.transitTo = function transitTo(state, duration, delay, easeType) {
            if (!state) {
                return;
            }
            for (var key in this.layers) {
                var layerState = state[key];
                if (!layerState) {
                    continue;
                }
                var layer = this.layers[key];
                layer.transitTo(layerState, duration, delay, easeType);
            }
        };
    
        return LogoTexture;
    }();
    
    exports.default = LogoTexture;
    
    /***/ }),
    /* 79 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _transition = __webpack_require__(20);
    
    var _transition2 = _interopRequireDefault(_transition);
    
    var _rotatablePoint = __webpack_require__(33);
    
    var _rotatablePoint2 = _interopRequireDefault(_rotatablePoint);
    
    var _layer = __webpack_require__(80);
    
    var _layer2 = _interopRequireDefault(_layer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function paceSpeedConvert(value) {
        if (!value) {
            return 0;
        }
        return 100 * Math.PI / (value * 3);
    }
    
    var LogoLayer = function () {
        function LogoLayer(texture, size) {
            _classCallCheck(this, LogoLayer);
    
            this.source = new PIXI.Sprite(texture);
    
            this._speed = 0;
            this._pivot = null;
    
            this.setupPivot(size);
            this.setup(size);
        }
    
        LogoLayer.prototype.setupPivot = function setupPivot(size) {
            var baseRadius = size / 2;
            this._pivot = new _rotatablePoint2.default({ x: baseRadius, y: baseRadius }, /* starting point */
            baseRadius /* base radius*/
            );
        };
    
        LogoLayer.prototype.setup = function setup(size) {
            var scaleFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    
            this.source.x = size / 2;
            this.source.y = size / 2;
            this.source.width = size;
            this.source.height = size;
            this.source.anchor.set(0.5);
            this.source.scale.x *= scaleFactor;
            this.source.scale.y *= scaleFactor;
            this.originScale = {
                x: this.source.scale.x,
                y: this.source.scale.y
            };
            this.tintColor = new _layer2.default(this.source.tint);
            this._initRotation = this.source.rotation;
        };
    
        LogoLayer.prototype.update = function update(deltaTime, time) {
            this._makeTransition(deltaTime, time);
            // rotate around center
            this._updatePivot(deltaTime);
            // rotate around itself
            if (deltaTime && this.speed) {
                var delta = deltaTime * this.speed;
                this._rotate(delta);
            }
        };
    
        LogoLayer.prototype.getLayer = function getLayer() {
            return this.source;
        };
    
        LogoLayer.prototype.getState = function getState() {
            return {
                alpha: this.alpha,
                color: this.color.toString(),
                blur: this.blur,
                scale: this.scale,
                initRotation: this.initRotation,
                speed: this.speed,
                pivot: this._pivot.getState()
            };
        };
    
        LogoLayer.prototype.setState = function setState(settings) {
            if (!settings) {
                return;
            }
    
            this._pivot.setState(settings.pivot);
    
            this.alpha = settings.alpha;
            this.color = settings.color;
            this.blur = settings.blur;
            this.scale = settings.scale;
            this.initRotation = settings.initRotation;
            this.speed = settings.speed;
        };
    
        LogoLayer.prototype.transitTo = function transitTo(state, duration, delay, easeType) {
            if (!state) {
                return;
            }
            if (typeof this.pivot.transitTo === "function") {
                this.pivot.transitTo(state.pivot, duration, delay);
            }
            var transition = new _transition2.default(this, duration, delay, easeType);
            for (var key in state) {
                if (key === "pivot") {
                    continue;
                }
                if (key === "color") {
                    var targetColor = new _layer2.default(state.color).toRgb();
                    transition.tween("colorRGB", targetColor);
                } else if (key === "initRotation") {
                    transition.tweenRotation(key, state[key]);
                } else {
                    transition.tween(key, state[key]);
                }
            }
        };
    
        LogoLayer.prototype._makeTransition = function _makeTransition(deltaTime) {
            if (!this.__transition) {
                return;
            }
            this.__transition.tick(deltaTime);
        };
    
        LogoLayer.prototype._rotate = function _rotate(delta) {
            var newRotation = this.source.rotation + delta;
            this.source.rotation = newRotation;
        };
    
        LogoLayer.prototype._updatePivot = function _updatePivot(deltaTime) {
            this._pivot.update(deltaTime);
            this.source.x = this._pivot.x;
            this.source.y = this._pivot.y;
        };
    
        LogoLayer.prototype.applyTint = function applyTint() {/* do nothing. Should be overriden */};
    
        _createClass(LogoLayer, [{
            key: "alpha",
            get: function get() {
                return this.source.alpha * 100;
            },
            set: function set(val) {
                this.source.alpha = val / 100;
            }
        }, {
            key: "initRotation",
            get: function get() {
                return this._initRotation;
            },
            set: function set(val) {
                var newRotation = val || 0;
                var delta = newRotation - this._initRotation;
                this._rotate(delta);
                this._initRotation = newRotation;
            }
        }, {
            key: "scale",
            get: function get() {
                return this.source.scale.x / this.originScale.x;
            },
            set: function set(val) {
                var factor = val;
                this.source.scale = {
                    x: this.originScale.x * factor,
                    y: this.originScale.y * factor
                };
            }
        }, {
            key: "color",
            get: function get() {
                return this.tintColor;
            },
            set: function set(val) {
                this.tintColor = val instanceof _layer2.default ? val : new _layer2.default(val);
                this.applyTint();
            }
        }, {
            key: "colorRGB",
            get: function get() {
                var rgb = this.tintColor.toRgb();
                return rgb;
            },
            set: function set(val) {
                this.tintColor = _layer2.default.fromRgb(val);
                this.applyTint();
            }
        }, {
            key: "colorHSV",
            get: function get() {
                var rgb = this.tintColor.toHsv();
                return rgb;
            },
            set: function set(val) {
                this.tintColor = _layer2.default.fromHsv(val);
                this.applyTint();
            }
        }, {
            key: "pivot",
            get: function get() {
                return this._pivot;
            }
        }, {
            key: "speed",
            get: function get() {
                return this._speed;
            },
            set: function set(value) {
                this._speed = value || 0;
            }
        }, {
            key: "pace",
            get: function get() {
                return paceSpeedConvert(this._speed);
            },
            set: function set(value) {
                this._speed = paceSpeedConvert(value);
            }
        }, {
            key: "blur",
            get: function get() {
                return 0;
            },
            set: function set(val) {/* do nothing */}
        }]);
    
        return LogoLayer;
    }();
    
    exports.default = LogoLayer;
    
    /***/ }),
    /* 80 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function hexToRbg(color) {
        var red = color >> 16 & 255;
        var green = color >> 8 & 255;
        var blue = color & 255;
        return { r: red, g: green, b: blue };
    }
    
    function rgbToHsv(rgb) {
        var min = Math.min(rgb.r, rgb.g, rgb.b);
        var max = Math.max(rgb.r, rgb.g, rgb.b);
        var delta = max - min;
        var hsv = {
            h: 0,
            s: 0,
            v: max / 255.0
        };
        if (max !== 0) {
            hsv.s = delta / max;
            if (rgb.r === max) {
                hsv.h = (rgb.g - rgb.b) / delta;
            } else if (rgb.g === max) {
                hsv.h = 2.0 + (rgb.b - rgb.r) / delta;
            } else if (rgb.b === max) {
                hsv.h = 4.0 + (rgb.r - rgb.g) / delta;
            }
            hsv.h *= 60;
            if (hsv.h < 0) {
                hsv.h += 360;
            }
        }
        return hsv;
    }
    
    function hsvToRgb(hsv) {
        var v = hsv.v * 255;
        var rgb = {
            r: v,
            g: v,
            b: v
        };
        if (hsv.s === 0) {
            return rgb;
        }
        var h = hsv.h;
        var s = hsv.s;
        if (h < 0) {
            h += 360;
        } else if (hsv.h >= 360) {
            h -= 360;
        }
        h /= 60;
        var i = Math.floor(h);
        var f = h - i;
        var p = v * (1 - s);
        var q = v * (1 - s * f);
        var t = v * (1 - s * (1 - f));
        switch (i) {
            case 0:
                rgb.r = v;
                rgb.g = t;
                rgb.b = p;
                break;
            case 1:
                rgb.r = q;
                rgb.g = v;
                rgb.b = p;
                break;
            case 2:
                rgb.r = p;
                rgb.g = v;
                rgb.b = t;
                break;
            case 3:
                rgb.r = p;
                rgb.g = q;
                rgb.b = v;
                break;
            case 4:
                rgb.r = t;
                rgb.g = p;
                rgb.b = v;
                break;
            case 5:
                rgb.r = v;
                rgb.g = p;
                rgb.b = q;
                break;
        }
        return rgb;
    }
    
    function rgbToHex(rgb) {
        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }
    
    var LayerColor = function () {
        function LayerColor(color) {
            _classCallCheck(this, LayerColor);
    
            if (typeof color === "string" && color[0] === "#") {
                color = parseInt(color.substr(1), 16);
            }
            this.color = color || 0xffffff;
            this.rgb = null;
            this.hsl = null;
        }
    
        LayerColor.prototype.toRgb = function toRgb() {
            if (!!this.rgb) {
                return this.rgb;
            }
            this.rgb = hexToRbg(this.color);
            return this.rgb;
        };
    
        LayerColor.prototype.toHsv = function toHsv() {
            if (!!this.hsl) {
                return this.hsl;
            }
            if (!this.rgb) {
                this.rgb = hexToRbg(this.color);
            }
            this.hsl = rgbToHsv(this.rgb);
            return this.hsl;
        };
    
        LayerColor.prototype.toHex = function toHex() {
            return this.color;
        };
    
        LayerColor.fromHsv = function fromHsv(hsv) {
            var rgb = hsvToRgb(hsv);
            var hex = rgbToHex(rgb);
            var color = new LayerColor(hex);
            color.hsl = hsv;
            color.rgb = rgb;
            return color;
        };
    
        LayerColor.fromRgb = function fromRgb(rgb) {
            var hex = rgbToHex(rgb);
            var color = new LayerColor(hex);
            color.rgb = rgb;
            return color;
        };
    
        LayerColor.prototype.toString = function toString() {
            return "#" + this.color.toString(16);
        };
    
        return LayerColor;
    }();
    
    exports.default = LayerColor;
    
    /***/ }),
    /* 81 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _mesh = __webpack_require__(171);
    
    var _logoShape = __webpack_require__(176);
    
    var _logoShape2 = _interopRequireDefault(_logoShape);
    
    var _logoShape3 = __webpack_require__(183);
    
    var _logoShape4 = _interopRequireDefault(_logoShape3);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var vertices = new Float32Array([0, 0, 11.11, 0, 22.22, 0, 33.33, 0, 44.44, 0, 55.56, 0, 66.67, 0, 77.78, 0, 88.89, 0, 100, 0, 0, 11.11, 11.11, 11.11, 22.22, 11.11, 33.33, 11.11, 44.44, 11.11, 55.56, 11.11, 66.67, 11.11, 77.78, 11.11, 88.89, 11.11, 100, 11.11, 0, 22.22, 11.11, 22.22, 22.22, 22.22, 33.33, 22.22, 44.44, 22.22, 55.56, 22.22, 66.67, 22.22, 77.78, 22.22, 88.89, 22.22, 100, 22.22, 0, 33.33, 11.11, 33.33, 22.22, 33.33, 33.33, 33.33, 44.44, 33.33, 55.56, 33.33, 66.67, 33.33, 77.78, 33.33, 88.89, 33.33, 100, 33.33, 0, 44.44, 11.11, 44.44, 22.22, 44.44, 33.33, 44.44, 44.44, 44.44, 55.56, 44.44, 66.67, 44.44, 77.78, 44.44, 88.89, 44.44, 100, 44.44, 0, 55.56, 11.11, 55.56, 22.22, 55.56, 33.33, 55.56, 44.44, 55.56, 55.56, 55.56, 66.67, 55.56, 77.78, 55.56, 88.89, 55.56, 100, 55.56, 0, 66.67, 11.11, 66.67, 22.22, 66.67, 33.33, 66.67, 44.44, 66.67, 55.56, 66.67, 66.67, 66.67, 77.78, 66.67, 88.89, 66.67, 100, 66.67, 0, 77.78, 11.11, 77.78, 22.22, 77.78, 33.33, 77.78, 44.44, 77.78, 55.56, 77.78, 66.67, 77.78, 77.78, 77.78, 88.89, 77.78, 100, 77.78, 0, 88.89, 11.11, 88.89, 22.22, 88.89, 33.33, 88.89, 44.44, 88.89, 55.56, 88.89, 66.67, 88.89, 77.78, 88.89, 88.89, 88.89, 100, 88.89, 0, 100, 11.11, 100, 22.22, 100, 33.33, 100, 44.44, 100, 55.56, 100, 66.67, 100, 77.78, 100, 88.89, 100, 100, 100]);
    
    var uvs = vertices.slice().map(function (x) {
        return x / 100;
    });
    var inds = new Uint16Array([0, 1, 10, 1, 11, 10, 1, 2, 11, 2, 12, 11, 2, 3, 12, 3, 13, 12, 3, 4, 13, 4, 14, 13, 4, 5, 14, 5, 15, 14, 5, 6, 15, 6, 16, 15, 6, 7, 16, 7, 17, 16, 7, 8, 17, 8, 18, 17, 8, 9, 18, 9, 19, 18, 10, 11, 20, 11, 21, 20, 11, 12, 21, 12, 22, 21, 12, 13, 22, 13, 23, 22, 13, 14, 23, 14, 24, 23, 14, 15, 24, 15, 25, 24, 15, 16, 25, 16, 26, 25, 16, 17, 26, 17, 27, 26, 17, 18, 27, 18, 28, 27, 18, 19, 28, 19, 29, 28, 20, 21, 30, 21, 31, 30, 21, 22, 31, 22, 32, 31, 22, 23, 32, 23, 33, 32, 23, 24, 33, 24, 34, 33, 24, 25, 34, 25, 35, 34, 25, 26, 35, 26, 36, 35, 26, 27, 36, 27, 37, 36, 27, 28, 37, 28, 38, 37, 28, 29, 38, 29, 39, 38, 30, 31, 40, 31, 41, 40, 31, 32, 41, 32, 42, 41, 32, 33, 42, 33, 43, 42, 33, 34, 43, 34, 44, 43, 34, 35, 44, 35, 45, 44, 35, 36, 45, 36, 46, 45, 36, 37, 46, 37, 47, 46, 37, 38, 47, 38, 48, 47, 38, 39, 48, 39, 49, 48, 40, 41, 50, 41, 51, 50, 41, 42, 51, 42, 52, 51, 42, 43, 52, 43, 53, 52, 43, 44, 53, 44, 54, 53, 44, 45, 54, 45, 55, 54, 45, 46, 55, 46, 56, 55, 46, 47, 56, 47, 57, 56, 47, 48, 57, 48, 58, 57, 48, 49, 58, 49, 59, 58, 50, 51, 60, 51, 61, 60, 51, 52, 61, 52, 62, 61, 52, 53, 62, 53, 63, 62, 53, 54, 63, 54, 64, 63, 54, 55, 64, 55, 65, 64, 55, 56, 65, 56, 66, 65, 56, 57, 66, 57, 67, 66, 57, 58, 67, 58, 68, 67, 58, 59, 68, 59, 69, 68, 60, 61, 70, 61, 71, 70, 61, 62, 71, 62, 72, 71, 62, 63, 72, 63, 73, 72, 63, 64, 73, 64, 74, 73, 64, 65, 74, 65, 75, 74, 65, 66, 75, 66, 76, 75, 66, 67, 76, 67, 77, 76, 67, 68, 77, 68, 78, 77, 68, 69, 78, 69, 79, 78, 70, 71, 80, 71, 81, 80, 71, 72, 81, 72, 82, 81, 72, 73, 82, 73, 83, 82, 73, 74, 83, 74, 84, 83, 74, 75, 84, 75, 85, 84, 75, 76, 85, 76, 86, 85, 76, 77, 86, 77, 87, 86, 77, 78, 87, 78, 88, 87, 78, 79, 88, 79, 89, 88, 80, 81, 90, 81, 91, 90, 81, 82, 91, 82, 92, 91, 82, 83, 92, 83, 93, 92, 83, 84, 93, 84, 94, 93, 84, 85, 94, 85, 95, 94, 85, 86, 95, 86, 96, 95, 86, 87, 96, 87, 97, 96, 87, 88, 97, 88, 98, 97, 88, 89, 98, 89, 99, 98]);
    
    var LogoMesh = function () {
        function LogoMesh(texture, app, size) {
            _classCallCheck(this, LogoMesh);
    
            this.isCanvas = app.renderer instanceof PIXI.CanvasRenderer;
    
            this.container = new PIXI.Container();
            this.mesh = null;
            this.texture = null;
            this.background = null;
            this.hitArea = null;
    
            this.init(texture, app, size);
    
            this.state = {
                isHover: false,
                isDragged: false
            };
        }
    
        LogoMesh.prototype.getBackground = function getBackground() {
            return this.background;
        };
    
        LogoMesh.prototype.getMesh = function getMesh() {
            return this.mesh;
        };
    
        LogoMesh.prototype.getShape = function getShape() {
            return this.shape;
        };
    
        LogoMesh.prototype.init = function init(texture, app, size) {
            this.texture = texture;
            this.setupMesh(app, texture.get(), size);
            this.setupBackground();
            this.setupInteractions();
            this.appendToView(app);
            this.setupShape(app);
            this.movement = new _mesh.MeshMovement(this.mesh);
        };
    
        LogoMesh.prototype.update = function update(deltaTime) {
            this.texture.update(deltaTime);
            this.shape.update(deltaTime);
            this.movement.update(deltaTime);
        };
    
        LogoMesh.prototype.reset = function reset() {
            this.mesh.vertices = vertices.slice();
            this.movement.reset(vertices);
        };
    
        LogoMesh.prototype.setupShape = function setupShape(app) {
            // we use LogoShapeCanvas for canvas and webgl
            // because webgl masking looks too sharp
            this.shape = new _logoShape2.default(this.mesh, app);
        };
    
        LogoMesh.prototype.setupMesh = function setupMesh(app, currentTexture, size) {
            this.mesh = new PIXI.mesh.Mesh(currentTexture, vertices.slice(), uvs.slice(), inds.slice(), 1);
    
            if (size) {
                this.mesh.width = size;
                this.mesh.height = size;
            }
        };
    
        LogoMesh.prototype.setupBackground = function setupBackground() {
            if (!this.isCanvas) {
                return;
            }
            this.background = new PIXI.Sprite(this.mesh.texture);
            this.background.height = this.mesh.height;
            this.background.width = this.mesh.width;
            this.background.anchor.set(0.5);
            this.background.x = this.mesh.x + this.mesh.width / 2;
            this.background.y = this.mesh.y + this.mesh.height / 2;
        };
    
        LogoMesh.prototype.setupInteractions = function setupInteractions() {
            var hitRadius = this.mesh.height * 0.38;
            this.hitArea = new PIXI.Graphics();
            this.hitArea.x = this.mesh.x + this.mesh.width / 2;
            this.hitArea.y = this.mesh.y + this.mesh.height / 2;
            this.hitArea.lineStyle(0);
            this.hitArea.beginFill(0xFFFFFF, 0);
            this.hitArea.drawCircle(0, 0, hitRadius);
            this.hitArea.interactive = true;
            this.hitArea.buttonMode = true;
            var self = this;
            this.hitArea.on('pointerdown', function (event) {
                self.startDrag();
            }).on('pointerup', function (event) {
                self.stopDrag();
            }).on('pointerover', function (event) {
                self.startHover();
            }).on('pointerout', function (event) {
                self.stopHover();
                self.stopDrag();
            });
        };
    
        LogoMesh.prototype.startDrag = function startDrag() {
            // todo :: must be implemented
        };
    
        LogoMesh.prototype.stopDrag = function stopDrag() {
            // todo :: must be implemented
        };
    
        LogoMesh.prototype.startHover = function startHover() {
            // todo :: must be implemented
        };
    
        LogoMesh.prototype.stopHover = function stopHover() {
            // todo :: must be implemented
        };
    
        LogoMesh.prototype.appendToView = function appendToView(app) {
    
            if (this.isCanvas) {
                this.container.addChild(this.background);
            }
            this.container.addChild(this.mesh);
            this.container.addChild(this.hitArea);
            app.stage.addChild(this.container);
        };
    
        LogoMesh.prototype.getState = function getState() {
            var state = {
                mesh: this.movement.getState(),
                shape: this.shape.getState(),
                texture: this.texture.getState()
            };
            return state;
        };
    
        LogoMesh.prototype.setState = function setState(settings) {
            if (!settings) {
                return;
            }
            this.shape.setState(settings.shape);
            this.texture.setState(settings.texture);
            this.movement.setState(settings.mesh);
        };
    
        LogoMesh.prototype.transitTo = function transitTo(state, duration, delay, easeType) {
            if (!state) {
                return;
            }
            this.shape.transitTo(state.shape, duration, delay, easeType);
            this.texture.transitTo(state.texture, duration, delay, easeType);
            this.movement.transitTo(state.mesh, duration, delay, easeType);
        };
    
        return LogoMesh;
    }();
    
    exports.default = LogoMesh;
    
    /***/ }),
    /* 82 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _rotatablePoint = __webpack_require__(33);
    
    var _rotatablePoint2 = _interopRequireDefault(_rotatablePoint);
    
    var _bubble = __webpack_require__(177);
    
    var _bubble2 = _interopRequireDefault(_bubble);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var settings = {
        total: 5,
        offsetCoeff: 0.3,
        bubbleMinCoeff: 0.2,
        bubbleDeltaCoeff: 0.1,
        bubblePosCoeff: 1.2,
        moveOffsetCoeff: 1.4,
        shapeProximity: 0.75,
        movementCoeff: 1.25
    };
    
    var LogoShape = function () {
        function LogoShape(mesh, app) {
            _classCallCheck(this, LogoShape);
    
            this.mesh = mesh;
            this.bubbles = [];
    
            this.smoothThreshold = 250;
    
            this.prepareMaskTexture();
            this.generateBubbles();
            this.prepareMetaballizer();
    
            this.setup(app);
        }
    
        LogoShape.prototype.prepareMaskTexture = function prepareMaskTexture() {
            this.height = this.mesh.height;
            this.width = this.mesh.width;
            this.height *= settings.movementCoeff;
            this.width *= settings.movementCoeff;
            var tempCanvas = document.createElement("canvas");
            tempCanvas.height = this.height;
            tempCanvas.width = this.width;
            this.maskContext = tempCanvas.getContext("2d");
            this.maskTexture = PIXI.Texture.fromCanvas(tempCanvas);
        };
    
        LogoShape.prototype.generateBubbles = function generateBubbles() {
            this.bubbles = [];
            var center = new _rotatablePoint2.default({
                x: this.mesh.width / 2,
                y: this.mesh.height / 2
            });
            var maxDistance = Math.min(center.x, center.y) + 2;
            var mainRadius = maxDistance * (1 - settings.offsetCoeff);
            var mainBubble = new _bubble2.default(center, mainRadius);
            this.bubbles.push(mainBubble);
            for (var s = 0; s < settings.total; s++) {
                var bubble = _bubble2.default.getRandom(center, mainRadius);
                this.bubbles.push(bubble);
            }
        };
    
        LogoShape.prototype.prepareMetaballizer = function prepareMetaballizer() {
            // do nothing 
            // should be overriden in extended classes
        };
    
        LogoShape.prototype.setup = function setup(app) {
            this.metaballize();
            this.maskTexture.update();
            this.appendMask(app);
        };
    
        LogoShape.prototype.getOutlineBubbles = function getOutlineBubbles() {
            return !this.bubbles ? [] : this.bubbles.slice(1);
        };
    
        LogoShape.prototype.getBaseShape = function getBaseShape() {
            return !this.bubbles || !this.bubbles.length ? null : this.bubbles[0];
        };
    
        LogoShape.prototype.getBaseShapeSize = function getBaseShapeSize() {
            var metaballsCoeff = 2 - this.smoothThreshold / 255;
            return (1 - settings.offsetCoeff) * metaballsCoeff;
        };
    
        LogoShape.prototype.reset = function reset(app) {
            this.generateBubbles();
            this.cleanupMask();
            this.setup(app);
        };
    
        LogoShape.prototype.show = function show() {
            this.isApplied = true;
        };
    
        LogoShape.prototype.hide = function hide() {
            this.isApplied = false;
            this.setupEmptyMask();
            this.refreshMask();
        };
    
        LogoShape.prototype.appendMask = function appendMask(app) {
            this.isApplied = true;
            // do nothing 
        };
    
        LogoShape.prototype.refreshMask = function refreshMask() {
            //do nothing
        };
    
        LogoShape.prototype._createMask = function _createMask(app) {
            var mask = new PIXI.Sprite(this.maskTexture);
            app.stage.addChild(mask);
            return mask;
        };
    
        LogoShape.prototype.changeDeformer = function changeDeformer(distanceRange, speedRange) {
            for (var b = 1; b < this.bubbles.length; b++) {
                var distance = distanceRange.min + Math.random() * distanceRange.range;
                var speed = speedRange.min + Math.random() * speedRange.range;
                this.bubbles[b].changeMovement({ range: distance, speed: speed });
            }
        };
    
        LogoShape.prototype.removeDeformer = function removeDeformer() {
            for (var b = 1; b < this.bubbles.length; b++) {
                this.bubbles[b].hideSlowly();
            }
        };
    
        LogoShape.prototype.setRotation = function setRotation(speed) {
            for (var b = 1; b < this.bubbles.length; b++) {
                this.bubbles[b].setRotation(speed);
            }
        };
    
        LogoShape.prototype.addModifiers = function addModifiers(rangeDelta, speedDelta) {
            for (var b = 1; b < this.bubbles.length; b++) {
                this.bubbles[b].addModifiers(rangeDelta, speedDelta);
            }
        };
    
        LogoShape.prototype.removeModifiers = function removeModifiers() {
            for (var b = 1; b < this.bubbles.length; b++) {
                this.bubbles[b].removeModifiers();
            }
        };
    
        LogoShape.prototype.update = function update(deltaTime) {
            if (!this.isApplied) {
                return;
            }
            this.cleanupMask();
            for (var b = 0; b < this.bubbles.length; b++) {
                this.bubbles[b].update(deltaTime);
            }
            this.metaballize();
            this.refreshMask();
        };
    
        LogoShape.prototype.cleanupMask = function cleanupMask() {
            this.maskContext.clearRect(0, 0, this.width, this.height);
        };
    
        LogoShape.prototype.setupEmptyMask = function setupEmptyMask() {
            this.fillStyle = this.noMaskColor;
            this.maskContext.fillRect(0, 0, this.width, this.height);
        };
    
        LogoShape.prototype.metaballize = function metaballize() {
            this.metaballizer.render();
        };
    
        // get/set settings of the current outline shape state
    
    
        LogoShape.prototype.getState = function getState() {
            var state = {
                mainSize: this.getBaseShape().size,
                bubbles: []
            };
            var bubbles = this.getOutlineBubbles();
            for (var i = 0; i < bubbles.length; i++) {
                state.bubbles.push(bubbles[i].getState());
            }
            return state;
        };
    
        LogoShape.prototype.setState = function setState(state) {
            if (!state) {
                return;
            }
            this.getBaseShape().size = state.mainSize || 0;
            this.getOutlineBubbles().forEach(function (bubble, i) {
                var bubbleSettings = state.bubbles[i];
                bubble.setState(bubbleSettings);
            });
        };
    
        LogoShape.prototype.transitTo = function transitTo(state, duration, delay, easeType) {
            if (!state) {
                return;
            }
    
            this.getBaseShape().transitTo({ "size": state.mainSize }, duration, delay, easeType);
            this.getOutlineBubbles().forEach(function (bubble, i) {
                var bubbleSettings = state.bubbles[i];
                bubble.transitTo(bubbleSettings, duration, delay, easeType);
            });
        };
    
        return LogoShape;
    }();
    
    exports.default = LogoShape;
    
    /***/ }),
    /* 83 */
    /***/ (function(module, exports, __webpack_require__) {
    
    module.exports = __webpack_require__(84);
    
    
    /***/ }),
    /* 84 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    /* WEBPACK VAR INJECTION */(function(global) {
    
    exports.__esModule = true;
    exports.Logo = exports.LogoMesh = exports.LogoTexture = undefined;
    
    __webpack_require__(85);
    
    __webpack_require__(19);
    
    var _logo = __webpack_require__(78);
    
    var _logo2 = _interopRequireDefault(_logo);
    
    var _logo3 = __webpack_require__(81);
    
    var _logo4 = _interopRequireDefault(_logo3);
    
    var _logo5 = __webpack_require__(186);
    
    var _logo6 = _interopRequireDefault(_logo5);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    exports.LogoTexture = _logo2.default;
    exports.LogoMesh = _logo4.default;
    exports.Logo = _logo6.default;
    
    
    global.SHLogo = exports;
    /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))
    
    /***/ }),
    /* 85 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    /* WEBPACK VAR INJECTION */(function(global) {
    
    exports.__esModule = true;
    exports.loader = exports.mesh = exports.loaders = exports.filters = exports.interaction = undefined;
    
    var _polyfill = __webpack_require__(86);
    
    Object.keys(_polyfill).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _polyfill[key];
        }
      });
    });
    
    var _core = __webpack_require__(4);
    
    Object.keys(_core).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _core[key];
        }
      });
    });
    
    var _interaction = __webpack_require__(145);
    
    var interaction = _interopRequireWildcard(_interaction);
    
    var _filters = __webpack_require__(149);
    
    var filters = _interopRequireWildcard(_filters);
    
    var _loaders = __webpack_require__(151);
    
    var loaders = _interopRequireWildcard(_loaders);
    
    var _mesh = __webpack_require__(155);
    
    var mesh = _interopRequireWildcard(_mesh);
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    // export core
    _core.utils.mixins.performMixins();
    
    /**
     * Alias for {@link PIXI.loaders.shared}.
     * @name loader
     * @memberof PIXI
     * @type {PIXI.loader.Loader}
     */
    
    
    // handle mixins now, after all code has been added, including deprecation
    
    
    // export libs
    // import polyfills. Done as an export to make sure polyfills are imported first
    var loader = loaders.shared || null;
    
    exports.interaction = interaction;
    exports.filters = filters;
    exports.loaders = loaders;
    exports.mesh = mesh;
    exports.loader = loader;
    
    // Always export pixi globally.
    
    global.PIXI = exports; // eslint-disable-line
    /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))
    
    /***/ }),
    /* 86 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    __webpack_require__(87);
    
    __webpack_require__(89);
    
    __webpack_require__(90);
    
    if (!window.ArrayBuffer) {
        window.ArrayBuffer = Array;
    }
    
    if (!window.Float32Array) {
        window.Float32Array = Array;
    }
    
    if (!window.Uint32Array) {
        window.Uint32Array = Array;
    }
    
    if (!window.Uint16Array) {
        window.Uint16Array = Array;
    }
    
    /***/ }),
    /* 87 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var _objectAssign = __webpack_require__(88);
    
    var _objectAssign2 = _interopRequireDefault(_objectAssign);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    if (!Object.assign) {
        Object.assign = _objectAssign2.default;
    } // References:
    // https://github.com/sindresorhus/object-assign
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    
    /***/ }),
    /* 88 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    
    
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    
    function toObject(val) {
        if (val === null || val === undefined) {
            throw new TypeError('Object.assign cannot be called with null or undefined');
        }
    
        return Object(val);
    }
    
    function shouldUseNative() {
        try {
            if (!Object.assign) {
                return false;
            }
    
            // Detect buggy property enumeration order in older V8 versions.
    
            // https://bugs.chromium.org/p/v8/issues/detail?id=4118
            var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
            test1[5] = 'de';
            if (Object.getOwnPropertyNames(test1)[0] === '5') {
                return false;
            }
    
            // https://bugs.chromium.org/p/v8/issues/detail?id=3056
            var test2 = {};
            for (var i = 0; i < 10; i++) {
                test2['_' + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
                return test2[n];
            });
            if (order2.join('') !== '0123456789') {
                return false;
            }
    
            // https://bugs.chromium.org/p/v8/issues/detail?id=3056
            var test3 = {};
            'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
                test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join('') !==
                    'abcdefghijklmnopqrst') {
                return false;
            }
    
            return true;
        } catch (err) {
            // We don't expect any of the above to throw, but better to be safe.
            return false;
        }
    }
    
    module.exports = shouldUseNative() ? Object.assign : function (target, source) {
        var from;
        var to = toObject(target);
        var symbols;
    
        for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
    
            for (var key in from) {
                if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                }
            }
    
            if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) {
                    if (propIsEnumerable.call(from, symbols[i])) {
                        to[symbols[i]] = from[symbols[i]];
                    }
                }
            }
        }
    
        return to;
    };
    
    
    /***/ }),
    /* 89 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    /* WEBPACK VAR INJECTION */(function(global) {
    
    // References:
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    // https://gist.github.com/1579671
    // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision
    // https://gist.github.com/timhall/4078614
    // https://github.com/Financial-Times/polyfill-service/tree/master/polyfills/requestAnimationFrame
    
    // Expected to be used with Browserfiy
    // Browserify automatically detects the use of `global` and passes the
    // correct reference of `global`, `self`, and finally `window`
    
    var ONE_FRAME_TIME = 16;
    
    // Date.now
    if (!(Date.now && Date.prototype.getTime)) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }
    
    // performance.now
    if (!(global.performance && global.performance.now)) {
        var startTime = Date.now();
    
        if (!global.performance) {
            global.performance = {};
        }
    
        global.performance.now = function () {
            return Date.now() - startTime;
        };
    }
    
    // requestAnimationFrame
    var lastTime = Date.now();
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    
    for (var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) {
        var p = vendors[x];
    
        global.requestAnimationFrame = global[p + 'RequestAnimationFrame'];
        global.cancelAnimationFrame = global[p + 'CancelAnimationFrame'] || global[p + 'CancelRequestAnimationFrame'];
    }
    
    if (!global.requestAnimationFrame) {
        global.requestAnimationFrame = function (callback) {
            if (typeof callback !== 'function') {
                throw new TypeError(callback + 'is not a function');
            }
    
            var currentTime = Date.now();
            var delay = ONE_FRAME_TIME + lastTime - currentTime;
    
            if (delay < 0) {
                delay = 0;
            }
    
            lastTime = currentTime;
    
            return setTimeout(function () {
                lastTime = Date.now();
                callback(performance.now());
            }, delay);
        };
    }
    
    if (!global.cancelAnimationFrame) {
        global.cancelAnimationFrame = function (id) {
            return clearTimeout(id);
        };
    }
    /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))
    
    /***/ }),
    /* 90 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    // References:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
    
    if (!Math.sign) {
        Math.sign = function mathSign(x) {
            x = Number(x);
    
            if (x === 0 || isNaN(x)) {
                return x;
            }
    
            return x > 0 ? 1 : -1;
        };
    }
    
    /***/ }),
    /* 91 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * The Point object represents a location in a two-dimensional coordinate system, where x represents
     * the horizontal axis and y represents the vertical axis.
     * An observable point is a point that triggers a callback when the point's position is changed.
     *
     * @class
     * @memberof PIXI
     */
    var ObservablePoint = function () {
        /**
         * @param {Function} cb - callback when changed
         * @param {object} scope - owner of callback
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
        function ObservablePoint(cb, scope) {
            var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    
            _classCallCheck(this, ObservablePoint);
    
            this._x = x;
            this._y = y;
    
            this.cb = cb;
            this.scope = scope;
        }
    
        /**
         * Sets the point to a new x and y position.
         * If y is omitted, both x and y will be set to x.
         *
         * @param {number} [x=0] - position of the point on the x axis
         * @param {number} [y=0] - position of the point on the y axis
         */
    
    
        ObservablePoint.prototype.set = function set(x, y) {
            var _x = x || 0;
            var _y = y || (y !== 0 ? _x : 0);
    
            if (this._x !== _x || this._y !== _y) {
                this._x = _x;
                this._y = _y;
                this.cb.call(this.scope);
            }
        };
    
        /**
         * Copies the data from another point
         *
         * @param {PIXI.Point|PIXI.ObservablePoint} point - point to copy from
         */
    
    
        ObservablePoint.prototype.copy = function copy(point) {
            if (this._x !== point.x || this._y !== point.y) {
                this._x = point.x;
                this._y = point.y;
                this.cb.call(this.scope);
            }
        };
    
        /**
         * The position of the displayObject on the x axis relative to the local coordinates of the parent.
         *
         * @member {number}
         */
    
    
        _createClass(ObservablePoint, [{
            key: "x",
            get: function get() {
                return this._x;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                if (this._x !== value) {
                    this._x = value;
                    this.cb.call(this.scope);
                }
            }
    
            /**
             * The position of the displayObject on the x axis relative to the local coordinates of the parent.
             *
             * @member {number}
             */
    
        }, {
            key: "y",
            get: function get() {
                return this._y;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                if (this._y !== value) {
                    this._y = value;
                    this.cb.call(this.scope);
                }
            }
        }]);
    
        return ObservablePoint;
    }();
    
    exports.default = ObservablePoint;
    
    /***/ }),
    /* 92 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Rectangle = __webpack_require__(23);
    
    var _Rectangle2 = _interopRequireDefault(_Rectangle);
    
    var _const = __webpack_require__(0);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * The Circle object can be used to specify a hit area for displayObjects
     *
     * @class
     * @memberof PIXI
     */
    var Circle = function () {
      /**
       * @param {number} [x=0] - The X coordinate of the center of this circle
       * @param {number} [y=0] - The Y coordinate of the center of this circle
       * @param {number} [radius=0] - The radius of the circle
       */
      function Circle() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    
        _classCallCheck(this, Circle);
    
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
    
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
    
        /**
         * @member {number}
         * @default 0
         */
        this.radius = radius;
    
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.CIRC
         * @see PIXI.SHAPES
         */
        this.type = _const.SHAPES.CIRC;
      }
    
      /**
       * Creates a clone of this Circle instance
       *
       * @return {PIXI.Circle} a copy of the Circle
       */
    
    
      Circle.prototype.clone = function clone() {
        return new Circle(this.x, this.y, this.radius);
      };
    
      /**
       * Checks whether the x and y coordinates given are contained within this circle
       *
       * @param {number} x - The X coordinate of the point to test
       * @param {number} y - The Y coordinate of the point to test
       * @return {boolean} Whether the x/y coordinates are within this Circle
       */
    
    
      Circle.prototype.contains = function contains(x, y) {
        if (this.radius <= 0) {
          return false;
        }
    
        var r2 = this.radius * this.radius;
        var dx = this.x - x;
        var dy = this.y - y;
    
        dx *= dx;
        dy *= dy;
    
        return dx + dy <= r2;
      };
    
      /**
      * Returns the framing rectangle of the circle as a Rectangle object
      *
      * @return {PIXI.Rectangle} the framing rectangle
      */
    
    
      Circle.prototype.getBounds = function getBounds() {
        return new _Rectangle2.default(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
      };
    
      return Circle;
    }();
    
    exports.default = Circle;
    
    /***/ }),
    /* 93 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Rectangle = __webpack_require__(23);
    
    var _Rectangle2 = _interopRequireDefault(_Rectangle);
    
    var _const = __webpack_require__(0);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * The Ellipse object can be used to specify a hit area for displayObjects
     *
     * @class
     * @memberof PIXI
     */
    var Ellipse = function () {
      /**
       * @param {number} [x=0] - The X coordinate of the center of this circle
       * @param {number} [y=0] - The Y coordinate of the center of this circle
       * @param {number} [width=0] - The half width of this ellipse
       * @param {number} [height=0] - The half height of this ellipse
       */
      function Ellipse() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    
        _classCallCheck(this, Ellipse);
    
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
    
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
    
        /**
         * @member {number}
         * @default 0
         */
        this.width = width;
    
        /**
         * @member {number}
         * @default 0
         */
        this.height = height;
    
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.ELIP
         * @see PIXI.SHAPES
         */
        this.type = _const.SHAPES.ELIP;
      }
    
      /**
       * Creates a clone of this Ellipse instance
       *
       * @return {PIXI.Ellipse} a copy of the ellipse
       */
    
    
      Ellipse.prototype.clone = function clone() {
        return new Ellipse(this.x, this.y, this.width, this.height);
      };
    
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse
       *
       * @param {number} x - The X coordinate of the point to test
       * @param {number} y - The Y coordinate of the point to test
       * @return {boolean} Whether the x/y coords are within this ellipse
       */
    
    
      Ellipse.prototype.contains = function contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
    
        // normalize the coords to an ellipse with center 0,0
        var normx = (x - this.x) / this.width;
        var normy = (y - this.y) / this.height;
    
        normx *= normx;
        normy *= normy;
    
        return normx + normy <= 1;
      };
    
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object
       *
       * @return {PIXI.Rectangle} the framing rectangle
       */
    
    
      Ellipse.prototype.getBounds = function getBounds() {
        return new _Rectangle2.default(this.x - this.width, this.y - this.height, this.width, this.height);
      };
    
      return Ellipse;
    }();
    
    exports.default = Ellipse;
    
    /***/ }),
    /* 94 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Point = __webpack_require__(21);
    
    var _Point2 = _interopRequireDefault(_Point);
    
    var _const = __webpack_require__(0);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * @class
     * @memberof PIXI
     */
    var Polygon = function () {
        /**
         * @param {PIXI.Point[]|number[]} points - This can be an array of Points
         *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
         *  the arguments passed can be all the points of the polygon e.g.
         *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat
         *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
         */
        function Polygon() {
            for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
                points[_key] = arguments[_key];
            }
    
            _classCallCheck(this, Polygon);
    
            if (Array.isArray(points[0])) {
                points = points[0];
            }
    
            // if this is an array of points, convert it to a flat array of numbers
            if (points[0] instanceof _Point2.default) {
                var p = [];
    
                for (var i = 0, il = points.length; i < il; i++) {
                    p.push(points[i].x, points[i].y);
                }
    
                points = p;
            }
    
            this.closed = true;
    
            /**
             * An array of the points of this polygon
             *
             * @member {number[]}
             */
            this.points = points;
    
            /**
             * The type of the object, mainly used to avoid `instanceof` checks
             *
             * @member {number}
             * @readOnly
             * @default PIXI.SHAPES.POLY
             * @see PIXI.SHAPES
             */
            this.type = _const.SHAPES.POLY;
        }
    
        /**
         * Creates a clone of this polygon
         *
         * @return {PIXI.Polygon} a copy of the polygon
         */
    
    
        Polygon.prototype.clone = function clone() {
            return new Polygon(this.points.slice());
        };
    
        /**
         * Closes the polygon, adding points if necessary.
         *
         */
    
    
        Polygon.prototype.close = function close() {
            var points = this.points;
    
            // close the poly if the value is true!
            if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {
                points.push(points[0], points[1]);
            }
        };
    
        /**
         * Checks whether the x and y coordinates passed to this function are contained within this polygon
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this polygon
         */
    
    
        Polygon.prototype.contains = function contains(x, y) {
            var inside = false;
    
            // use some raycasting to test hits
            // https://github.com/substack/point-in-polygon/blob/master/index.js
            var length = this.points.length / 2;
    
            for (var i = 0, j = length - 1; i < length; j = i++) {
                var xi = this.points[i * 2];
                var yi = this.points[i * 2 + 1];
                var xj = this.points[j * 2];
                var yj = this.points[j * 2 + 1];
                var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
    
                if (intersect) {
                    inside = !inside;
                }
            }
    
            return inside;
        };
    
        return Polygon;
    }();
    
    exports.default = Polygon;
    
    /***/ }),
    /* 95 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _const = __webpack_require__(0);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its
     * top-left corner point (x, y) and by its width and its height and its radius.
     *
     * @class
     * @memberof PIXI
     */
    var RoundedRectangle = function () {
        /**
         * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
         * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
         * @param {number} [width=0] - The overall width of this rounded rectangle
         * @param {number} [height=0] - The overall height of this rounded rectangle
         * @param {number} [radius=20] - Controls the radius of the rounded corners
         */
        function RoundedRectangle() {
            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;
    
            _classCallCheck(this, RoundedRectangle);
    
            /**
             * @member {number}
             * @default 0
             */
            this.x = x;
    
            /**
             * @member {number}
             * @default 0
             */
            this.y = y;
    
            /**
             * @member {number}
             * @default 0
             */
            this.width = width;
    
            /**
             * @member {number}
             * @default 0
             */
            this.height = height;
    
            /**
             * @member {number}
             * @default 20
             */
            this.radius = radius;
    
            /**
             * The type of the object, mainly used to avoid `instanceof` checks
             *
             * @member {number}
             * @readonly
             * @default PIXI.SHAPES.RREC
             * @see PIXI.SHAPES
             */
            this.type = _const.SHAPES.RREC;
        }
    
        /**
         * Creates a clone of this Rounded Rectangle
         *
         * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
         */
    
    
        RoundedRectangle.prototype.clone = function clone() {
            return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
        };
    
        /**
         * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
         *
         * @param {number} x - The X coordinate of the point to test
         * @param {number} y - The Y coordinate of the point to test
         * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
         */
    
    
        RoundedRectangle.prototype.contains = function contains(x, y) {
            if (this.width <= 0 || this.height <= 0) {
                return false;
            }
            if (x >= this.x && x <= this.x + this.width) {
                if (y >= this.y && y <= this.y + this.height) {
                    if (y >= this.y + this.radius && y <= this.y + this.height - this.radius || x >= this.x + this.radius && x <= this.x + this.width - this.radius) {
                        return true;
                    }
                    var dx = x - (this.x + this.radius);
                    var dy = y - (this.y + this.radius);
                    var radius2 = this.radius * this.radius;
    
                    if (dx * dx + dy * dy <= radius2) {
                        return true;
                    }
                    dx = x - (this.x + this.width - this.radius);
                    if (dx * dx + dy * dy <= radius2) {
                        return true;
                    }
                    dy = y - (this.y + this.height - this.radius);
                    if (dx * dx + dy * dy <= radius2) {
                        return true;
                    }
                    dx = x - (this.x + this.radius);
                    if (dx * dx + dy * dy <= radius2) {
                        return true;
                    }
                }
            }
    
            return false;
        };
    
        return RoundedRectangle;
    }();
    
    exports.default = RoundedRectangle;
    
    /***/ }),
    /* 96 */
    /***/ (function(module, exports) {
    
    
    /**
     * Helper class to create a webGL Context
     *
     * @class
     * @memberof PIXI.glCore
     * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
     * @param options {Object} An options object that gets passed in to the canvas element containing the context attributes,
     *                         see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext for the options available
     * @return {WebGLRenderingContext} the WebGL context
     */
    var createContext = function(canvas, options)
    {
        var gl = canvas.getContext('webgl', options) || 
             canvas.getContext('experimental-webgl', options);
    
        if (!gl)
        {
            // fail, not able to get a context
            throw new Error('This browser does not support webGL. Try using the canvas renderer');
        }
    
        return gl;
    };
    
    module.exports = createContext;
    
    
    /***/ }),
    /* 97 */
    /***/ (function(module, exports) {
    
    var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);
    
    /**
     * Helper class to create a webGL buffer
     *
     * @class
     * @memberof PIXI.glCore
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     * @param type {gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER} @mat
     * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
     * @param drawType {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
     */
    var Buffer = function(gl, type, data, drawType)
    {
    
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
        /**
         * The WebGL buffer, created upon instantiation
         *
         * @member {WebGLBuffer}
         */
        this.buffer = gl.createBuffer();
    
        /**
         * The type of the buffer
         *
         * @member {gl.ARRAY_BUFFER|gl.ELEMENT_ARRAY_BUFFER}
         */
        this.type = type || gl.ARRAY_BUFFER;
    
        /**
         * The draw type of the buffer
         *
         * @member {gl.STATIC_DRAW|gl.DYNAMIC_DRAW|gl.STREAM_DRAW}
         */
        this.drawType = drawType || gl.STATIC_DRAW;
    
        /**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
         */
        this.data = EMPTY_ARRAY_BUFFER;
    
        if(data)
        {
            this.upload(data);
        }
    
        this._updateID = 0;
    };
    
    /**
     * Uploads the buffer to the GPU
     * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data to upload
     * @param offset {Number} if only a subset of the data should be uploaded, this is the amount of data to subtract
     * @param dontBind {Boolean} whether to bind the buffer before uploading it
     */
    Buffer.prototype.upload = function(data, offset, dontBind)
    {
        // todo - needed?
        if(!dontBind) this.bind();
    
        var gl = this.gl;
    
        data = data || this.data;
        offset = offset || 0;
    
        if(this.data.byteLength >= data.byteLength)
        {
            gl.bufferSubData(this.type, offset, data);
        }
        else
        {
            gl.bufferData(this.type, data, this.drawType);
        }
    
        this.data = data;
    };
    /**
     * Binds the buffer
     *
     */
    Buffer.prototype.bind = function()
    {
        var gl = this.gl;
        gl.bindBuffer(this.type, this.buffer);
    };
    
    Buffer.createVertexBuffer = function(gl, data, drawType)
    {
        return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType);
    };
    
    Buffer.createIndexBuffer = function(gl, data, drawType)
    {
        return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType);
    };
    
    Buffer.create = function(gl, type, data, drawType)
    {
        return new Buffer(gl, type, data, drawType);
    };
    
    /**
     * Destroys the buffer
     *
     */
    Buffer.prototype.destroy = function(){
        this.gl.deleteBuffer(this.buffer);
    };
    
    module.exports = Buffer;
    
    
    /***/ }),
    /* 98 */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    var Texture = __webpack_require__(36);
    
    /**
     * Helper class to create a webGL Framebuffer
     *
     * @class
     * @memberof PIXI.glCore
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     * @param width {Number} the width of the drawing area of the frame buffer
     * @param height {Number} the height of the drawing area of the frame buffer
     */
    var Framebuffer = function(gl, width, height)
    {
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
        /**
         * The frame buffer
         *
         * @member {WebGLFramebuffer}
         */
        this.framebuffer = gl.createFramebuffer();
    
        /**
         * The stencil buffer
         *
         * @member {WebGLRenderbuffer}
         */
        this.stencil = null;
    
        /**
         * The stencil buffer
         *
         * @member {PIXI.glCore.GLTexture}
         */
        this.texture = null;
    
        /**
         * The width of the drawing area of the buffer
         *
         * @member {Number}
         */
        this.width = width || 100;
        /**
         * The height of the drawing area of the buffer
         *
         * @member {Number}
         */
        this.height = height || 100;
    };
    
    /**
     * Adds a texture to the frame buffer
     * @param texture {PIXI.glCore.GLTexture}
     */
    Framebuffer.prototype.enableTexture = function(texture)
    {
        var gl = this.gl;
    
        this.texture = texture || new Texture(gl);
    
        this.texture.bind();
    
        //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    
        this.bind();
    
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
    };
    
    /**
     * Initialises the stencil buffer
     */
    Framebuffer.prototype.enableStencil = function()
    {
        if(this.stencil)return;
    
        var gl = this.gl;
    
        this.stencil = gl.createRenderbuffer();
    
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
    
        // TODO.. this is depth AND stencil?
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL,  this.width  , this.height );
    
    
    };
    
    /**
     * Erases the drawing area and fills it with a colour
     * @param  r {Number} the red value of the clearing colour
     * @param  g {Number} the green value of the clearing colour
     * @param  b {Number} the blue value of the clearing colour
     * @param  a {Number} the alpha value of the clearing colour
     */
    Framebuffer.prototype.clear = function( r, g, b, a )
    {
        this.bind();
    
        var gl = this.gl;
    
        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };
    
    /**
     * Binds the frame buffer to the WebGL context
     */
    Framebuffer.prototype.bind = function()
    {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );
    };
    
    /**
     * Unbinds the frame buffer to the WebGL context
     */
    Framebuffer.prototype.unbind = function()
    {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null );
    };
    /**
     * Resizes the drawing area of the buffer to the given width and height
     * @param  width  {Number} the new width
     * @param  height {Number} the new height
     */
    Framebuffer.prototype.resize = function(width, height)
    {
        var gl = this.gl;
    
        this.width = width;
        this.height = height;
    
        if ( this.texture )
        {
            this.texture.uploadData(null, width, height);
        }
    
        if ( this.stencil )
        {
            // update the stencil buffer width and height
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
        }
    };
    
    /**
     * Destroys this buffer
     */
    Framebuffer.prototype.destroy = function()
    {
        var gl = this.gl;
    
        //TODO
        if(this.texture)
        {
            this.texture.destroy();
        }
    
        gl.deleteFramebuffer(this.framebuffer);
    
        this.gl = null;
    
        this.stencil = null;
        this.texture = null;
    };
    
    /**
     * Creates a frame buffer with a texture containing the given data
     * @static
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     * @param width {Number} the width of the drawing area of the frame buffer
     * @param height {Number} the height of the drawing area of the frame buffer
     * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
     */
    Framebuffer.createRGBA = function(gl, width, height, data)
    {
        var texture = Texture.fromData(gl, null, width, height);
        texture.enableNearestScaling();
        texture.enableWrapClamp();
    
        //now create the framebuffer object and attach the texture to it.
        var fbo = new Framebuffer(gl, width, height);
        fbo.enableTexture(texture);
    
        //fbo.enableStencil(); // get this back on soon!
    
        fbo.unbind();
    
        return fbo;
    };
    
    /**
     * Creates a frame buffer with a texture containing the given data
     * @static
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     * @param width {Number} the width of the drawing area of the frame buffer
     * @param height {Number} the height of the drawing area of the frame buffer
     * @param data {ArrayBuffer| SharedArrayBuffer|ArrayBufferView} an array of data
     */
    Framebuffer.createFloat32 = function(gl, width, height, data)
    {
        // create a new texture..
        var texture = new Texture.fromData(gl, data, width, height);
        texture.enableNearestScaling();
        texture.enableWrapClamp();
    
        //now create the framebuffer object and attach the texture to it.
        var fbo = new Framebuffer(gl, width, height);
        fbo.enableTexture(texture);
    
        fbo.unbind();
    
        return fbo;
    };
    
    module.exports = Framebuffer;
    
    
    /***/ }),
    /* 99 */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    var compileProgram = __webpack_require__(37),
        extractAttributes = __webpack_require__(38),
        extractUniforms = __webpack_require__(40),
        setPrecision = __webpack_require__(42),
        generateUniformAccessObject = __webpack_require__(43);
    
    /**
     * Helper class to create a webGL Shader
     *
     * @class
     * @memberof PIXI.glCore
     * @param gl {WebGLRenderingContext}
     * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
     * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
     * @param precision {precision]} The float precision of the shader. Options are 'lowp', 'mediump' or 'highp'.
     * @param attributeLocations {object} A key value pair showing which location eact attribute should sit eg {position:0, uvs:1}
     */
    var Shader = function(gl, vertexSrc, fragmentSrc, precision, attributeLocations)
    {
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
        if(precision)
        {
            vertexSrc = setPrecision(vertexSrc, precision);
            fragmentSrc = setPrecision(fragmentSrc, precision);
        }
    
        /**
         * The shader program
         *
         * @member {WebGLProgram}
         */
        // First compile the program..
        this.program = compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations);
    
        /**
         * The attributes of the shader as an object containing the following properties
         * {
         * 	type,
         * 	size,
         * 	location,
         * 	pointer
         * }
         * @member {Object}
         */
        // next extract the attributes
        this.attributes = extractAttributes(gl, this.program);
    
        this.uniformData = extractUniforms(gl, this.program);
    
        /**
         * The uniforms of the shader as an object containing the following properties
         * {
         * 	gl,
         * 	data
         * }
         * @member {Object}
         */
        this.uniforms = generateUniformAccessObject( gl, this.uniformData );
    
    };
    /**
     * Uses this shader
     */
    Shader.prototype.bind = function()
    {
        this.gl.useProgram(this.program);
    };
    
    /**
     * Destroys this shader
     * TODO
     */
    Shader.prototype.destroy = function()
    {
        this.attributes = null;
        this.uniformData = null;
        this.uniforms = null;
    
        var gl = this.gl;
        gl.deleteProgram(this.program);
    };
    
    
    module.exports = Shader;
    
    
    /***/ }),
    /* 100 */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    // state object//
    var setVertexAttribArrays = __webpack_require__( 35 );
    
    /**
     * Helper class to work with WebGL VertexArrayObjects (vaos)
     * Only works if WebGL extensions are enabled (they usually are)
     *
     * @class
     * @memberof PIXI.glCore
     * @param gl {WebGLRenderingContext} The current WebGL rendering context
     */
    function VertexArrayObject(gl, state)
    {
        this.nativeVaoExtension = null;
    
        if(!VertexArrayObject.FORCE_NATIVE)
        {
            this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') ||
                                      gl.getExtension('MOZ_OES_vertex_array_object') ||
                                      gl.getExtension('WEBKIT_OES_vertex_array_object');
        }
    
        this.nativeState = state;
    
        if(this.nativeVaoExtension)
        {
            this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();
    
            var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    
            // VAO - overwrite the state..
            this.nativeState = {
                tempAttribState: new Array(maxAttribs),
                attribState: new Array(maxAttribs)
            };
        }
    
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
        /**
         * An array of attributes
         *
         * @member {Array}
         */
        this.attributes = [];
    
        /**
         * @member {PIXI.glCore.GLBuffer}
         */
        this.indexBuffer = null;
    
        /**
         * A boolean flag
         *
         * @member {Boolean}
         */
        this.dirty = false;
    }
    
    VertexArrayObject.prototype.constructor = VertexArrayObject;
    module.exports = VertexArrayObject;
    
    /**
    * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
    * If you find on older devices that things have gone a bit weird then set this to true.
    */
    /**
     * Lets the VAO know if you should use the WebGL extension or the native methods.
     * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)
     * If you find on older devices that things have gone a bit weird then set this to true.
     * @static
     * @property {Boolean} FORCE_NATIVE
     */
    VertexArrayObject.FORCE_NATIVE = false;
    
    /**
     * Binds the buffer
     */
    VertexArrayObject.prototype.bind = function()
    {
        if(this.nativeVao)
        {
            this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
    
            if(this.dirty)
            {
                this.dirty = false;
                this.activate();
            }
        }
        else
        {
    
            this.activate();
        }
    
        return this;
    };
    
    /**
     * Unbinds the buffer
     */
    VertexArrayObject.prototype.unbind = function()
    {
        if(this.nativeVao)
        {
            this.nativeVaoExtension.bindVertexArrayOES(null);
        }
    
        return this;
    };
    
    /**
     * Uses this vao
     */
    VertexArrayObject.prototype.activate = function()
    {
    
        var gl = this.gl;
        var lastBuffer = null;
    
        for (var i = 0; i < this.attributes.length; i++)
        {
            var attrib = this.attributes[i];
    
            if(lastBuffer !== attrib.buffer)
            {
                attrib.buffer.bind();
                lastBuffer = attrib.buffer;
            }
    
            gl.vertexAttribPointer(attrib.attribute.location,
                                   attrib.attribute.size,
                                   attrib.type || gl.FLOAT,
                                   attrib.normalized || false,
                                   attrib.stride || 0,
                                   attrib.start || 0);
        }
    
        setVertexAttribArrays(gl, this.attributes, this.nativeState);
    
        if(this.indexBuffer)
        {
            this.indexBuffer.bind();
        }
    
        return this;
    };
    
    /**
     *
     * @param buffer     {PIXI.gl.GLBuffer}
     * @param attribute  {*}
     * @param type       {String}
     * @param normalized {Boolean}
     * @param stride     {Number}
     * @param start      {Number}
     */
    VertexArrayObject.prototype.addAttribute = function(buffer, attribute, type, normalized, stride, start)
    {
        this.attributes.push({
            buffer:     buffer,
            attribute:  attribute,
    
            location:   attribute.location,
            type:       type || this.gl.FLOAT,
            normalized: normalized || false,
            stride:     stride || 0,
            start:      start || 0
        });
    
        this.dirty = true;
    
        return this;
    };
    
    /**
     *
     * @param buffer   {PIXI.gl.GLBuffer}
     */
    VertexArrayObject.prototype.addIndex = function(buffer/*, options*/)
    {
        this.indexBuffer = buffer;
    
        this.dirty = true;
    
        return this;
    };
    
    /**
     * Unbinds this vao and disables it
     */
    VertexArrayObject.prototype.clear = function()
    {
        // var gl = this.gl;
    
        // TODO - should this function unbind after clear?
        // for now, no but lets see what happens in the real world!
        if(this.nativeVao)
        {
            this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
        }
    
        this.attributes.length = 0;
        this.indexBuffer = null;
    
        return this;
    };
    
    /**
     * @param type  {Number}
     * @param size  {Number}
     * @param start {Number}
     */
    VertexArrayObject.prototype.draw = function(type, size, start)
    {
        var gl = this.gl;
    
        if(this.indexBuffer)
        {
            gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2 );
        }
        else
        {
            // TODO need a better way to calculate size..
            gl.drawArrays(type, start, size || this.getSize());
        }
    
        return this;
    };
    
    /**
     * Destroy this vao
     */
    VertexArrayObject.prototype.destroy = function()
    {
        // lose references
        this.gl = null;
        this.indexBuffer = null;
        this.attributes = null;
        this.nativeState = null;
    
        if(this.nativeVao)
        {
            this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);
        }
    
        this.nativeVaoExtension = null;
        this.nativeVao = null;
    };
    
    VertexArrayObject.prototype.getSize = function()
    {
        var attrib = this.attributes[0];
        return attrib.buffer.data.length / (( attrib.stride/4 ) || attrib.attribute.size);
    };
    
    
    /***/ }),
    /* 101 */
    /***/ (function(module, exports, __webpack_require__) {
    
    module.exports = {
        compileProgram: __webpack_require__(37),
        defaultValue: __webpack_require__(41),
        extractAttributes: __webpack_require__(38),
        extractUniforms: __webpack_require__(40),
        generateUniformAccessObject: __webpack_require__(43),
        setPrecision: __webpack_require__(42),
        mapSize: __webpack_require__(39),
        mapType: __webpack_require__(24)
    };
    
    /***/ }),
    /* 102 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = maxRecommendedTextures;
    
    var _ismobilejs = __webpack_require__(45);
    
    var _ismobilejs2 = _interopRequireDefault(_ismobilejs);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function maxRecommendedTextures(max) {
        if (_ismobilejs2.default.tablet || _ismobilejs2.default.phone) {
            // check if the res is iphone 6 or higher..
            return 4;
        }
    
        // desktop should be ok
        return max;
    }
    
    /***/ }),
    /* 103 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = canUploadSameBuffer;
    function canUploadSameBuffer() {
        // Uploading the same buffer multiple times in a single frame can cause perf issues.
        // Apparent on IOS so only check for that at the moment
        // this check may become more complex if this issue pops up elsewhere.
        var ios = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);
    
        return !ios;
    }
    
    /***/ }),
    /* 104 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    /**
     * Mixins functionality to make an object have "plugins".
     *
     * @example
     *      function MyObject() {}
     *
     *      pluginTarget.mixin(MyObject);
     *
     * @mixin
     * @memberof PIXI.utils
     * @param {object} obj - The object to mix into.
     */
    function pluginTarget(obj) {
        obj.__plugins = {};
    
        /**
         * Adds a plugin to an object
         *
         * @param {string} pluginName - The events that should be listed.
         * @param {Function} ctor - The constructor function for the plugin.
         */
        obj.registerPlugin = function registerPlugin(pluginName, ctor) {
            obj.__plugins[pluginName] = ctor;
        };
    
        /**
         * Instantiates all the plugins of this object
         *
         */
        obj.prototype.initPlugins = function initPlugins() {
            this.plugins = this.plugins || {};
    
            for (var o in obj.__plugins) {
                this.plugins[o] = new obj.__plugins[o](this);
            }
        };
    
        /**
         * Removes all the plugins of this object
         *
         */
        obj.prototype.destroyPlugins = function destroyPlugins() {
            for (var o in this.plugins) {
                this.plugins[o].destroy();
                this.plugins[o] = null;
            }
    
            this.plugins = null;
        };
    }
    
    exports.default = {
        /**
         * Mixes in the properties of the pluginTarget into another object
         *
         * @param {object} obj - The obj to mix into
         */
        mixin: function mixin(obj) {
            pluginTarget(obj);
        }
    };
    
    /***/ }),
    /* 105 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.mixin = mixin;
    exports.delayMixin = delayMixin;
    exports.performMixins = performMixins;
    /**
     * Mixes all enumerable properties and methods from a source object to a target object.
     *
     * @memberof PIXI.utils.mixins
     * @function mixin
     * @param {object} target The prototype or instance that properties and methods should be added to.
     * @param {object} source The source of properties and methods to mix in.
     */
    function mixin(target, source) {
        if (!target || !source) return;
        // in ES8/ES2017, this would be really easy:
        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    
        // get all the enumerable property keys
        var keys = Object.keys(source);
    
        // loop through properties
        for (var i = 0; i < keys.length; ++i) {
            var propertyName = keys[i];
    
            // Set the property using the property descriptor - this works for accessors and normal value properties
            Object.defineProperty(target, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
    }
    
    var mixins = [];
    
    /**
     * Queues a mixin to be handled towards the end of the initialization of PIXI, so that deprecation
     * can take effect.
     *
     * @memberof PIXI.utils.mixins
     * @function delayMixin
     * @private
     * @param {object} target The prototype or instance that properties and methods should be added to.
     * @param {object} source The source of properties and methods to mix in.
     */
    function delayMixin(target, source) {
        mixins.push(target, source);
    }
    
    /**
     * Handles all mixins queued via delayMixin().
     *
     * @memberof PIXI.utils.mixins
     * @function performMixins
     * @private
     */
    function performMixins() {
        for (var i = 0; i < mixins.length; i += 2) {
            mixin(mixins[i], mixins[i + 1]);
        }
        mixins.length = 0;
    }
    
    /***/ }),
    /* 106 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = determineCrossOrigin;
    
    var _url2 = __webpack_require__(49);
    
    var _url3 = _interopRequireDefault(_url2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var tempAnchor = void 0;
    
    /**
     * Sets the `crossOrigin` property for this resource based on if the url
     * for this resource is cross-origin. If crossOrigin was manually set, this
     * function does nothing.
     * Nipped from the resource loader!
     *
     * @ignore
     * @param {string} url - The url to test.
     * @param {object} [loc=window.location] - The location object to test against.
     * @return {string} The crossOrigin value to use (or empty string for none).
     */
    function determineCrossOrigin(url) {
        var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location;
    
        // data: and javascript: urls are considered same-origin
        if (url.indexOf('data:') === 0) {
            return '';
        }
    
        // default is window.location
        loc = loc || window.location;
    
        if (!tempAnchor) {
            tempAnchor = document.createElement('a');
        }
    
        // let the browser determine the full href for the url of this resource and then
        // parse with the node url lib, we can't use the properties of the anchor element
        // because they don't work in IE9 :(
        tempAnchor.href = url;
        url = _url3.default.parse(tempAnchor.href);
    
        var samePort = !url.port && loc.port === '' || url.port === loc.port;
    
        // if cross origin
        if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) {
            return 'anonymous';
        }
    
        return '';
    }
    
    /***/ }),
    /* 107 */
    /***/ (function(module, exports, __webpack_require__) {
    
    /* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
    ;(function(root) {
    
        /** Detect free variables */
        var freeExports = typeof exports == 'object' && exports &&
            !exports.nodeType && exports;
        var freeModule = typeof module == 'object' && module &&
            !module.nodeType && module;
        var freeGlobal = typeof global == 'object' && global;
        if (
            freeGlobal.global === freeGlobal ||
            freeGlobal.window === freeGlobal ||
            freeGlobal.self === freeGlobal
        ) {
            root = freeGlobal;
        }
    
        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */
        var punycode,
    
        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
    
        /** Bootstring parameters */
        base = 36,
        tMin = 1,
        tMax = 26,
        skew = 38,
        damp = 700,
        initialBias = 72,
        initialN = 128, // 0x80
        delimiter = '-', // '\x2D'
    
        /** Regular expressions */
        regexPunycode = /^xn--/,
        regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
    
        /** Error messages */
        errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
        },
    
        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
        floor = Math.floor,
        stringFromCharCode = String.fromCharCode,
    
        /** Temporary variable */
        key;
    
        /*--------------------------------------------------------------------------*/
    
        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error(type) {
            throw new RangeError(errors[type]);
        }
    
        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
                result[length] = fn(array[length]);
            }
            return result;
        }
    
        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
            var parts = string.split('@');
            var result = '';
            if (parts.length > 1) {
                // In email addresses, only the domain name should be punycoded. Leave
                // the local part (i.e. everything up to `@`) intact.
                result = parts[0] + '@';
                string = parts[1];
            }
            // Avoid `split(regex)` for IE8 compatibility. See #17.
            string = string.replace(regexSeparators, '\x2E');
            var labels = string.split('.');
            var encoded = map(labels, fn).join('.');
            return result + encoded;
        }
    
        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value,
                extra;
            while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    // high surrogate, and there is a next character
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                    } else {
                        // unmatched surrogate; only append this code unit, in case the next
                        // code unit is the high surrogate of a surrogate pair
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }
    
        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        function ucs2encode(array) {
            return map(array, function(value) {
                var output = '';
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
            }).join('');
        }
    
        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        }
    
        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        function digitToBasic(digit, flag) {
            //  0..25 map to ASCII a..z or A..Z
            // 26..35 map to ASCII 0..9
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }
    
        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * https://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }
    
        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        function decode(input) {
            // Don't use UCS-2
            var output = [],
                inputLength = input.length,
                out,
                i = 0,
                n = initialN,
                bias = initialBias,
                basic,
                j,
                index,
                oldi,
                w,
                k,
                digit,
                t,
                /** Cached calculation results */
                baseMinusT;
    
            // Handle the basic code points: let `basic` be the number of input code
            // points before the last delimiter, or `0` if there is none, then copy
            // the first basic code points to the output.
    
            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }
    
            for (j = 0; j < basic; ++j) {
                // if it's not a basic code point
                if (input.charCodeAt(j) >= 0x80) {
                    error('not-basic');
                }
                output.push(input.charCodeAt(j));
            }
    
            // Main decoding loop: start just after the last delimiter if any basic code
            // points were copied; start at the beginning otherwise.
    
            for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
    
                // `index` is the index of the next character to be consumed.
                // Decode a generalized variable-length integer into `delta`,
                // which gets added to `i`. The overflow checking is easier
                // if we increase `i` as we go, then subtract off its starting
                // value at the end to obtain `delta`.
                for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
    
                    if (index >= inputLength) {
                        error('invalid-input');
                    }
    
                    digit = basicToDigit(input.charCodeAt(index++));
    
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow');
                    }
    
                    i += digit * w;
                    t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    
                    if (digit < t) {
                        break;
                    }
    
                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error('overflow');
                    }
    
                    w *= baseMinusT;
    
                }
    
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
    
                // `i` was supposed to wrap around from `out` to `0`,
                // incrementing `n` each time, so we'll fix that now:
                if (floor(i / out) > maxInt - n) {
                    error('overflow');
                }
    
                n += floor(i / out);
                i %= out;
    
                // Insert `n` at position `i` of the output
                output.splice(i++, 0, n);
    
            }
    
            return ucs2encode(output);
        }
    
        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        function encode(input) {
            var n,
                delta,
                handledCPCount,
                basicLength,
                bias,
                j,
                m,
                q,
                k,
                t,
                currentValue,
                output = [],
                /** `inputLength` will hold the number of code points in `input`. */
                inputLength,
                /** Cached calculation results */
                handledCPCountPlusOne,
                baseMinusT,
                qMinusT;
    
            // Convert the input in UCS-2 to Unicode
            input = ucs2decode(input);
    
            // Cache the length
            inputLength = input.length;
    
            // Initialize the state
            n = initialN;
            delta = 0;
            bias = initialBias;
    
            // Handle the basic code points
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                }
            }
    
            handledCPCount = basicLength = output.length;
    
            // `handledCPCount` is the number of code points that have been handled;
            // `basicLength` is the number of basic code points.
    
            // Finish the basic string - if it is not empty - with a delimiter
            if (basicLength) {
                output.push(delimiter);
            }
    
            // Main encoding loop:
            while (handledCPCount < inputLength) {
    
                // All non-basic code points < n have been handled already. Find the next
                // larger one:
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }
    
                // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                // but guard against overflow
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                }
    
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
    
                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
    
                    if (currentValue < n && ++delta > maxInt) {
                        error('overflow');
                    }
    
                    if (currentValue == n) {
                        // Represent delta as a generalized variable-length integer
                        for (q = delta, k = base; /* no condition */; k += base) {
                            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                            if (q < t) {
                                break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(
                                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                            );
                            q = floor(qMinusT / baseMinusT);
                        }
    
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
    
                ++delta;
                ++n;
    
            }
            return output.join('');
        }
    
        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        function toUnicode(input) {
            return mapDomain(input, function(string) {
                return regexPunycode.test(string)
                    ? decode(string.slice(4).toLowerCase())
                    : string;
            });
        }
    
        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        function toASCII(input) {
            return mapDomain(input, function(string) {
                return regexNonASCII.test(string)
                    ? 'xn--' + encode(string)
                    : string;
            });
        }
    
        /*--------------------------------------------------------------------------*/
    
        /** Define the public API */
        punycode = {
            /**
             * A string representing the current Punycode.js version number.
             * @memberOf punycode
             * @type String
             */
            'version': '1.4.1',
            /**
             * An object of methods to convert from JavaScript's internal character
             * representation (UCS-2) to Unicode code points, and back.
             * @see <https://mathiasbynens.be/notes/javascript-encoding>
             * @memberOf punycode
             * @type Object
             */
            'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
            },
            'decode': decode,
            'encode': encode,
            'toASCII': toASCII,
            'toUnicode': toUnicode
        };
    
        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (
            true
        ) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return punycode;
            }.call(exports, __webpack_require__, exports, module),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (freeExports && freeModule) {
            if (module.exports == freeExports) {
                // in Node.js, io.js, or RingoJS v0.8.0+
                freeModule.exports = punycode;
            } else {
                // in Narwhal or RingoJS v0.7.0-
                for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
            }
        } else {
            // in Rhino or a web browser
            root.punycode = punycode;
        }
    
    }(this));
    
    /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(108)(module), __webpack_require__(12)))
    
    /***/ }),
    /* 108 */
    /***/ (function(module, exports) {
    
    module.exports = function(module) {
        if(!module.webpackPolyfill) {
            module.deprecate = function() {};
            module.paths = [];
            // module.parent = undefined by default
            if(!module.children) module.children = [];
            Object.defineProperty(module, "loaded", {
                enumerable: true,
                get: function() {
                    return module.l;
                }
            });
            Object.defineProperty(module, "id", {
                enumerable: true,
                get: function() {
                    return module.i;
                }
            });
            module.webpackPolyfill = 1;
        }
        return module;
    };
    
    
    /***/ }),
    /* 109 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    module.exports = {
      isString: function(arg) {
        return typeof(arg) === 'string';
      },
      isObject: function(arg) {
        return typeof(arg) === 'object' && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    
    
    /***/ }),
    /* 110 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.decode = exports.parse = __webpack_require__(111);
    exports.encode = exports.stringify = __webpack_require__(112);
    
    
    /***/ }),
    /* 111 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    
    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    
    module.exports = function(qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};
    
      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }
    
      var regexp = /\+/g;
      qs = qs.split(sep);
    
      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }
    
      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
    
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr, vstr, k, v;
    
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }
    
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
    
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
    
      return obj;
    };
    
    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
    
    /***/ }),
    /* 112 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case 'string':
          return v;
    
        case 'boolean':
          return v ? 'true' : 'false';
    
        case 'number':
          return isFinite(v) ? v : '';
    
        default:
          return '';
      }
    };
    
    module.exports = function(obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }
    
      if (typeof obj === 'object') {
        return map(objectKeys(obj), function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray(obj[k])) {
            return map(obj[k], function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
    
      }
    
      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
             encodeURIComponent(stringifyPrimitive(obj));
    };
    
    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
    function map (xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }
    
    var objectKeys = Object.keys || function (obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
      }
      return res;
    };
    
    
    /***/ }),
    /* 113 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _const = __webpack_require__(0);
    
    var _TickerListener = __webpack_require__(114);
    
    var _TickerListener2 = _interopRequireDefault(_TickerListener);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * A Ticker class that runs an update loop that other objects listen to.
     * This class is composed around listeners
     * meant for execution on the next requested animation frame.
     * Animation frames are requested only when necessary,
     * e.g. When the ticker is started and the emitter has listeners.
     *
     * @class
     * @memberof PIXI.ticker
     */
    var Ticker = function () {
        /**
         *
         */
        function Ticker() {
            var _this = this;
    
            _classCallCheck(this, Ticker);
    
            /**
             * The first listener. All new listeners added are chained on this.
             * @private
             * @type {TickerListener}
             */
            this._head = new _TickerListener2.default(null, null, Infinity);
    
            /**
             * Internal current frame request ID
             * @private
             */
            this._requestId = null;
    
            /**
             * Internal value managed by minFPS property setter and getter.
             * This is the maximum allowed milliseconds between updates.
             * @private
             */
            this._maxElapsedMS = 100;
    
            /**
             * Whether or not this ticker should invoke the method
             * {@link PIXI.ticker.Ticker#start} automatically
             * when a listener is added.
             *
             * @member {boolean}
             * @default false
             */
            this.autoStart = false;
    
            /**
             * Scalar time value from last frame to this frame.
             * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}
             * and is scaled with {@link PIXI.ticker.Ticker#speed}.
             * **Note:** The cap may be exceeded by scaling.
             *
             * @member {number}
             * @default 1
             */
            this.deltaTime = 1;
    
            /**
             * Time elapsed in milliseconds from last frame to this frame.
             * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}
             * is based, this value is neither capped nor scaled.
             * If the platform supports DOMHighResTimeStamp,
             * this value will have a precision of 1 µs.
             * Defaults to target frame time
             *
             * @member {number}
             * @default 16.66
             */
            this.elapsedMS = 1 / _settings2.default.TARGET_FPMS;
    
            /**
             * The last time {@link PIXI.ticker.Ticker#update} was invoked.
             * This value is also reset internally outside of invoking
             * update, but only when a new animation frame is requested.
             * If the platform supports DOMHighResTimeStamp,
             * this value will have a precision of 1 µs.
             *
             * @member {number}
             * @default 0
             */
            this.lastTime = 0;
    
            /**
             * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.
             * @example
             * // Scales ticker.deltaTime to what would be
             * // the equivalent of approximately 120 FPS
             * ticker.speed = 2;
             *
             * @member {number}
             * @default 1
             */
            this.speed = 1;
    
            /**
             * Whether or not this ticker has been started.
             * `true` if {@link PIXI.ticker.Ticker#start} has been called.
             * `false` if {@link PIXI.ticker.Ticker#stop} has been called.
             * While `false`, this value may change to `true` in the
             * event of {@link PIXI.ticker.Ticker#autoStart} being `true`
             * and a listener is added.
             *
             * @member {boolean}
             * @default false
             */
            this.started = false;
    
            /**
             * Internal tick method bound to ticker instance.
             * This is because in early 2015, Function.bind
             * is still 60% slower in high performance scenarios.
             * Also separating frame requests from update method
             * so listeners may be called at any time and with
             * any animation API, just invoke ticker.update(time).
             *
             * @private
             * @param {number} time - Time since last tick.
             */
            this._tick = function (time) {
                _this._requestId = null;
    
                if (_this.started) {
                    // Invoke listeners now
                    _this.update(time);
                    // Listener side effects may have modified ticker state.
                    if (_this.started && _this._requestId === null && _this._head.next) {
                        _this._requestId = requestAnimationFrame(_this._tick);
                    }
                }
            };
        }
    
        /**
         * Conditionally requests a new animation frame.
         * If a frame has not already been requested, and if the internal
         * emitter has listeners, a new frame is requested.
         *
         * @private
         */
    
    
        Ticker.prototype._requestIfNeeded = function _requestIfNeeded() {
            if (this._requestId === null && this._head.next) {
                // ensure callbacks get correct delta
                this.lastTime = performance.now();
                this._requestId = requestAnimationFrame(this._tick);
            }
        };
    
        /**
         * Conditionally cancels a pending animation frame.
         *
         * @private
         */
    
    
        Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded() {
            if (this._requestId !== null) {
                cancelAnimationFrame(this._requestId);
                this._requestId = null;
            }
        };
    
        /**
         * Conditionally requests a new animation frame.
         * If the ticker has been started it checks if a frame has not already
         * been requested, and if the internal emitter has listeners. If these
         * conditions are met, a new frame is requested. If the ticker has not
         * been started, but autoStart is `true`, then the ticker starts now,
         * and continues with the previous conditions to request a new frame.
         *
         * @private
         */
    
    
        Ticker.prototype._startIfPossible = function _startIfPossible() {
            if (this.started) {
                this._requestIfNeeded();
            } else if (this.autoStart) {
                this.start();
            }
        };
    
        /**
         * Register a handler for tick events. Calls continuously unless
         * it is removed or the ticker is stopped.
         *
         * @param {Function} fn - The listener function to be added for updates
         * @param {Function} [context] - The listener context
         * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */
    
    
        Ticker.prototype.add = function add(fn, context) {
            var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;
    
            return this._addListener(new _TickerListener2.default(fn, context, priority));
        };
    
        /**
         * Add a handler for the tick event which is only execute once.
         *
         * @param {Function} fn - The listener function to be added for one update
         * @param {Function} [context] - The listener context
         * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */
    
    
        Ticker.prototype.addOnce = function addOnce(fn, context) {
            var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL;
    
            return this._addListener(new _TickerListener2.default(fn, context, priority, true));
        };
    
        /**
         * Internally adds the event handler so that it can be sorted by priority.
         * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
         * before the rendering.
         *
         * @private
         * @param {TickerListener} listener - Current listener being added.
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */
    
    
        Ticker.prototype._addListener = function _addListener(listener) {
            // For attaching to head
            var current = this._head.next;
            var previous = this._head;
    
            // Add the first item
            if (!current) {
                listener.connect(previous);
            } else {
                // Go from highest to lowest priority
                while (current) {
                    if (listener.priority > current.priority) {
                        listener.connect(previous);
                        break;
                    }
                    previous = current;
                    current = current.next;
                }
    
                // Not yet connected
                if (!listener.previous) {
                    listener.connect(previous);
                }
            }
    
            this._startIfPossible();
    
            return this;
        };
    
        /**
         * Removes any handlers matching the function and context parameters.
         * If no handlers are left after removing, then it cancels the animation frame.
         *
         * @param {Function} fn - The listener function to be removed
         * @param {Function} [context] - The listener context to be removed
         * @returns {PIXI.ticker.Ticker} This instance of a ticker
         */
    
    
        Ticker.prototype.remove = function remove(fn, context) {
            var listener = this._head.next;
    
            while (listener) {
                // We found a match, lets remove it
                // no break to delete all possible matches
                // incase a listener was added 2+ times
                if (listener.match(fn, context)) {
                    listener = listener.destroy();
                } else {
                    listener = listener.next;
                }
            }
    
            if (!this._head.next) {
                this._cancelIfNeeded();
            }
    
            return this;
        };
    
        /**
         * Starts the ticker. If the ticker has listeners
         * a new animation frame is requested at this point.
         */
    
    
        Ticker.prototype.start = function start() {
            if (!this.started) {
                this.started = true;
                this._requestIfNeeded();
            }
        };
    
        /**
         * Stops the ticker. If the ticker has requested
         * an animation frame it is canceled at this point.
         */
    
    
        Ticker.prototype.stop = function stop() {
            if (this.started) {
                this.started = false;
                this._cancelIfNeeded();
            }
        };
    
        /**
         * Destroy the ticker and don't use after this. Calling
         * this method removes all references to internal events.
         */
    
    
        Ticker.prototype.destroy = function destroy() {
            this.stop();
    
            var listener = this._head.next;
    
            while (listener) {
                listener = listener.destroy(true);
            }
    
            this._head.destroy();
            this._head = null;
        };
    
        /**
         * Triggers an update. An update entails setting the
         * current {@link PIXI.ticker.Ticker#elapsedMS},
         * the current {@link PIXI.ticker.Ticker#deltaTime},
         * invoking all listeners with current deltaTime,
         * and then finally setting {@link PIXI.ticker.Ticker#lastTime}
         * with the value of currentTime that was provided.
         * This method will be called automatically by animation
         * frame callbacks if the ticker instance has been started
         * and listeners are added.
         *
         * @param {number} [currentTime=performance.now()] - the current time of execution
         */
    
    
        Ticker.prototype.update = function update() {
            var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
    
            var elapsedMS = void 0;
    
            // If the difference in time is zero or negative, we ignore most of the work done here.
            // If there is no valid difference, then should be no reason to let anyone know about it.
            // A zero delta, is exactly that, nothing should update.
            //
            // The difference in time can be negative, and no this does not mean time traveling.
            // This can be the result of a race condition between when an animation frame is requested
            // on the current JavaScript engine event loop, and when the ticker's start method is invoked
            // (which invokes the internal _requestIfNeeded method). If a frame is requested before
            // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
            // can receive a time argument that can be less than the lastTime value that was set within
            // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
            //
            // This check covers this browser engine timing issue, as well as if consumers pass an invalid
            // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
    
            if (currentTime > this.lastTime) {
                // Save uncapped elapsedMS for measurement
                elapsedMS = this.elapsedMS = currentTime - this.lastTime;
    
                // cap the milliseconds elapsed used for deltaTime
                if (elapsedMS > this._maxElapsedMS) {
                    elapsedMS = this._maxElapsedMS;
                }
    
                this.deltaTime = elapsedMS * _settings2.default.TARGET_FPMS * this.speed;
    
                // Cache a local reference, in-case ticker is destroyed
                // during the emit, we can still check for head.next
                var head = this._head;
    
                // Invoke listeners added to internal emitter
                var listener = head.next;
    
                while (listener) {
                    listener = listener.emit(this.deltaTime);
                }
    
                if (!head.next) {
                    this._cancelIfNeeded();
                }
            } else {
                this.deltaTime = this.elapsedMS = 0;
            }
    
            this.lastTime = currentTime;
        };
    
        /**
         * The frames per second at which this ticker is running.
         * The default is approximately 60 in most modern browsers.
         * **Note:** This does not factor in the value of
         * {@link PIXI.ticker.Ticker#speed}, which is specific
         * to scaling {@link PIXI.ticker.Ticker#deltaTime}.
         *
         * @member {number}
         * @readonly
         */
    
    
        _createClass(Ticker, [{
            key: 'FPS',
            get: function get() {
                return 1000 / this.elapsedMS;
            }
    
            /**
             * Manages the maximum amount of milliseconds allowed to
             * elapse between invoking {@link PIXI.ticker.Ticker#update}.
             * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},
             * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
             * When setting this property it is clamped to a value between
             * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
             *
             * @member {number}
             * @default 10
             */
    
        }, {
            key: 'minFPS',
            get: function get() {
                return 1000 / this._maxElapsedMS;
            },
            set: function set(fps) // eslint-disable-line require-jsdoc
            {
                // Clamp: 0 to TARGET_FPMS
                var minFPMS = Math.min(Math.max(0, fps) / 1000, _settings2.default.TARGET_FPMS);
    
                this._maxElapsedMS = 1 / minFPMS;
            }
        }]);
    
        return Ticker;
    }();
    
    exports.default = Ticker;
    
    /***/ }),
    /* 114 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Internal class for handling the priority sorting of ticker handlers.
     *
     * @private
     * @class
     * @memberof PIXI.ticker
     */
    var TickerListener = function () {
      /**
       * Constructor
       *
       * @param {Function} fn - The listener function to be added for one update
       * @param {Function} [context=null] - The listener context
       * @param {number} [priority=0] - The priority for emitting
       * @param {boolean} [once=false] - If the handler should fire once
       */
      function TickerListener(fn) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    
        _classCallCheck(this, TickerListener);
    
        /**
         * The handler function to execute.
         * @member {Function}
         */
        this.fn = fn;
    
        /**
         * The calling to execute.
         * @member {Function}
         */
        this.context = context;
    
        /**
         * The current priority.
         * @member {number}
         */
        this.priority = priority;
    
        /**
         * If this should only execute once.
         * @member {boolean}
         */
        this.once = once;
    
        /**
         * The next item in chain.
         * @member {TickerListener}
         */
        this.next = null;
    
        /**
         * The previous item in chain.
         * @member {TickerListener}
         */
        this.previous = null;
    
        /**
         * `true` if this listener has been destroyed already.
         * @member {boolean}
         * @private
         */
        this._destroyed = false;
      }
    
      /**
       * Simple compare function to figure out if a function and context match.
       *
       * @param {Function} fn - The listener function to be added for one update
       * @param {Function} context - The listener context
       * @return {boolean} `true` if the listener match the arguments
       */
    
    
      TickerListener.prototype.match = function match(fn, context) {
        context = context || null;
    
        return this.fn === fn && this.context === context;
      };
    
      /**
       * Emit by calling the current function.
       * @param {number} deltaTime - time since the last emit.
       * @return {TickerListener} Next ticker
       */
    
    
      TickerListener.prototype.emit = function emit(deltaTime) {
        if (this.context) {
          this.fn.call(this.context, deltaTime);
        } else {
          this.fn(deltaTime);
        }
    
        var redirect = this.next;
    
        if (this.once) {
          this.destroy(true);
        }
    
        // Soft-destroying should remove
        // the next reference
        if (this._destroyed) {
          this.next = null;
        }
    
        return redirect;
      };
    
      /**
       * Connect to the list.
       * @param {TickerListener} previous - Input node, previous listener
       */
    
    
      TickerListener.prototype.connect = function connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      };
    
      /**
       * Destroy and don't use after this.
       * @param {boolean} [hard = false] `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @return {TickerListener} The listener to redirect while emitting or removing.
       */
    
    
      TickerListener.prototype.destroy = function destroy() {
        var hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    
        this._destroyed = true;
        this.fn = null;
        this.context = null;
    
        // Disconnect, hook up next and previous
        if (this.previous) {
          this.previous.next = this.next;
        }
    
        if (this.next) {
          this.next.previous = this.previous;
        }
    
        // Redirect to the next item
        var redirect = this.previous;
    
        // Remove references
        this.next = hard ? null : redirect;
        this.previous = null;
    
        return redirect;
      };
    
      return TickerListener;
    }();
    
    exports.default = TickerListener;
    
    /***/ }),
    /* 115 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _CanvasRenderer = __webpack_require__(10);
    
    var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
    
    var _const = __webpack_require__(0);
    
    var _math = __webpack_require__(2);
    
    var _CanvasTinter = __webpack_require__(56);
    
    var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var canvasRenderWorldTransform = new _math.Matrix();
    
    /**
     * @author Mat Groves
     *
     * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
     * for creating the original pixi version!
     * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now
     * share 4 bytes on the vertex buffer
     *
     * Heavily inspired by LibGDX's CanvasSpriteRenderer:
     * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java
     */
    
    /**
     * Renderer dedicated to drawing and batching sprites.
     *
     * @class
     * @private
     * @memberof PIXI
     */
    
    var CanvasSpriteRenderer = function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer -The renderer sprite this batch works for.
         */
        function CanvasSpriteRenderer(renderer) {
            _classCallCheck(this, CanvasSpriteRenderer);
    
            this.renderer = renderer;
        }
    
        /**
         * Renders the sprite object.
         *
         * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
         */
    
    
        CanvasSpriteRenderer.prototype.render = function render(sprite) {
            var texture = sprite._texture;
            var renderer = this.renderer;
    
            var width = texture._frame.width;
            var height = texture._frame.height;
    
            var wt = sprite.transform.worldTransform;
            var dx = 0;
            var dy = 0;
    
            if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) {
                return;
            }
    
            renderer.setBlendMode(sprite.blendMode);
    
            //  Ignore null sources
            if (texture.valid) {
                renderer.context.globalAlpha = sprite.worldAlpha;
    
                // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture
                var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;
    
                if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {
                    renderer.context[renderer.smoothProperty] = smoothingEnabled;
                }
    
                if (texture.trim) {
                    dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
                    dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;
                } else {
                    dx = (0.5 - sprite.anchor.x) * texture.orig.width;
                    dy = (0.5 - sprite.anchor.y) * texture.orig.height;
                }
    
                if (texture.rotate) {
                    wt.copy(canvasRenderWorldTransform);
                    wt = canvasRenderWorldTransform;
                    _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
                    // the anchor has already been applied above, so lets set it to zero
                    dx = 0;
                    dy = 0;
                }
    
                dx -= width / 2;
                dy -= height / 2;
    
                // Allow for pixel rounding
                if (renderer.roundPixels) {
                    renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);
    
                    dx = dx | 0;
                    dy = dy | 0;
                } else {
                    renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);
                }
    
                var resolution = texture.baseTexture.resolution;
    
                if (sprite.tint !== 0xFFFFFF) {
                    if (sprite.cachedTint !== sprite.tint) {
                        sprite.cachedTint = sprite.tint;
    
                        // TODO clean up caching - how to clean up the caches?
                        sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint);
                    }
    
                    renderer.context.drawImage(sprite.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
                } else {
                    renderer.context.drawImage(texture.baseTexture.source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
                }
            }
        };
    
        /**
         * destroy the sprite object.
         *
         */
    
    
        CanvasSpriteRenderer.prototype.destroy = function destroy() {
            this.renderer = null;
        };
    
        return CanvasSpriteRenderer;
    }();
    
    exports.default = CanvasSpriteRenderer;
    
    
    _CanvasRenderer2.default.registerPlugin('sprite', CanvasSpriteRenderer);
    
    /***/ }),
    /* 116 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _const = __webpack_require__(0);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * A set of functions used to handle masking.
     *
     * @class
     * @memberof PIXI
     */
    var CanvasMaskManager = function () {
        /**
         * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.
         */
        function CanvasMaskManager(renderer) {
            _classCallCheck(this, CanvasMaskManager);
    
            this.renderer = renderer;
        }
    
        /**
         * This method adds it to the current stack of masks.
         *
         * @param {object} maskData - the maskData that will be pushed
         */
    
    
        CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {
            var renderer = this.renderer;
    
            renderer.context.save();
    
            var cacheAlpha = maskData.alpha;
            var transform = maskData.transform.worldTransform;
            var resolution = renderer.resolution;
    
            renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
    
            // TODO suport sprite alpha masks??
            // lots of effort required. If demand is great enough..
            if (!maskData._texture) {
                this.renderGraphicsShape(maskData);
                renderer.context.clip();
            }
    
            maskData.worldAlpha = cacheAlpha;
        };
    
        /**
         * Renders a PIXI.Graphics shape.
         *
         * @param {PIXI.Graphics} graphics - The object to render.
         */
    
    
        CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {
            var context = this.renderer.context;
            var len = graphics.graphicsData.length;
    
            if (len === 0) {
                return;
            }
    
            context.beginPath();
    
            for (var i = 0; i < len; i++) {
                var data = graphics.graphicsData[i];
                var shape = data.shape;
    
                if (data.type === _const.SHAPES.POLY) {
                    var points = shape.points;
    
                    context.moveTo(points[0], points[1]);
    
                    for (var j = 1; j < points.length / 2; j++) {
                        context.lineTo(points[j * 2], points[j * 2 + 1]);
                    }
    
                    // if the first and last point are the same close the path - much neater :)
                    if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {
                        context.closePath();
                    }
                } else if (data.type === _const.SHAPES.RECT) {
                    context.rect(shape.x, shape.y, shape.width, shape.height);
                    context.closePath();
                } else if (data.type === _const.SHAPES.CIRC) {
                    // TODO - need to be Undefined!
                    context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                    context.closePath();
                } else if (data.type === _const.SHAPES.ELIP) {
                    // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
    
                    var w = shape.width * 2;
                    var h = shape.height * 2;
    
                    var x = shape.x - w / 2;
                    var y = shape.y - h / 2;
    
                    var kappa = 0.5522848;
                    var ox = w / 2 * kappa; // control point offset horizontal
                    var oy = h / 2 * kappa; // control point offset vertical
                    var xe = x + w; // x-end
                    var ye = y + h; // y-end
                    var xm = x + w / 2; // x-middle
                    var ym = y + h / 2; // y-middle
    
                    context.moveTo(x, ym);
                    context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                    context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                    context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                    context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                    context.closePath();
                } else if (data.type === _const.SHAPES.RREC) {
                    var rx = shape.x;
                    var ry = shape.y;
                    var width = shape.width;
                    var height = shape.height;
                    var radius = shape.radius;
    
                    var maxRadius = Math.min(width, height) / 2 | 0;
    
                    radius = radius > maxRadius ? maxRadius : radius;
    
                    context.moveTo(rx, ry + radius);
                    context.lineTo(rx, ry + height - radius);
                    context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                    context.lineTo(rx + width - radius, ry + height);
                    context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                    context.lineTo(rx + width, ry + radius);
                    context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                    context.lineTo(rx + radius, ry);
                    context.quadraticCurveTo(rx, ry, rx, ry + radius);
                    context.closePath();
                }
            }
        };
    
        /**
         * Restores the current drawing context to the state it was before the mask was applied.
         *
         * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.
         */
    
    
        CanvasMaskManager.prototype.popMask = function popMask(renderer) {
            renderer.context.restore();
        };
    
        /**
         * Destroys this canvas mask manager.
         *
         */
    
    
        CanvasMaskManager.prototype.destroy = function destroy() {
            /* empty */
        };
    
        return CanvasMaskManager;
    }();
    
    exports.default = CanvasMaskManager;
    
    /***/ }),
    /* 117 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = mapCanvasBlendModesToPixi;
    
    var _const = __webpack_require__(0);
    
    var _canUseNewCanvasBlendModes = __webpack_require__(55);
    
    var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * Maps blend combinations to Canvas.
     *
     * @memberof PIXI
     * @function mapCanvasBlendModesToPixi
     * @private
     * @param {string[]} [array=[]] - The array to output into.
     * @return {string[]} Mapped modes.
     */
    function mapCanvasBlendModesToPixi() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    
        if ((0, _canUseNewCanvasBlendModes2.default)()) {
            array[_const.BLEND_MODES.NORMAL] = 'source-over';
            array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
            array[_const.BLEND_MODES.MULTIPLY] = 'multiply';
            array[_const.BLEND_MODES.SCREEN] = 'screen';
            array[_const.BLEND_MODES.OVERLAY] = 'overlay';
            array[_const.BLEND_MODES.DARKEN] = 'darken';
            array[_const.BLEND_MODES.LIGHTEN] = 'lighten';
            array[_const.BLEND_MODES.COLOR_DODGE] = 'color-dodge';
            array[_const.BLEND_MODES.COLOR_BURN] = 'color-burn';
            array[_const.BLEND_MODES.HARD_LIGHT] = 'hard-light';
            array[_const.BLEND_MODES.SOFT_LIGHT] = 'soft-light';
            array[_const.BLEND_MODES.DIFFERENCE] = 'difference';
            array[_const.BLEND_MODES.EXCLUSION] = 'exclusion';
            array[_const.BLEND_MODES.HUE] = 'hue';
            array[_const.BLEND_MODES.SATURATION] = 'saturate';
            array[_const.BLEND_MODES.COLOR] = 'color';
            array[_const.BLEND_MODES.LUMINOSITY] = 'luminosity';
        } else {
            // this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'
            array[_const.BLEND_MODES.NORMAL] = 'source-over';
            array[_const.BLEND_MODES.ADD] = 'lighter'; // IS THIS OK???
            array[_const.BLEND_MODES.MULTIPLY] = 'source-over';
            array[_const.BLEND_MODES.SCREEN] = 'source-over';
            array[_const.BLEND_MODES.OVERLAY] = 'source-over';
            array[_const.BLEND_MODES.DARKEN] = 'source-over';
            array[_const.BLEND_MODES.LIGHTEN] = 'source-over';
            array[_const.BLEND_MODES.COLOR_DODGE] = 'source-over';
            array[_const.BLEND_MODES.COLOR_BURN] = 'source-over';
            array[_const.BLEND_MODES.HARD_LIGHT] = 'source-over';
            array[_const.BLEND_MODES.SOFT_LIGHT] = 'source-over';
            array[_const.BLEND_MODES.DIFFERENCE] = 'source-over';
            array[_const.BLEND_MODES.EXCLUSION] = 'source-over';
            array[_const.BLEND_MODES.HUE] = 'source-over';
            array[_const.BLEND_MODES.SATURATION] = 'source-over';
            array[_const.BLEND_MODES.COLOR] = 'source-over';
            array[_const.BLEND_MODES.LUMINOSITY] = 'source-over';
        }
    
        return array;
    }
    
    /***/ }),
    /* 118 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _ObjectRenderer2 = __webpack_require__(13);
    
    var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);
    
    var _WebGLRenderer = __webpack_require__(14);
    
    var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);
    
    var _createIndicesForQuads = __webpack_require__(60);
    
    var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);
    
    var _generateMultiTextureShader = __webpack_require__(131);
    
    var _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);
    
    var _checkMaxIfStatmentsInShader = __webpack_require__(132);
    
    var _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);
    
    var _BatchBuffer = __webpack_require__(133);
    
    var _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
    
    var _bitTwiddle = __webpack_require__(27);
    
    var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var TICK = 0;
    var TEXTURE_TICK = 0;
    
    /**
     * Renderer dedicated to drawing and batching sprites.
     *
     * @class
     * @private
     * @memberof PIXI
     * @extends PIXI.ObjectRenderer
     */
    
    var SpriteRenderer = function (_ObjectRenderer) {
        _inherits(SpriteRenderer, _ObjectRenderer);
    
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.
         */
        function SpriteRenderer(renderer) {
            _classCallCheck(this, SpriteRenderer);
    
            /**
             * Number of values sent in the vertex buffer.
             * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
             *
             * @member {number}
             */
            var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));
    
            _this.vertSize = 5;
    
            /**
             * The size of the vertex information in bytes.
             *
             * @member {number}
             */
            _this.vertByteSize = _this.vertSize * 4;
    
            /**
             * The number of images in the SpriteRenderer before it flushes.
             *
             * @member {number}
             */
            _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
    
            // the total number of bytes in our batch
            // let numVerts = this.size * 4 * this.vertByteSize;
    
            _this.buffers = [];
            for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {
                _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));
            }
    
            /**
             * Holds the indices of the geometry (quads) to draw
             *
             * @member {Uint16Array}
             */
            _this.indices = (0, _createIndicesForQuads2.default)(_this.size);
    
            /**
             * The default shaders that is used if a sprite doesn't have a more specific one.
             * there is a shader for each number of textures that can be rendererd.
             * These shaders will also be generated on the fly as required.
             * @member {PIXI.Shader[]}
             */
            _this.shader = null;
    
            _this.currentIndex = 0;
            _this.groups = [];
    
            for (var k = 0; k < _this.size; k++) {
                _this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };
            }
    
            _this.sprites = [];
    
            _this.vertexBuffers = [];
            _this.vaos = [];
    
            _this.vaoMax = 2;
            _this.vertexCount = 0;
    
            _this.renderer.on('prerender', _this.onPrerender, _this);
            return _this;
        }
    
        /**
         * Sets up the renderer context and necessary buffers.
         *
         * @private
         */
    
    
        SpriteRenderer.prototype.onContextChange = function onContextChange() {
            var gl = this.renderer.gl;
    
            if (this.renderer.legacy) {
                this.MAX_TEXTURES = 1;
            } else {
                // step 1: first check max textures the GPU can handle.
                this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES);
    
                // step 2: check the maximum number of if statements the shader can have too..
                this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);
            }
    
            this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES);
    
            // create a couple of buffers
            this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);
    
            // we use the second shader as the first one depending on your browser may omit aTextureId
            // as it is not used by the shader so is optimized out.
    
            this.renderer.bindVao(null);
    
            var attrs = this.shader.attributes;
    
            for (var i = 0; i < this.vaoMax; i++) {
                /* eslint-disable max-len */
                var vertexBuffer = this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);
                /* eslint-enable max-len */
    
                // build the vao object that will render..
                var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);
    
                if (attrs.aTextureId) {
                    vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
                }
    
                this.vaos[i] = vao;
            }
    
            this.vao = this.vaos[0];
            this.currentBlendMode = 99999;
    
            this.boundTextures = new Array(this.MAX_TEXTURES);
        };
    
        /**
         * Called before the renderer starts rendering.
         *
         */
    
    
        SpriteRenderer.prototype.onPrerender = function onPrerender() {
            this.vertexCount = 0;
        };
    
        /**
         * Renders the sprite object.
         *
         * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
         */
    
    
        SpriteRenderer.prototype.render = function render(sprite) {
            // TODO set blend modes..
            // check texture..
            if (this.currentIndex >= this.size) {
                this.flush();
            }
    
            // get the uvs for the texture
    
            // if the uvs have not updated then no point rendering just yet!
            if (!sprite._texture._uvs) {
                return;
            }
    
            // push a texture.
            // increment the batchsize
            this.sprites[this.currentIndex++] = sprite;
        };
    
        /**
         * Renders the content and empties the current batch.
         *
         */
    
    
        SpriteRenderer.prototype.flush = function flush() {
            if (this.currentIndex === 0) {
                return;
            }
    
            var gl = this.renderer.gl;
            var MAX_TEXTURES = this.MAX_TEXTURES;
    
            var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);
            var log2 = _bitTwiddle2.default.log2(np2);
            var buffer = this.buffers[log2];
    
            var sprites = this.sprites;
            var groups = this.groups;
    
            var float32View = buffer.float32View;
            var uint32View = buffer.uint32View;
    
            var boundTextures = this.boundTextures;
            var rendererBoundTextures = this.renderer.boundTextures;
            var touch = this.renderer.textureGC.count;
    
            var index = 0;
            var nextTexture = void 0;
            var currentTexture = void 0;
            var groupCount = 1;
            var textureCount = 0;
            var currentGroup = groups[0];
            var vertexData = void 0;
            var uvs = void 0;
            var blendMode = sprites[0].blendMode;
    
            currentGroup.textureCount = 0;
            currentGroup.start = 0;
            currentGroup.blend = blendMode;
    
            TICK++;
    
            var i = void 0;
    
            // copy textures..
            for (i = 0; i < MAX_TEXTURES; ++i) {
                boundTextures[i] = rendererBoundTextures[i];
                boundTextures[i]._virtalBoundId = i;
            }
    
            for (i = 0; i < this.currentIndex; ++i) {
                // upload the sprite elemetns...
                // they have all ready been calculated so we just need to push them into the buffer.
                var sprite = sprites[i];
    
                nextTexture = sprite._texture.baseTexture;
    
                if (blendMode !== sprite.blendMode) {
                    // finish a group..
                    blendMode = sprite.blendMode;
    
                    // force the batch to break!
                    currentTexture = null;
                    textureCount = MAX_TEXTURES;
                    TICK++;
                }
    
                if (currentTexture !== nextTexture) {
                    currentTexture = nextTexture;
    
                    if (nextTexture._enabled !== TICK) {
                        if (textureCount === MAX_TEXTURES) {
                            TICK++;
    
                            currentGroup.size = i - currentGroup.start;
    
                            textureCount = 0;
    
                            currentGroup = groups[groupCount++];
                            currentGroup.blend = blendMode;
                            currentGroup.textureCount = 0;
                            currentGroup.start = i;
                        }
    
                        nextTexture.touched = touch;
    
                        if (nextTexture._virtalBoundId === -1) {
                            for (var j = 0; j < MAX_TEXTURES; ++j) {
                                var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;
    
                                var t = boundTextures[tIndex];
    
                                if (t._enabled !== TICK) {
                                    TEXTURE_TICK++;
    
                                    t._virtalBoundId = -1;
    
                                    nextTexture._virtalBoundId = tIndex;
    
                                    boundTextures[tIndex] = nextTexture;
                                    break;
                                }
                            }
                        }
    
                        nextTexture._enabled = TICK;
    
                        currentGroup.textureCount++;
                        currentGroup.ids[textureCount] = nextTexture._virtalBoundId;
                        currentGroup.textures[textureCount++] = nextTexture;
                    }
                }
    
                vertexData = sprite.vertexData;
    
                // TODO this sum does not need to be set each frame..
                uvs = sprite._texture._uvs.uvsUint32;
    
                if (this.renderer.roundPixels) {
                    var resolution = this.renderer.resolution;
    
                    // xy
                    float32View[index] = (vertexData[0] * resolution | 0) / resolution;
                    float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution;
    
                    // xy
                    float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;
                    float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution;
    
                    // xy
                    float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;
                    float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution;
    
                    // xy
                    float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;
                    float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution;
                } else {
                    // xy
                    float32View[index] = vertexData[0];
                    float32View[index + 1] = vertexData[1];
    
                    // xy
                    float32View[index + 5] = vertexData[2];
                    float32View[index + 6] = vertexData[3];
    
                    // xy
                    float32View[index + 10] = vertexData[4];
                    float32View[index + 11] = vertexData[5];
    
                    // xy
                    float32View[index + 15] = vertexData[6];
                    float32View[index + 16] = vertexData[7];
                }
    
                uint32View[index + 2] = uvs[0];
                uint32View[index + 7] = uvs[1];
                uint32View[index + 12] = uvs[2];
                uint32View[index + 17] = uvs[3];
    
                /* eslint-disable max-len */
                uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = sprite._tintRGB + (Math.min(sprite.worldAlpha, 1) * 255 << 24);
    
                float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;
                /* eslint-enable max-len */
    
                index += 20;
            }
    
            currentGroup.size = i - currentGroup.start;
    
            if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
                // this is still needed for IOS performance..
                // it really does not like uploading to the same buffer in a single frame!
                if (this.vaoMax <= this.vertexCount) {
                    this.vaoMax++;
    
                    var attrs = this.shader.attributes;
    
                    /* eslint-disable max-len */
                    var vertexBuffer = this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);
                    /* eslint-enable max-len */
    
                    // build the vao object that will render..
                    var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);
    
                    if (attrs.aTextureId) {
                        vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);
                    }
    
                    this.vaos[this.vertexCount] = vao;
                }
    
                this.renderer.bindVao(this.vaos[this.vertexCount]);
    
                this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);
    
                this.vertexCount++;
            } else {
                // lets use the faster option, always use buffer number 0
                this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);
            }
    
            for (i = 0; i < MAX_TEXTURES; ++i) {
                rendererBoundTextures[i]._virtalBoundId = -1;
            }
    
            // render the groups..
            for (i = 0; i < groupCount; ++i) {
                var group = groups[i];
                var groupTextureCount = group.textureCount;
    
                for (var _j = 0; _j < groupTextureCount; _j++) {
                    currentTexture = group.textures[_j];
    
                    // reset virtual ids..
                    // lets do a quick check..
                    if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {
                        this.renderer.bindTexture(currentTexture, group.ids[_j], true);
                    }
    
                    // reset the virtualId..
                    currentTexture._virtalBoundId = -1;
                }
    
                // set the blend mode..
                this.renderer.state.setBlendMode(group.blend);
    
                gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);
            }
    
            // reset elements for the next flush
            this.currentIndex = 0;
        };
    
        /**
         * Starts a new sprite batch.
         */
    
    
        SpriteRenderer.prototype.start = function start() {
            this.renderer.bindShader(this.shader);
    
            if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
                // bind buffer #0, we don't need others
                this.renderer.bindVao(this.vaos[this.vertexCount]);
    
                this.vertexBuffers[this.vertexCount].bind();
            }
        };
    
        /**
         * Stops and flushes the current batch.
         *
         */
    
    
        SpriteRenderer.prototype.stop = function stop() {
            this.flush();
        };
    
        /**
         * Destroys the SpriteRenderer.
         *
         */
    
    
        SpriteRenderer.prototype.destroy = function destroy() {
            for (var i = 0; i < this.vaoMax; i++) {
                if (this.vertexBuffers[i]) {
                    this.vertexBuffers[i].destroy();
                }
                if (this.vaos[i]) {
                    this.vaos[i].destroy();
                }
            }
    
            if (this.indexBuffer) {
                this.indexBuffer.destroy();
            }
    
            this.renderer.off('prerender', this.onPrerender, this);
    
            _ObjectRenderer.prototype.destroy.call(this);
    
            if (this.shader) {
                this.shader.destroy();
                this.shader = null;
            }
    
            this.vertexBuffers = null;
            this.vaos = null;
            this.indexBuffer = null;
            this.indices = null;
    
            this.sprites = null;
    
            for (var _i = 0; _i < this.buffers.length; ++_i) {
                this.buffers[_i].destroy();
            }
        };
    
        return SpriteRenderer;
    }(_ObjectRenderer3.default);
    
    exports.default = SpriteRenderer;
    
    
    _WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);
    
    /***/ }),
    /* 119 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _WebGLManager2 = __webpack_require__(11);
    
    var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);
    
    var _SpriteMaskFilter = __webpack_require__(57);
    
    var _SpriteMaskFilter2 = _interopRequireDefault(_SpriteMaskFilter);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * @class
     * @extends PIXI.WebGLManager
     * @memberof PIXI
     */
    var MaskManager = function (_WebGLManager) {
        _inherits(MaskManager, _WebGLManager);
    
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function MaskManager(renderer) {
            _classCallCheck(this, MaskManager);
    
            // TODO - we don't need both!
            var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));
    
            _this.scissor = false;
            _this.scissorData = null;
            _this.scissorRenderTarget = null;
    
            _this.enableScissor = true;
    
            _this.alphaMaskPool = [];
            _this.alphaMaskIndex = 0;
            return _this;
        }
    
        /**
         * Applies the Mask and adds it to the current filter stack.
         *
         * @param {PIXI.DisplayObject} target - Display Object to push the mask to
         * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
         */
    
    
        MaskManager.prototype.pushMask = function pushMask(target, maskData) {
            // TODO the root check means scissor rect will not
            // be used on render textures more info here:
            // https://github.com/pixijs/pixi.js/pull/3545
    
            if (maskData.texture) {
                this.pushSpriteMask(target, maskData);
            } else if (this.enableScissor && !this.scissor && this.renderer._activeRenderTarget.root && !this.renderer.stencilManager.stencilMaskStack.length && maskData.isFastRect()) {
                var matrix = maskData.worldTransform;
    
                var rot = Math.atan2(matrix.b, matrix.a);
    
                // use the nearest degree!
                rot = Math.round(rot * (180 / Math.PI));
    
                if (rot % 90) {
                    this.pushStencilMask(maskData);
                } else {
                    this.pushScissorMask(target, maskData);
                }
            } else {
                this.pushStencilMask(maskData);
            }
        };
    
        /**
         * Removes the last mask from the mask stack and doesn't return it.
         *
         * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
         * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
         */
    
    
        MaskManager.prototype.popMask = function popMask(target, maskData) {
            if (maskData.texture) {
                this.popSpriteMask(target, maskData);
            } else if (this.enableScissor && !this.renderer.stencilManager.stencilMaskStack.length) {
                this.popScissorMask(target, maskData);
            } else {
                this.popStencilMask(target, maskData);
            }
        };
    
        /**
         * Applies the Mask and adds it to the current filter stack.
         *
         * @param {PIXI.RenderTarget} target - Display Object to push the sprite mask to
         * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
         */
    
    
        MaskManager.prototype.pushSpriteMask = function pushSpriteMask(target, maskData) {
            var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
    
            if (!alphaMaskFilter) {
                alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new _SpriteMaskFilter2.default(maskData)];
            }
    
            alphaMaskFilter[0].resolution = this.renderer.resolution;
            alphaMaskFilter[0].maskSprite = maskData;
    
            // TODO - may cause issues!
            target.filterArea = maskData.getBounds(true);
    
            this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
    
            this.alphaMaskIndex++;
        };
    
        /**
         * Removes the last filter from the filter stack and doesn't return it.
         *
         */
    
    
        MaskManager.prototype.popSpriteMask = function popSpriteMask() {
            this.renderer.filterManager.popFilter();
            this.alphaMaskIndex--;
        };
    
        /**
         * Applies the Mask and adds it to the current filter stack.
         *
         * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
         */
    
    
        MaskManager.prototype.pushStencilMask = function pushStencilMask(maskData) {
            this.renderer.currentRenderer.stop();
            this.renderer.stencilManager.pushStencil(maskData);
        };
    
        /**
         * Removes the last filter from the filter stack and doesn't return it.
         *
         */
    
    
        MaskManager.prototype.popStencilMask = function popStencilMask() {
            this.renderer.currentRenderer.stop();
            this.renderer.stencilManager.popStencil();
        };
    
        /**
         *
         * @param {PIXI.DisplayObject} target - Display Object to push the mask to
         * @param {PIXI.Graphics} maskData - The masking data.
         */
    
    
        MaskManager.prototype.pushScissorMask = function pushScissorMask(target, maskData) {
            maskData.renderable = true;
    
            var renderTarget = this.renderer._activeRenderTarget;
    
            var bounds = maskData.getBounds();
    
            bounds.fit(renderTarget.size);
            maskData.renderable = false;
    
            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
    
            var resolution = this.renderer.resolution;
    
            this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);
    
            this.scissorRenderTarget = renderTarget;
            this.scissorData = maskData;
            this.scissor = true;
        };
    
        /**
         *
         *
         */
    
    
        MaskManager.prototype.popScissorMask = function popScissorMask() {
            this.scissorRenderTarget = null;
            this.scissorData = null;
            this.scissor = false;
    
            // must be scissor!
            var gl = this.renderer.gl;
    
            gl.disable(gl.SCISSOR_TEST);
        };
    
        return MaskManager;
    }(_WebGLManager3.default);
    
    exports.default = MaskManager;
    
    /***/ }),
    /* 120 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = extractUniformsFromSrc;
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var defaultValue = _pixiGlCore2.default.shader.defaultValue;
    
    function extractUniformsFromSrc(vertexSrc, fragmentSrc, mask) {
        var vertUniforms = extractUniformsFromString(vertexSrc, mask);
        var fragUniforms = extractUniformsFromString(fragmentSrc, mask);
    
        return Object.assign(vertUniforms, fragUniforms);
    }
    
    function extractUniformsFromString(string) {
        var maskRegex = new RegExp('^(projectionMatrix|uSampler|filterArea|filterClamp)$');
    
        var uniforms = {};
        var nameSplit = void 0;
    
        // clean the lines a little - remove extra spaces / tabs etc
        // then split along ';'
        var lines = string.replace(/\s+/g, ' ').split(/\s*;\s*/);
    
        // loop through..
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
    
            if (line.indexOf('uniform') > -1) {
                var splitLine = line.split(' ');
                var type = splitLine[1];
    
                var name = splitLine[2];
                var size = 1;
    
                if (name.indexOf('[') > -1) {
                    // array!
                    nameSplit = name.split(/\[|]/);
                    name = nameSplit[0];
                    size *= Number(nameSplit[1]);
                }
    
                if (!name.match(maskRegex)) {
                    uniforms[name] = {
                        value: defaultValue(type, size),
                        name: name,
                        type: type
                    };
                }
            }
        }
    
        return uniforms;
    }
    
    /***/ }),
    /* 121 */
    /***/ (function(module, exports) {
    
    // shim for using process in browser
    var process = module.exports = {};
    
    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.
    
    var cachedSetTimeout;
    var cachedClearTimeout;
    
    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    
    
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    
    
    
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    
    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
    
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    
    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };
    
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};
    
    function noop() {}
    
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    
    process.listeners = function (name) { return [] }
    
    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };
    
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    
    
    /***/ }),
    /* 122 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _WebGLManager2 = __webpack_require__(11);
    
    var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * @class
     * @extends PIXI.WebGLManager
     * @memberof PIXI
     */
    var StencilManager = function (_WebGLManager) {
        _inherits(StencilManager, _WebGLManager);
    
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function StencilManager(renderer) {
            _classCallCheck(this, StencilManager);
    
            var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));
    
            _this.stencilMaskStack = null;
            return _this;
        }
    
        /**
         * Changes the mask stack that is used by this manager.
         *
         * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
         */
    
    
        StencilManager.prototype.setMaskStack = function setMaskStack(stencilMaskStack) {
            this.stencilMaskStack = stencilMaskStack;
    
            var gl = this.renderer.gl;
    
            if (stencilMaskStack.length === 0) {
                gl.disable(gl.STENCIL_TEST);
            } else {
                gl.enable(gl.STENCIL_TEST);
            }
        };
    
        /**
         * Applies the Mask and adds it to the current filter stack. @alvin
         *
         * @param {PIXI.Graphics} graphics - The mask
         */
    
    
        StencilManager.prototype.pushStencil = function pushStencil(graphics) {
            this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
    
            this.renderer._activeRenderTarget.attachStencilBuffer();
    
            var gl = this.renderer.gl;
            var sms = this.stencilMaskStack;
    
            if (sms.length === 0) {
                gl.enable(gl.STENCIL_TEST);
                gl.clear(gl.STENCIL_BUFFER_BIT);
                gl.stencilFunc(gl.ALWAYS, 1, 1);
            }
    
            sms.push(graphics);
    
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    
            this.renderer.plugins.graphics.render(graphics);
    
            gl.colorMask(true, true, true, true);
            gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        };
    
        /**
         * TODO @alvin
         */
    
    
        StencilManager.prototype.popStencil = function popStencil() {
            this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
    
            var gl = this.renderer.gl;
            var sms = this.stencilMaskStack;
    
            var graphics = sms.pop();
    
            if (sms.length === 0) {
                // the stack is empty!
                gl.disable(gl.STENCIL_TEST);
            } else {
                gl.colorMask(false, false, false, false);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
    
                this.renderer.plugins.graphics.render(graphics);
    
                gl.colorMask(true, true, true, true);
                gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            }
        };
    
        /**
         * Destroys the mask stack.
         *
         */
    
    
        StencilManager.prototype.destroy = function destroy() {
            _WebGLManager3.default.prototype.destroy.call(this);
    
            this.stencilMaskStack.stencilStack = null;
        };
    
        return StencilManager;
    }(_WebGLManager3.default);
    
    exports.default = StencilManager;
    
    /***/ }),
    /* 123 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _WebGLManager2 = __webpack_require__(11);
    
    var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);
    
    var _RenderTarget = __webpack_require__(15);
    
    var _RenderTarget2 = _interopRequireDefault(_RenderTarget);
    
    var _Quad = __webpack_require__(59);
    
    var _Quad2 = _interopRequireDefault(_Quad);
    
    var _math = __webpack_require__(2);
    
    var _Shader = __webpack_require__(16);
    
    var _Shader2 = _interopRequireDefault(_Shader);
    
    var _filterTransforms = __webpack_require__(124);
    
    var filterTransforms = _interopRequireWildcard(_filterTransforms);
    
    var _bitTwiddle = __webpack_require__(27);
    
    var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * @ignore
     * @class
     */
    var FilterState =
    /**
     *
     */
    function FilterState() {
        _classCallCheck(this, FilterState);
    
        this.renderTarget = null;
        this.sourceFrame = new _math.Rectangle();
        this.destinationFrame = new _math.Rectangle();
        this.filters = [];
        this.target = null;
        this.resolution = 1;
    };
    
    /**
     * @class
     * @memberof PIXI
     * @extends PIXI.WebGLManager
     */
    
    
    var FilterManager = function (_WebGLManager) {
        _inherits(FilterManager, _WebGLManager);
    
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function FilterManager(renderer) {
            _classCallCheck(this, FilterManager);
    
            var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));
    
            _this.gl = _this.renderer.gl;
            // know about sprites!
            _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);
    
            _this.shaderCache = {};
            // todo add default!
            _this.pool = {};
    
            _this.filterData = null;
            return _this;
        }
    
        /**
         * Adds a new filter to the manager.
         *
         * @param {PIXI.DisplayObject} target - The target of the filter to render.
         * @param {PIXI.Filter[]} filters - The filters to apply.
         */
    
    
        FilterManager.prototype.pushFilter = function pushFilter(target, filters) {
            var renderer = this.renderer;
    
            var filterData = this.filterData;
    
            if (!filterData) {
                filterData = this.renderer._activeRenderTarget.filterStack;
    
                // add new stack
                var filterState = new FilterState();
    
                filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;
                filterState.renderTarget = renderer._activeRenderTarget;
    
                this.renderer._activeRenderTarget.filterData = filterData = {
                    index: 0,
                    stack: [filterState]
                };
    
                this.filterData = filterData;
            }
    
            // get the current filter state..
            var currentState = filterData.stack[++filterData.index];
    
            if (!currentState) {
                currentState = filterData.stack[filterData.index] = new FilterState();
            }
    
            // for now we go off the filter of the first resolution..
            var resolution = filters[0].resolution;
            var padding = filters[0].padding | 0;
            var targetBounds = target.filterArea || target.getBounds(true);
            var sourceFrame = currentState.sourceFrame;
            var destinationFrame = currentState.destinationFrame;
    
            sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;
            sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;
            sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;
            sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;
    
            if (filterData.stack[0].renderTarget.transform) {//
    
                // TODO we should fit the rect around the transform..
            } else if (filters[0].autoFit) {
                sourceFrame.fit(filterData.stack[0].destinationFrame);
            }
    
            // lets apply the padding After we fit the element to the screen.
            // this should stop the strange side effects that can occur when cropping to the edges
            sourceFrame.pad(padding);
    
            destinationFrame.width = sourceFrame.width;
            destinationFrame.height = sourceFrame.height;
    
            // lets play the padding after we fit the element to the screen.
            // this should stop the strange side effects that can occur when cropping to the edges
    
            var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);
    
            currentState.target = target;
            currentState.filters = filters;
            currentState.resolution = resolution;
            currentState.renderTarget = renderTarget;
    
            // bind the render target to draw the shape in the top corner..
    
            renderTarget.setFrame(destinationFrame, sourceFrame);
    
            // bind the render target
            renderer.bindRenderTarget(renderTarget);
            renderTarget.clear();
        };
    
        /**
         * Pops off the filter and applies it.
         *
         */
    
    
        FilterManager.prototype.popFilter = function popFilter() {
            var filterData = this.filterData;
    
            var lastState = filterData.stack[filterData.index - 1];
            var currentState = filterData.stack[filterData.index];
    
            this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();
    
            var filters = currentState.filters;
    
            if (filters.length === 1) {
                filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);
                this.freePotRenderTarget(currentState.renderTarget);
            } else {
                var flip = currentState.renderTarget;
                var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);
    
                flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);
    
                // finally lets clear the render target before drawing to it..
                flop.clear();
    
                var i = 0;
    
                for (i = 0; i < filters.length - 1; ++i) {
                    filters[i].apply(this, flip, flop, true, currentState);
    
                    var t = flip;
    
                    flip = flop;
                    flop = t;
                }
    
                filters[i].apply(this, flip, lastState.renderTarget, false, currentState);
    
                this.freePotRenderTarget(flip);
                this.freePotRenderTarget(flop);
            }
    
            filterData.index--;
    
            if (filterData.index === 0) {
                this.filterData = null;
            }
        };
    
        /**
         * Draws a filter.
         *
         * @param {PIXI.Filter} filter - The filter to draw.
         * @param {PIXI.RenderTarget} input - The input render target.
         * @param {PIXI.RenderTarget} output - The target to output to.
         * @param {boolean} clear - Should the output be cleared before rendering to it
         */
    
    
        FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {
            var renderer = this.renderer;
            var gl = renderer.gl;
    
            var shader = filter.glShaders[renderer.CONTEXT_UID];
    
            // cacheing..
            if (!shader) {
                if (filter.glShaderKey) {
                    shader = this.shaderCache[filter.glShaderKey];
    
                    if (!shader) {
                        shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);
    
                        filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;
                    }
                } else {
                    shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);
                }
    
                // TODO - this only needs to be done once?
                renderer.bindVao(null);
    
                this.quad.initVao(shader);
            }
    
            renderer.bindVao(this.quad.vao);
    
            renderer.bindRenderTarget(output);
    
            if (clear) {
                gl.disable(gl.SCISSOR_TEST);
                renderer.clear(); // [1, 1, 1, 1]);
                gl.enable(gl.SCISSOR_TEST);
            }
    
            // in case the render target is being masked using a scissor rect
            if (output === renderer.maskManager.scissorRenderTarget) {
                renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);
            }
    
            renderer.bindShader(shader);
    
            // free unit 0 for us, doesn't matter what was there
            // don't try to restore it, because syncUniforms can upload it to another slot
            // and it'll be a problem
            var tex = this.renderer.emptyTextures[0];
    
            this.renderer.boundTextures[0] = tex;
            // this syncs the pixi filters  uniforms with glsl uniforms
            this.syncUniforms(shader, filter);
    
            renderer.state.setBlendMode(filter.blendMode);
    
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);
    
            this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);
    
            gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
        };
    
        /**
         * Uploads the uniforms of the filter.
         *
         * @param {GLShader} shader - The underlying gl shader.
         * @param {PIXI.Filter} filter - The filter we are synchronizing.
         */
    
    
        FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {
            var uniformData = filter.uniformData;
            var uniforms = filter.uniforms;
    
            // 0 is reserved for the pixi texture so we start at 1!
            var textureCount = 1;
            var currentState = void 0;
    
            // filterArea and filterClamp that are handled by FilterManager directly
            // they must not appear in uniformData
    
            if (shader.uniforms.filterArea) {
                currentState = this.filterData.stack[this.filterData.index];
    
                var filterArea = shader.uniforms.filterArea;
    
                filterArea[0] = currentState.renderTarget.size.width;
                filterArea[1] = currentState.renderTarget.size.height;
                filterArea[2] = currentState.sourceFrame.x;
                filterArea[3] = currentState.sourceFrame.y;
    
                shader.uniforms.filterArea = filterArea;
            }
    
            // use this to clamp displaced texture coords so they belong to filterArea
            // see displacementFilter fragment shader for an example
            if (shader.uniforms.filterClamp) {
                currentState = currentState || this.filterData.stack[this.filterData.index];
    
                var filterClamp = shader.uniforms.filterClamp;
    
                filterClamp[0] = 0;
                filterClamp[1] = 0;
                filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;
                filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;
    
                shader.uniforms.filterClamp = filterClamp;
            }
    
            // TODO Cacheing layer..
            for (var i in uniformData) {
                if (uniformData[i].type === 'sampler2D' && uniforms[i] !== 0) {
                    if (uniforms[i].baseTexture) {
                        shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);
                    } else {
                        shader.uniforms[i] = textureCount;
    
                        // TODO
                        // this is helpful as renderTargets can also be set.
                        // Although thinking about it, we could probably
                        // make the filter texture cache return a RenderTexture
                        // rather than a renderTarget
                        var gl = this.renderer.gl;
    
                        this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];
                        gl.activeTexture(gl.TEXTURE0 + textureCount);
    
                        uniforms[i].texture.bind();
                    }
    
                    textureCount++;
                } else if (uniformData[i].type === 'mat3') {
                    // check if its pixi matrix..
                    if (uniforms[i].a !== undefined) {
                        shader.uniforms[i] = uniforms[i].toArray(true);
                    } else {
                        shader.uniforms[i] = uniforms[i];
                    }
                } else if (uniformData[i].type === 'vec2') {
                    // check if its a point..
                    if (uniforms[i].x !== undefined) {
                        var val = shader.uniforms[i] || new Float32Array(2);
    
                        val[0] = uniforms[i].x;
                        val[1] = uniforms[i].y;
                        shader.uniforms[i] = val;
                    } else {
                        shader.uniforms[i] = uniforms[i];
                    }
                } else if (uniformData[i].type === 'float') {
                    if (shader.uniforms.data[i].value !== uniformData[i]) {
                        shader.uniforms[i] = uniforms[i];
                    }
                } else {
                    shader.uniforms[i] = uniforms[i];
                }
            }
        };
    
        /**
         * Gets a render target from the pool, or creates a new one.
         *
         * @param {boolean} clear - Should we clear the render texture when we get it?
         * @param {number} resolution - The resolution of the target.
         * @return {PIXI.RenderTarget} The new render target
         */
    
    
        FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) {
            var currentState = this.filterData.stack[this.filterData.index];
            var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);
    
            renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);
    
            return renderTarget;
        };
    
        /**
         * Returns a render target to the pool.
         *
         * @param {PIXI.RenderTarget} renderTarget - The render target to return.
         */
    
    
        FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) {
            this.freePotRenderTarget(renderTarget);
        };
    
        /**
         * Calculates the mapped matrix.
         *
         * TODO playing around here.. this is temporary - (will end up in the shader)
         * this returns a matrix that will normalise map filter cords in the filter to screen space
         *
         * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
         * @return {PIXI.Matrix} The mapped matrix.
         */
    
    
        FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) {
            var currentState = this.filterData.stack[this.filterData.index];
    
            return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);
        };
    
        /**
         * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea
         *
         * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
         * @return {PIXI.Matrix} The mapped matrix.
         */
    
    
        FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) {
            var currentState = this.filterData.stack[this.filterData.index];
    
            return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame);
        };
    
        /**
         * This will map the filter coord so that a texture can be used based on the transform of a sprite
         *
         * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
         * @param {PIXI.Sprite} sprite - The sprite to map to.
         * @return {PIXI.Matrix} The mapped matrix.
         */
    
    
        FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) {
            var currentState = this.filterData.stack[this.filterData.index];
    
            return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);
        };
    
        /**
         * Destroys this Filter Manager.
         *
         */
    
    
        FilterManager.prototype.destroy = function destroy() {
            this.shaderCache = {};
            this.emptyPool();
        };
    
        /**
         * Gets a Power-of-Two render texture.
         *
         * TODO move to a seperate class could be on renderer?
         * also - could cause issue with multiple contexts?
         *
         * @private
         * @param {WebGLRenderingContext} gl - The webgl rendering context
         * @param {number} minWidth - The minimum width of the render target.
         * @param {number} minHeight - The minimum height of the render target.
         * @param {number} resolution - The resolution of the render target.
         * @return {PIXI.RenderTarget} The new render target.
         */
    
    
        FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {
            // TODO you could return a bigger texture if there is not one in the pool?
            minWidth = _bitTwiddle2.default.nextPow2(minWidth * resolution);
            minHeight = _bitTwiddle2.default.nextPow2(minHeight * resolution);
    
            var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;
    
            if (!this.pool[key]) {
                this.pool[key] = [];
            }
    
            var renderTarget = this.pool[key].pop();
    
            // creating render target will cause texture to be bound!
            if (!renderTarget) {
                // temporary bypass cache..
                var tex = this.renderer.boundTextures[0];
    
                gl.activeTexture(gl.TEXTURE0);
    
                // internally - this will cause a texture to be bound..
                renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1);
    
                // set the current one back
                gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
            }
    
            // manually tweak the resolution...
            // this will not modify the size of the frame buffer, just its resolution.
            renderTarget.resolution = resolution;
            renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;
            renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;
    
            return renderTarget;
        };
    
        /**
         * Empties the texture pool.
         *
         */
    
    
        FilterManager.prototype.emptyPool = function emptyPool() {
            for (var i in this.pool) {
                var textures = this.pool[i];
    
                if (textures) {
                    for (var j = 0; j < textures.length; j++) {
                        textures[j].destroy(true);
                    }
                }
            }
    
            this.pool = {};
        };
    
        /**
         * Frees a render target back into the pool.
         *
         * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free
         */
    
    
        FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) {
            var minWidth = renderTarget.size.width * renderTarget.resolution;
            var minHeight = renderTarget.size.height * renderTarget.resolution;
            var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;
    
            this.pool[key].push(renderTarget);
        };
    
        return FilterManager;
    }(_WebGLManager3.default);
    
    exports.default = FilterManager;
    
    /***/ }),
    /* 124 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;
    exports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;
    exports.calculateSpriteMatrix = calculateSpriteMatrix;
    
    var _math = __webpack_require__(2);
    
    /**
     * Calculates the mapped matrix
     * @param filterArea {Rectangle} The filter area
     * @param sprite {Sprite} the target sprite
     * @param outputMatrix {Matrix} @alvin
     */
    // TODO playing around here.. this is temporary - (will end up in the shader)
    // this returns a matrix that will normalise map filter cords in the filter to screen space
    function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),
        // let texture = {width:1136, height:700};//sprite._texture.baseTexture;
    
        // TODO unwrap?
        var mappedMatrix = outputMatrix.identity();
    
        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
    
        mappedMatrix.scale(textureSize.width, textureSize.height);
    
        return mappedMatrix;
    }
    
    function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        var mappedMatrix = outputMatrix.identity();
    
        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
    
        var translateScaleX = textureSize.width / filterArea.width;
        var translateScaleY = textureSize.height / filterArea.height;
    
        mappedMatrix.scale(translateScaleX, translateScaleY);
    
        return mappedMatrix;
    }
    
    // this will map the filter coord so that a texture can be used based on the transform of a sprite
    function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
        var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);
        var texture = sprite._texture.baseTexture;
    
        // TODO unwrap?
        var mappedMatrix = outputMatrix.identity();
    
        // scale..
        var ratio = textureSize.height / textureSize.width;
    
        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
    
        mappedMatrix.scale(1, ratio);
    
        var translateScaleX = textureSize.width / texture.width;
        var translateScaleY = textureSize.height / texture.height;
    
        worldTransform.tx /= texture.width * translateScaleX;
    
        // this...?  free beer for anyone who can explain why this makes sense!
        worldTransform.ty /= texture.width * translateScaleX;
        // worldTransform.ty /= texture.height * translateScaleY;
    
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
    
        // apply inverse scale..
        mappedMatrix.scale(1, 1 / ratio);
    
        mappedMatrix.scale(translateScaleX, translateScaleY);
    
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    
        return mappedMatrix;
    }
    
    /***/ }),
    /* 125 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _const = __webpack_require__(0);
    
    var _RenderTarget = __webpack_require__(15);
    
    var _RenderTarget2 = _interopRequireDefault(_RenderTarget);
    
    var _utils = __webpack_require__(1);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Helper class to create a webGL Texture
     *
     * @class
     * @memberof PIXI
     */
    var TextureManager = function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer
         */
        function TextureManager(renderer) {
            _classCallCheck(this, TextureManager);
    
            /**
             * A reference to the current renderer
             *
             * @member {PIXI.WebGLRenderer}
             */
            this.renderer = renderer;
    
            /**
             * The current WebGL rendering context
             *
             * @member {WebGLRenderingContext}
             */
            this.gl = renderer.gl;
    
            /**
             * Track textures in the renderer so we can no longer listen to them on destruction.
             *
             * @member {Array<*>}
             * @private
             */
            this._managedTextures = [];
        }
    
        /**
         * Binds a texture.
         *
         */
    
    
        TextureManager.prototype.bindTexture = function bindTexture() {}
        // empty
    
    
        /**
         * Gets a texture.
         *
         */
        ;
    
        TextureManager.prototype.getTexture = function getTexture() {}
        // empty
    
    
        /**
         * Updates and/or Creates a WebGL texture for the renderer's context.
         *
         * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update
         * @param {number} location - the location the texture will be bound to.
         * @return {GLTexture} The gl texture.
         */
        ;
    
        TextureManager.prototype.updateTexture = function updateTexture(texture, location) {
            // assume it good!
            // texture = texture.baseTexture || texture;
    
            var gl = this.gl;
    
            var isRenderTexture = !!texture._glRenderTargets;
    
            if (!texture.hasLoaded) {
                return null;
            }
    
            var boundTextures = this.renderer.boundTextures;
    
            // if the location is undefined then this may have been called by n event.
            // this being the case the texture may already be bound to a slot. As a texture can only be bound once
            // we need to find its current location if it exists.
            if (location === undefined) {
                location = 0;
    
                // TODO maybe we can use texture bound ids later on...
                // check if texture is already bound..
                for (var i = 0; i < boundTextures.length; ++i) {
                    if (boundTextures[i] === texture) {
                        location = i;
                        break;
                    }
                }
            }
    
            boundTextures[location] = texture;
    
            gl.activeTexture(gl.TEXTURE0 + location);
    
            var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];
    
            if (!glTexture) {
                if (isRenderTexture) {
                    var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);
    
                    renderTarget.resize(texture.width, texture.height);
                    texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;
                    glTexture = renderTarget.texture;
                } else {
                    glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);
                    glTexture.bind(location);
                    glTexture.premultiplyAlpha = true;
                    glTexture.upload(texture.source);
                }
    
                texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;
    
                texture.on('update', this.updateTexture, this);
                texture.on('dispose', this.destroyTexture, this);
    
                this._managedTextures.push(texture);
    
                if (texture.isPowerOfTwo) {
                    if (texture.mipmap) {
                        glTexture.enableMipmap();
                    }
    
                    if (texture.wrapMode === _const.WRAP_MODES.CLAMP) {
                        glTexture.enableWrapClamp();
                    } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) {
                        glTexture.enableWrapRepeat();
                    } else {
                        glTexture.enableWrapMirrorRepeat();
                    }
                } else {
                    glTexture.enableWrapClamp();
                }
    
                if (texture.scaleMode === _const.SCALE_MODES.NEAREST) {
                    glTexture.enableNearestScaling();
                } else {
                    glTexture.enableLinearScaling();
                }
            }
            // the texture already exists so we only need to update it..
            else if (isRenderTexture) {
                    texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);
                } else {
                    glTexture.upload(texture.source);
                }
    
            return glTexture;
        };
    
        /**
         * Deletes the texture from WebGL
         *
         * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
         * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
         */
    
    
        TextureManager.prototype.destroyTexture = function destroyTexture(texture, skipRemove) {
            texture = texture.baseTexture || texture;
    
            if (!texture.hasLoaded) {
                return;
            }
    
            if (texture._glTextures[this.renderer.CONTEXT_UID]) {
                this.renderer.unbindTexture(texture);
    
                texture._glTextures[this.renderer.CONTEXT_UID].destroy();
                texture.off('update', this.updateTexture, this);
                texture.off('dispose', this.destroyTexture, this);
    
                delete texture._glTextures[this.renderer.CONTEXT_UID];
    
                if (!skipRemove) {
                    var i = this._managedTextures.indexOf(texture);
    
                    if (i !== -1) {
                        (0, _utils.removeItems)(this._managedTextures, i, 1);
                    }
                }
            }
        };
    
        /**
         * Deletes all the textures from WebGL
         */
    
    
        TextureManager.prototype.removeAll = function removeAll() {
            // empty all the old gl textures as they are useless now
            for (var i = 0; i < this._managedTextures.length; ++i) {
                var texture = this._managedTextures[i];
    
                if (texture._glTextures[this.renderer.CONTEXT_UID]) {
                    delete texture._glTextures[this.renderer.CONTEXT_UID];
                }
            }
        };
    
        /**
         * Destroys this manager and removes all its textures
         */
    
    
        TextureManager.prototype.destroy = function destroy() {
            // destroy managed textures
            for (var i = 0; i < this._managedTextures.length; ++i) {
                var texture = this._managedTextures[i];
    
                this.destroyTexture(texture, true);
    
                texture.off('update', this.updateTexture, this);
                texture.off('dispose', this.destroyTexture, this);
            }
    
            this._managedTextures = null;
        };
    
        return TextureManager;
    }();
    
    exports.default = TextureManager;
    
    /***/ }),
    /* 126 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _const = __webpack_require__(0);
    
    var _settings = __webpack_require__(3);
    
    var _settings2 = _interopRequireDefault(_settings);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged
     * up with textures that are no longer being used.
     *
     * @class
     * @memberof PIXI
     */
    var TextureGarbageCollector = function () {
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.
         */
        function TextureGarbageCollector(renderer) {
            _classCallCheck(this, TextureGarbageCollector);
    
            this.renderer = renderer;
    
            this.count = 0;
            this.checkCount = 0;
            this.maxIdle = _settings2.default.GC_MAX_IDLE;
            this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;
            this.mode = _settings2.default.GC_MODE;
        }
    
        /**
         * Checks to see when the last time a texture was used
         * if the texture has not been used for a specified amount of time it will be removed from the GPU
         */
    
    
        TextureGarbageCollector.prototype.update = function update() {
            this.count++;
    
            if (this.mode === _const.GC_MODES.MANUAL) {
                return;
            }
    
            this.checkCount++;
    
            if (this.checkCount > this.checkCountMax) {
                this.checkCount = 0;
    
                this.run();
            }
        };
    
        /**
         * Checks to see when the last time a texture was used
         * if the texture has not been used for a specified amount of time it will be removed from the GPU
         */
    
    
        TextureGarbageCollector.prototype.run = function run() {
            var tm = this.renderer.textureManager;
            var managedTextures = tm._managedTextures;
            var wasRemoved = false;
    
            for (var i = 0; i < managedTextures.length; i++) {
                var texture = managedTextures[i];
    
                // only supports non generated textures at the moment!
                if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) {
                    tm.destroyTexture(texture, true);
                    managedTextures[i] = null;
                    wasRemoved = true;
                }
            }
    
            if (wasRemoved) {
                var j = 0;
    
                for (var _i = 0; _i < managedTextures.length; _i++) {
                    if (managedTextures[_i] !== null) {
                        managedTextures[j++] = managedTextures[_i];
                    }
                }
    
                managedTextures.length = j;
            }
        };
    
        /**
         * Removes all the textures within the specified displayObject and its children from the GPU
         *
         * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
         */
    
    
        TextureGarbageCollector.prototype.unload = function unload(displayObject) {
            var tm = this.renderer.textureManager;
    
            // only destroy non generated textures
            if (displayObject._texture && displayObject._texture._glRenderTargets) {
                tm.destroyTexture(displayObject._texture, true);
            }
    
            for (var i = displayObject.children.length - 1; i >= 0; i--) {
                this.unload(displayObject.children[i]);
            }
        };
    
        return TextureGarbageCollector;
    }();
    
    exports.default = TextureGarbageCollector;
    
    /***/ }),
    /* 127 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _mapWebGLBlendModesToPixi = __webpack_require__(128);
    
    var _mapWebGLBlendModesToPixi2 = _interopRequireDefault(_mapWebGLBlendModesToPixi);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var BLEND = 0;
    var DEPTH_TEST = 1;
    var FRONT_FACE = 2;
    var CULL_FACE = 3;
    var BLEND_FUNC = 4;
    
    /**
     * A WebGL state machines
     *
     * @memberof PIXI
     * @class
     */
    
    var WebGLState = function () {
        /**
         * @param {WebGLRenderingContext} gl - The current WebGL rendering context
         */
        function WebGLState(gl) {
            _classCallCheck(this, WebGLState);
    
            /**
             * The current active state
             *
             * @member {Uint8Array}
             */
            this.activeState = new Uint8Array(16);
    
            /**
             * The default state
             *
             * @member {Uint8Array}
             */
            this.defaultState = new Uint8Array(16);
    
            // default blend mode..
            this.defaultState[0] = 1;
    
            /**
             * The current state index in the stack
             *
             * @member {number}
             * @private
             */
            this.stackIndex = 0;
    
            /**
             * The stack holding all the different states
             *
             * @member {Array<*>}
             * @private
             */
            this.stack = [];
    
            /**
             * The current WebGL rendering context
             *
             * @member {WebGLRenderingContext}
             */
            this.gl = gl;
    
            this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    
            this.attribState = {
                tempAttribState: new Array(this.maxAttribs),
                attribState: new Array(this.maxAttribs)
            };
    
            this.blendModes = (0, _mapWebGLBlendModesToPixi2.default)(gl);
    
            // check we have vao..
            this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');
        }
    
        /**
         * Pushes a new active state
         */
    
    
        WebGLState.prototype.push = function push() {
            // next state..
            var state = this.stack[this.stackIndex];
    
            if (!state) {
                state = this.stack[this.stackIndex] = new Uint8Array(16);
            }
    
            ++this.stackIndex;
    
            // copy state..
            // set active state so we can force overrides of gl state
            for (var i = 0; i < this.activeState.length; i++) {
                state[i] = this.activeState[i];
            }
        };
    
        /**
         * Pops a state out
         */
    
    
        WebGLState.prototype.pop = function pop() {
            var state = this.stack[--this.stackIndex];
    
            this.setState(state);
        };
    
        /**
         * Sets the current state
         *
         * @param {*} state - The state to set.
         */
    
    
        WebGLState.prototype.setState = function setState(state) {
            this.setBlend(state[BLEND]);
            this.setDepthTest(state[DEPTH_TEST]);
            this.setFrontFace(state[FRONT_FACE]);
            this.setCullFace(state[CULL_FACE]);
            this.setBlendMode(state[BLEND_FUNC]);
        };
    
        /**
         * Enables or disabled blending.
         *
         * @param {boolean} value - Turn on or off webgl blending.
         */
    
    
        WebGLState.prototype.setBlend = function setBlend(value) {
            value = value ? 1 : 0;
    
            if (this.activeState[BLEND] === value) {
                return;
            }
    
            this.activeState[BLEND] = value;
            this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
        };
    
        /**
         * Sets the blend mode.
         *
         * @param {number} value - The blend mode to set to.
         */
    
    
        WebGLState.prototype.setBlendMode = function setBlendMode(value) {
            if (value === this.activeState[BLEND_FUNC]) {
                return;
            }
    
            this.activeState[BLEND_FUNC] = value;
    
            this.gl.blendFunc(this.blendModes[value][0], this.blendModes[value][1]);
        };
    
        /**
         * Sets whether to enable or disable depth test.
         *
         * @param {boolean} value - Turn on or off webgl depth testing.
         */
    
    
        WebGLState.prototype.setDepthTest = function setDepthTest(value) {
            value = value ? 1 : 0;
    
            if (this.activeState[DEPTH_TEST] === value) {
                return;
            }
    
            this.activeState[DEPTH_TEST] = value;
            this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
        };
    
        /**
         * Sets whether to enable or disable cull face.
         *
         * @param {boolean} value - Turn on or off webgl cull face.
         */
    
    
        WebGLState.prototype.setCullFace = function setCullFace(value) {
            value = value ? 1 : 0;
    
            if (this.activeState[CULL_FACE] === value) {
                return;
            }
    
            this.activeState[CULL_FACE] = value;
            this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
        };
    
        /**
         * Sets the gl front face.
         *
         * @param {boolean} value - true is clockwise and false is counter-clockwise
         */
    
    
        WebGLState.prototype.setFrontFace = function setFrontFace(value) {
            value = value ? 1 : 0;
    
            if (this.activeState[FRONT_FACE] === value) {
                return;
            }
    
            this.activeState[FRONT_FACE] = value;
            this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
        };
    
        /**
         * Disables all the vaos in use
         *
         */
    
    
        WebGLState.prototype.resetAttributes = function resetAttributes() {
            for (var i = 0; i < this.attribState.tempAttribState.length; i++) {
                this.attribState.tempAttribState[i] = 0;
            }
    
            for (var _i = 0; _i < this.attribState.attribState.length; _i++) {
                this.attribState.attribState[_i] = 0;
            }
    
            // im going to assume one is always active for performance reasons.
            for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) {
                this.gl.disableVertexAttribArray(_i2);
            }
        };
    
        // used
        /**
         * Resets all the logic and disables the vaos
         */
    
    
        WebGLState.prototype.resetToDefault = function resetToDefault() {
            // unbind any VAO if they exist..
            if (this.nativeVaoExtension) {
                this.nativeVaoExtension.bindVertexArrayOES(null);
            }
    
            // reset all attributes..
            this.resetAttributes();
    
            // set active state so we can force overrides of gl state
            for (var i = 0; i < this.activeState.length; ++i) {
                this.activeState[i] = 32;
            }
    
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    
            this.setState(this.defaultState);
        };
    
        return WebGLState;
    }();
    
    exports.default = WebGLState;
    
    /***/ }),
    /* 128 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = mapWebGLBlendModesToPixi;
    
    var _const = __webpack_require__(0);
    
    /**
     * Maps gl blend combinations to WebGL.
     *
     * @memberof PIXI
     * @function mapWebGLBlendModesToPixi
     * @private
     * @param {WebGLRenderingContext} gl - The rendering context.
     * @param {string[]} [array=[]] - The array to output into.
     * @return {string[]} Mapped modes.
     */
    function mapWebGLBlendModesToPixi(gl) {
        var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    
        // TODO - premultiply alpha would be different.
        // add a boolean for that!
        array[_const.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA];
        array[_const.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
        array[_const.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[_const.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
    
        return array;
    }
    
    /***/ }),
    /* 129 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = mapWebGLDrawModesToPixi;
    
    var _const = __webpack_require__(0);
    
    /**
     * Generic Mask Stack data structure.
     *
     * @memberof PIXI
     * @function mapWebGLDrawModesToPixi
     * @private
     * @param {WebGLRenderingContext} gl - The current WebGL drawing context
     * @param {object} [object={}] - The object to map into
     * @return {object} The mapped draw modes.
     */
    function mapWebGLDrawModesToPixi(gl) {
      var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
      object[_const.DRAW_MODES.POINTS] = gl.POINTS;
      object[_const.DRAW_MODES.LINES] = gl.LINES;
      object[_const.DRAW_MODES.LINE_LOOP] = gl.LINE_LOOP;
      object[_const.DRAW_MODES.LINE_STRIP] = gl.LINE_STRIP;
      object[_const.DRAW_MODES.TRIANGLES] = gl.TRIANGLES;
      object[_const.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
      object[_const.DRAW_MODES.TRIANGLE_FAN] = gl.TRIANGLE_FAN;
    
      return object;
    }
    
    /***/ }),
    /* 130 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = validateContext;
    function validateContext(gl) {
        var attributes = gl.getContextAttributes();
    
        // this is going to be fairly simple for now.. but at least we have room to grow!
        if (!attributes.stencil) {
            /* eslint-disable no-console */
            console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
            /* eslint-enable no-console */
        }
    }
    
    /***/ }),
    /* 131 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = generateMultiTextureShader;
    
    var _Shader = __webpack_require__(16);
    
    var _Shader2 = _interopRequireDefault(_Shader);
    
    var _path = __webpack_require__(30);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var fragTemplate = ['varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureId;', 'uniform sampler2D uSamplers[%count%];', 'void main(void){', 'vec4 color;', 'float textureId = floor(vTextureId+0.5);', '%forloop%', 'gl_FragColor = color * vColor;', '}'].join('\n');
    
    function generateMultiTextureShader(gl, maxTextures) {
        var vertexSrc = 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n';
        var fragmentSrc = fragTemplate;
    
        fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, generateSampleSrc(maxTextures));
    
        var shader = new _Shader2.default(gl, vertexSrc, fragmentSrc);
    
        var sampleValues = [];
    
        for (var i = 0; i < maxTextures; i++) {
            sampleValues[i] = i;
        }
    
        shader.bind();
        shader.uniforms.uSamplers = sampleValues;
    
        return shader;
    }
    
    function generateSampleSrc(maxTextures) {
        var src = '';
    
        src += '\n';
        src += '\n';
    
        for (var i = 0; i < maxTextures; i++) {
            if (i > 0) {
                src += '\nelse ';
            }
    
            if (i < maxTextures - 1) {
                src += 'if(textureId == ' + i + '.0)';
            }
    
            src += '\n{';
            src += '\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);';
            src += '\n}';
        }
    
        src += '\n';
        src += '\n';
    
        return src;
    }
    
    /***/ }),
    /* 132 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = checkMaxIfStatmentsInShader;
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var fragTemplate = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n');
    
    function checkMaxIfStatmentsInShader(maxIfs, gl) {
        var createTempContext = !gl;
    
        // @if DEBUG
        if (maxIfs === 0) {
            throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
        }
        // @endif
    
        if (createTempContext) {
            var tinyCanvas = document.createElement('canvas');
    
            tinyCanvas.width = 1;
            tinyCanvas.height = 1;
    
            gl = _pixiGlCore2.default.createContext(tinyCanvas);
        }
    
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
    
        while (true) // eslint-disable-line no-constant-condition
        {
            var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    
            gl.shaderSource(shader, fragmentSrc);
            gl.compileShader(shader);
    
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                maxIfs = maxIfs / 2 | 0;
            } else {
                // valid!
                break;
            }
        }
    
        if (createTempContext) {
            // get rid of context
            if (gl.getExtension('WEBGL_lose_context')) {
                gl.getExtension('WEBGL_lose_context').loseContext();
            }
        }
    
        return maxIfs;
    }
    
    function generateIfTestSrc(maxIfs) {
        var src = '';
    
        for (var i = 0; i < maxIfs; ++i) {
            if (i > 0) {
                src += '\nelse ';
            }
    
            if (i < maxIfs - 1) {
                src += 'if(test == ' + i + '.0){}';
            }
        }
    
        return src;
    }
    
    /***/ }),
    /* 133 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * @class
     * @memberof PIXI
     */
    var Buffer = function () {
      /**
       * @param {number} size - The size of the buffer in bytes.
       */
      function Buffer(size) {
        _classCallCheck(this, Buffer);
    
        this.vertices = new ArrayBuffer(size);
    
        /**
         * View on the vertices as a Float32Array for positions
         *
         * @member {Float32Array}
         */
        this.float32View = new Float32Array(this.vertices);
    
        /**
         * View on the vertices as a Uint32Array for uvs
         *
         * @member {Float32Array}
         */
        this.uint32View = new Uint32Array(this.vertices);
      }
    
      /**
       * Destroys the buffer.
       *
       */
    
    
      Buffer.prototype.destroy = function destroy() {
        this.vertices = null;
        this.positions = null;
        this.uvs = null;
        this.colors = null;
      };
    
      return Buffer;
    }();
    
    exports.default = Buffer;
    
    /***/ }),
    /* 134 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Container2 = __webpack_require__(7);
    
    var _Container3 = _interopRequireDefault(_Container2);
    
    var _RenderTexture = __webpack_require__(29);
    
    var _RenderTexture2 = _interopRequireDefault(_RenderTexture);
    
    var _Texture = __webpack_require__(8);
    
    var _Texture2 = _interopRequireDefault(_Texture);
    
    var _GraphicsData = __webpack_require__(61);
    
    var _GraphicsData2 = _interopRequireDefault(_GraphicsData);
    
    var _Sprite = __webpack_require__(48);
    
    var _Sprite2 = _interopRequireDefault(_Sprite);
    
    var _math = __webpack_require__(2);
    
    var _utils = __webpack_require__(1);
    
    var _const = __webpack_require__(0);
    
    var _Bounds = __webpack_require__(25);
    
    var _Bounds2 = _interopRequireDefault(_Bounds);
    
    var _bezierCurveTo2 = __webpack_require__(135);
    
    var _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);
    
    var _CanvasRenderer = __webpack_require__(10);
    
    var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var canvasRenderer = void 0;
    var tempMatrix = new _math.Matrix();
    var tempPoint = new _math.Point();
    var tempColor1 = new Float32Array(4);
    var tempColor2 = new Float32Array(4);
    
    /**
     * The Graphics class contains methods used to draw primitive shapes such as lines, circles and
     * rectangles to the display, and to color and fill them.
     *
     * @class
     * @extends PIXI.Container
     * @memberof PIXI
     */
    
    var Graphics = function (_Container) {
        _inherits(Graphics, _Container);
    
        /**
         *
         * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         */
        function Graphics() {
            var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    
            _classCallCheck(this, Graphics);
    
            /**
             * The alpha value used when filling the Graphics object.
             *
             * @member {number}
             * @default 1
             */
            var _this = _possibleConstructorReturn(this, _Container.call(this));
    
            _this.fillAlpha = 1;
    
            /**
             * The width (thickness) of any lines drawn.
             *
             * @member {number}
             * @default 0
             */
            _this.lineWidth = 0;
    
            /**
             * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
             *
             * @member {boolean}
             */
            _this.nativeLines = nativeLines;
    
            /**
             * The color of any lines drawn.
             *
             * @member {string}
             * @default 0
             */
            _this.lineColor = 0;
    
            /**
             * Graphics data
             *
             * @member {PIXI.GraphicsData[]}
             * @private
             */
            _this.graphicsData = [];
    
            /**
             * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to
             * reset the tint.
             *
             * @member {number}
             * @default 0xFFFFFF
             */
            _this.tint = 0xFFFFFF;
    
            /**
             * The previous tint applied to the graphic shape. Used to compare to the current tint and
             * check if theres change.
             *
             * @member {number}
             * @private
             * @default 0xFFFFFF
             */
            _this._prevTint = 0xFFFFFF;
    
            /**
             * The blend mode to be applied to the graphic shape. Apply a value of
             * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
             *
             * @member {number}
             * @default PIXI.BLEND_MODES.NORMAL;
             * @see PIXI.BLEND_MODES
             */
            _this.blendMode = _const.BLEND_MODES.NORMAL;
    
            /**
             * Current path
             *
             * @member {PIXI.GraphicsData}
             * @private
             */
            _this.currentPath = null;
    
            /**
             * Array containing some WebGL-related properties used by the WebGL renderer.
             *
             * @member {object<number, object>}
             * @private
             */
            // TODO - _webgl should use a prototype object, not a random undocumented object...
            _this._webGL = {};
    
            /**
             * Whether this shape is being used as a mask.
             *
             * @member {boolean}
             */
            _this.isMask = false;
    
            /**
             * The bounds' padding used for bounds calculation.
             *
             * @member {number}
             */
            _this.boundsPadding = 0;
    
            /**
             * A cache of the local bounds to prevent recalculation.
             *
             * @member {PIXI.Rectangle}
             * @private
             */
            _this._localBounds = new _Bounds2.default();
    
            /**
             * Used to detect if the graphics object has changed. If this is set to true then the graphics
             * object will be recalculated.
             *
             * @member {boolean}
             * @private
             */
            _this.dirty = 0;
    
            /**
             * Used to detect if we need to do a fast rect check using the id compare method
             * @type {Number}
             */
            _this.fastRectDirty = -1;
    
            /**
             * Used to detect if we clear the graphics webGL data
             * @type {Number}
             */
            _this.clearDirty = 0;
    
            /**
             * Used to detect if we we need to recalculate local bounds
             * @type {Number}
             */
            _this.boundsDirty = -1;
    
            /**
             * Used to detect if the cached sprite object needs to be updated.
             *
             * @member {boolean}
             * @private
             */
            _this.cachedSpriteDirty = false;
    
            _this._spriteRect = null;
            _this._fastRect = false;
    
            /**
             * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
             * This is useful if your graphics element does not change often, as it will speed up the rendering
             * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
             * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
             * you are constantly redrawing the graphics element.
             *
             * @name cacheAsBitmap
             * @member {boolean}
             * @memberof PIXI.Graphics#
             * @default false
             */
            return _this;
        }
    
        /**
         * Creates a new Graphics object with the same values as this one.
         * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
         *
         * @return {PIXI.Graphics} A clone of the graphics object
         */
    
    
        Graphics.prototype.clone = function clone() {
            var clone = new Graphics();
    
            clone.renderable = this.renderable;
            clone.fillAlpha = this.fillAlpha;
            clone.lineWidth = this.lineWidth;
            clone.lineColor = this.lineColor;
            clone.tint = this.tint;
            clone.blendMode = this.blendMode;
            clone.isMask = this.isMask;
            clone.boundsPadding = this.boundsPadding;
            clone.dirty = 0;
            clone.cachedSpriteDirty = this.cachedSpriteDirty;
    
            // copy graphics data
            for (var i = 0; i < this.graphicsData.length; ++i) {
                clone.graphicsData.push(this.graphicsData[i].clone());
            }
    
            clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];
    
            clone.updateLocalBounds();
    
            return clone;
        };
    
        /**
         * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
         * method or the drawCircle() method.
         *
         * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style
         * @param {number} [color=0] - color of the line to draw, will update the objects stored style
         * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.lineStyle = function lineStyle() {
            var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    
            this.lineWidth = lineWidth;
            this.lineColor = color;
            this.lineAlpha = alpha;
    
            if (this.currentPath) {
                if (this.currentPath.shape.points.length) {
                    // halfway through a line? start a new one!
                    var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));
    
                    shape.closed = false;
    
                    this.drawShape(shape);
                } else {
                    // otherwise its empty so lets just set the line properties
                    this.currentPath.lineWidth = this.lineWidth;
                    this.currentPath.lineColor = this.lineColor;
                    this.currentPath.lineAlpha = this.lineAlpha;
                }
            }
    
            return this;
        };
    
        /**
         * Moves the current drawing position to x, y.
         *
         * @param {number} x - the X coordinate to move to
         * @param {number} y - the Y coordinate to move to
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.moveTo = function moveTo(x, y) {
            var shape = new _math.Polygon([x, y]);
    
            shape.closed = false;
            this.drawShape(shape);
    
            return this;
        };
    
        /**
         * Draws a line using the current line style from the current drawing position to (x, y);
         * The current drawing position is then set to (x, y).
         *
         * @param {number} x - the X coordinate to draw to
         * @param {number} y - the Y coordinate to draw to
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.lineTo = function lineTo(x, y) {
            this.currentPath.shape.points.push(x, y);
            this.dirty++;
    
            return this;
        };
    
        /**
         * Calculate the points for a quadratic bezier curve and then draws it.
         * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
         *
         * @param {number} cpX - Control point x
         * @param {number} cpY - Control point y
         * @param {number} toX - Destination point x
         * @param {number} toY - Destination point y
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points = [0, 0];
                }
            } else {
                this.moveTo(0, 0);
            }
    
            var n = 20;
            var points = this.currentPath.shape.points;
            var xa = 0;
            var ya = 0;
    
            if (points.length === 0) {
                this.moveTo(0, 0);
            }
    
            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];
    
            for (var i = 1; i <= n; ++i) {
                var j = i / n;
    
                xa = fromX + (cpX - fromX) * j;
                ya = fromY + (cpY - fromY) * j;
    
                points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
            }
    
            this.dirty++;
    
            return this;
        };
    
        /**
         * Calculate the points for a bezier curve and then draws it.
         *
         * @param {number} cpX - Control point x
         * @param {number} cpY - Control point y
         * @param {number} cpX2 - Second Control point x
         * @param {number} cpY2 - Second Control point y
         * @param {number} toX - Destination point x
         * @param {number} toY - Destination point y
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points = [0, 0];
                }
            } else {
                this.moveTo(0, 0);
            }
    
            var points = this.currentPath.shape.points;
    
            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];
    
            points.length -= 2;
    
            (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);
    
            this.dirty++;
    
            return this;
        };
    
        /**
         * The arcTo() method creates an arc/curve between two tangents on the canvas.
         *
         * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
         *
         * @param {number} x1 - The x-coordinate of the beginning of the arc
         * @param {number} y1 - The y-coordinate of the beginning of the arc
         * @param {number} x2 - The x-coordinate of the end of the arc
         * @param {number} y2 - The y-coordinate of the end of the arc
         * @param {number} radius - The radius of the arc
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {
            if (this.currentPath) {
                if (this.currentPath.shape.points.length === 0) {
                    this.currentPath.shape.points.push(x1, y1);
                }
            } else {
                this.moveTo(x1, y1);
            }
    
            var points = this.currentPath.shape.points;
            var fromX = points[points.length - 2];
            var fromY = points[points.length - 1];
            var a1 = fromY - y1;
            var b1 = fromX - x1;
            var a2 = y2 - y1;
            var b2 = x2 - x1;
            var mm = Math.abs(a1 * b2 - b1 * a2);
    
            if (mm < 1.0e-8 || radius === 0) {
                if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                    points.push(x1, y1);
                }
            } else {
                var dd = a1 * a1 + b1 * b1;
                var cc = a2 * a2 + b2 * b2;
                var tt = a1 * a2 + b1 * b2;
                var k1 = radius * Math.sqrt(dd) / mm;
                var k2 = radius * Math.sqrt(cc) / mm;
                var j1 = k1 * tt / dd;
                var j2 = k2 * tt / cc;
                var cx = k1 * b2 + k2 * b1;
                var cy = k1 * a2 + k2 * a1;
                var px = b1 * (k2 + j1);
                var py = a1 * (k2 + j1);
                var qx = b2 * (k1 + j2);
                var qy = a2 * (k1 + j2);
                var startAngle = Math.atan2(py - cy, px - cx);
                var endAngle = Math.atan2(qy - cy, qx - cx);
    
                this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);
            }
    
            this.dirty++;
    
            return this;
        };
    
        /**
         * The arc method creates an arc/curve (used to create circles, or parts of circles).
         *
         * @param {number} cx - The x-coordinate of the center of the circle
         * @param {number} cy - The y-coordinate of the center of the circle
         * @param {number} radius - The radius of the circle
         * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
         *  of the arc's circle)
         * @param {number} endAngle - The ending angle, in radians
         * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
         *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
         *  indicates counter-clockwise.
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {
            var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    
            if (startAngle === endAngle) {
                return this;
            }
    
            if (!anticlockwise && endAngle <= startAngle) {
                endAngle += Math.PI * 2;
            } else if (anticlockwise && startAngle <= endAngle) {
                startAngle += Math.PI * 2;
            }
    
            var sweep = endAngle - startAngle;
            var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;
    
            if (sweep === 0) {
                return this;
            }
    
            var startX = cx + Math.cos(startAngle) * radius;
            var startY = cy + Math.sin(startAngle) * radius;
    
            // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
            var points = this.currentPath ? this.currentPath.shape.points : null;
    
            if (points) {
                if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) {
                    points.push(startX, startY);
                }
            } else {
                this.moveTo(startX, startY);
                points = this.currentPath.shape.points;
            }
    
            var theta = sweep / (segs * 2);
            var theta2 = theta * 2;
    
            var cTheta = Math.cos(theta);
            var sTheta = Math.sin(theta);
    
            var segMinus = segs - 1;
    
            var remainder = segMinus % 1 / segMinus;
    
            for (var i = 0; i <= segMinus; ++i) {
                var real = i + remainder * i;
    
                var angle = theta + startAngle + theta2 * real;
    
                var c = Math.cos(angle);
                var s = -Math.sin(angle);
    
                points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);
            }
    
            this.dirty++;
    
            return this;
        };
    
        /**
         * Specifies a simple one-color fill that subsequent calls to other Graphics methods
         * (such as lineTo() or drawCircle()) use when drawing.
         *
         * @param {number} [color=0] - the color of the fill
         * @param {number} [alpha=1] - the alpha of the fill
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.beginFill = function beginFill() {
            var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    
            this.filling = true;
            this.fillColor = color;
            this.fillAlpha = alpha;
    
            if (this.currentPath) {
                if (this.currentPath.shape.points.length <= 2) {
                    this.currentPath.fill = this.filling;
                    this.currentPath.fillColor = this.fillColor;
                    this.currentPath.fillAlpha = this.fillAlpha;
                }
            }
    
            return this;
        };
    
        /**
         * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
         *
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.endFill = function endFill() {
            this.filling = false;
            this.fillColor = null;
            this.fillAlpha = 1;
    
            return this;
        };
    
        /**
         *
         * @param {number} x - The X coord of the top-left of the rectangle
         * @param {number} y - The Y coord of the top-left of the rectangle
         * @param {number} width - The width of the rectangle
         * @param {number} height - The height of the rectangle
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.drawRect = function drawRect(x, y, width, height) {
            this.drawShape(new _math.Rectangle(x, y, width, height));
    
            return this;
        };
    
        /**
         *
         * @param {number} x - The X coord of the top-left of the rectangle
         * @param {number} y - The Y coord of the top-left of the rectangle
         * @param {number} width - The width of the rectangle
         * @param {number} height - The height of the rectangle
         * @param {number} radius - Radius of the rectangle corners
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {
            this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));
    
            return this;
        };
    
        /**
         * Draws a circle.
         *
         * @param {number} x - The X coordinate of the center of the circle
         * @param {number} y - The Y coordinate of the center of the circle
         * @param {number} radius - The radius of the circle
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {
            this.drawShape(new _math.Circle(x, y, radius));
    
            return this;
        };
    
        /**
         * Draws an ellipse.
         *
         * @param {number} x - The X coordinate of the center of the ellipse
         * @param {number} y - The Y coordinate of the center of the ellipse
         * @param {number} width - The half width of the ellipse
         * @param {number} height - The half height of the ellipse
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {
            this.drawShape(new _math.Ellipse(x, y, width, height));
    
            return this;
        };
    
        /**
         * Draws a polygon using the given path.
         *
         * @param {number[]|PIXI.Point[]} path - The path data used to construct the polygon.
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.drawPolygon = function drawPolygon(path) {
            // prevents an argument assignment deopt
            // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            var points = path;
    
            var closed = true;
    
            if (points instanceof _math.Polygon) {
                closed = points.closed;
                points = points.points;
            }
    
            if (!Array.isArray(points)) {
                // prevents an argument leak deopt
                // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
                points = new Array(arguments.length);
    
                for (var i = 0; i < points.length; ++i) {
                    points[i] = arguments[i]; // eslint-disable-line prefer-rest-params
                }
            }
    
            var shape = new _math.Polygon(points);
    
            shape.closed = closed;
    
            this.drawShape(shape);
    
            return this;
        };
    
        /**
         * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
         *
         * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
         */
    
    
        Graphics.prototype.clear = function clear() {
            if (this.lineWidth || this.filling || this.graphicsData.length > 0) {
                this.lineWidth = 0;
                this.filling = false;
    
                this.boundsDirty = -1;
                this.dirty++;
                this.clearDirty++;
                this.graphicsData.length = 0;
            }
    
            this.currentPath = null;
            this._spriteRect = null;
    
            return this;
        };
    
        /**
         * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
         * masked with gl.scissor.
         *
         * @returns {boolean} True if only 1 rect.
         */
    
    
        Graphics.prototype.isFastRect = function isFastRect() {
            return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;
        };
    
        /**
         * Renders the object using the WebGL renderer
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */
    
    
        Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {
            // if the sprite is not visible or the alpha is 0 then no need to render this element
            if (this.dirty !== this.fastRectDirty) {
                this.fastRectDirty = this.dirty;
                this._fastRect = this.isFastRect();
            }
    
            // TODO this check can be moved to dirty?
            if (this._fastRect) {
                this._renderSpriteRect(renderer);
            } else {
                renderer.setObjectRenderer(renderer.plugins.graphics);
                renderer.plugins.graphics.render(this);
            }
        };
    
        /**
         * Renders a sprite rectangle.
         *
         * @private
         * @param {PIXI.WebGLRenderer} renderer - The renderer
         */
    
    
        Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {
            var rect = this.graphicsData[0].shape;
    
            if (!this._spriteRect) {
                this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE));
            }
    
            var sprite = this._spriteRect;
    
            if (this.tint === 0xffffff) {
                sprite.tint = this.graphicsData[0].fillColor;
            } else {
                var t1 = tempColor1;
                var t2 = tempColor2;
    
                (0, _utils.hex2rgb)(this.graphicsData[0].fillColor, t1);
                (0, _utils.hex2rgb)(this.tint, t2);
    
                t1[0] *= t2[0];
                t1[1] *= t2[1];
                t1[2] *= t2[2];
    
                sprite.tint = (0, _utils.rgb2hex)(t1);
            }
            sprite.alpha = this.graphicsData[0].fillAlpha;
            sprite.worldAlpha = this.worldAlpha * sprite.alpha;
            sprite.blendMode = this.blendMode;
    
            sprite._texture._frame.width = rect.width;
            sprite._texture._frame.height = rect.height;
    
            sprite.transform.worldTransform = this.transform.worldTransform;
    
            sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);
            sprite._onAnchorUpdate();
    
            sprite._renderWebGL(renderer);
        };
    
        /**
         * Renders the object using the Canvas renderer
         *
         * @private
         * @param {PIXI.CanvasRenderer} renderer - The renderer
         */
    
    
        Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {
            if (this.isMask === true) {
                return;
            }
    
            renderer.plugins.graphics.render(this);
        };
    
        /**
         * Retrieves the bounds of the graphic shape as a rectangle object
         *
         * @private
         */
    
    
        Graphics.prototype._calculateBounds = function _calculateBounds() {
            if (this.boundsDirty !== this.dirty) {
                this.boundsDirty = this.dirty;
                this.updateLocalBounds();
    
                this.cachedSpriteDirty = true;
            }
    
            var lb = this._localBounds;
    
            this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
        };
    
        /**
         * Tests if a point is inside this graphics object
         *
         * @param {PIXI.Point} point - the point to test
         * @return {boolean} the result of the test
         */
    
    
        Graphics.prototype.containsPoint = function containsPoint(point) {
            this.worldTransform.applyInverse(point, tempPoint);
    
            var graphicsData = this.graphicsData;
    
            for (var i = 0; i < graphicsData.length; ++i) {
                var data = graphicsData[i];
    
                if (!data.fill) {
                    continue;
                }
    
                // only deal with fills..
                if (data.shape) {
                    if (data.shape.contains(tempPoint.x, tempPoint.y)) {
                        return true;
                    }
                }
            }
    
            return false;
        };
    
        /**
         * Update the bounds of the object
         *
         */
    
    
        Graphics.prototype.updateLocalBounds = function updateLocalBounds() {
            var minX = Infinity;
            var maxX = -Infinity;
    
            var minY = Infinity;
            var maxY = -Infinity;
    
            if (this.graphicsData.length) {
                var shape = 0;
                var x = 0;
                var y = 0;
                var w = 0;
                var h = 0;
    
                for (var i = 0; i < this.graphicsData.length; i++) {
                    var data = this.graphicsData[i];
                    var type = data.type;
                    var lineWidth = data.lineWidth;
    
                    shape = data.shape;
    
                    if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {
                        x = shape.x - lineWidth / 2;
                        y = shape.y - lineWidth / 2;
                        w = shape.width + lineWidth;
                        h = shape.height + lineWidth;
    
                        minX = x < minX ? x : minX;
                        maxX = x + w > maxX ? x + w : maxX;
    
                        minY = y < minY ? y : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else if (type === _const.SHAPES.CIRC) {
                        x = shape.x;
                        y = shape.y;
                        w = shape.radius + lineWidth / 2;
                        h = shape.radius + lineWidth / 2;
    
                        minX = x - w < minX ? x - w : minX;
                        maxX = x + w > maxX ? x + w : maxX;
    
                        minY = y - h < minY ? y - h : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else if (type === _const.SHAPES.ELIP) {
                        x = shape.x;
                        y = shape.y;
                        w = shape.width + lineWidth / 2;
                        h = shape.height + lineWidth / 2;
    
                        minX = x - w < minX ? x - w : minX;
                        maxX = x + w > maxX ? x + w : maxX;
    
                        minY = y - h < minY ? y - h : minY;
                        maxY = y + h > maxY ? y + h : maxY;
                    } else {
                        // POLY
                        var points = shape.points;
                        var x2 = 0;
                        var y2 = 0;
                        var dx = 0;
                        var dy = 0;
                        var rw = 0;
                        var rh = 0;
                        var cx = 0;
                        var cy = 0;
    
                        for (var j = 0; j + 2 < points.length; j += 2) {
                            x = points[j];
                            y = points[j + 1];
                            x2 = points[j + 2];
                            y2 = points[j + 3];
                            dx = Math.abs(x2 - x);
                            dy = Math.abs(y2 - y);
                            h = lineWidth;
                            w = Math.sqrt(dx * dx + dy * dy);
    
                            if (w < 1e-9) {
                                continue;
                            }
    
                            rw = (h / w * dy + dx) / 2;
                            rh = (h / w * dx + dy) / 2;
                            cx = (x2 + x) / 2;
                            cy = (y2 + y) / 2;
    
                            minX = cx - rw < minX ? cx - rw : minX;
                            maxX = cx + rw > maxX ? cx + rw : maxX;
    
                            minY = cy - rh < minY ? cy - rh : minY;
                            maxY = cy + rh > maxY ? cy + rh : maxY;
                        }
                    }
                }
            } else {
                minX = 0;
                maxX = 0;
                minY = 0;
                maxY = 0;
            }
    
            var padding = this.boundsPadding;
    
            this._localBounds.minX = minX - padding;
            this._localBounds.maxX = maxX + padding * 2;
    
            this._localBounds.minY = minY - padding;
            this._localBounds.maxY = maxY + padding * 2;
        };
    
        /**
         * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
         *
         * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
         * @return {PIXI.GraphicsData} The generated GraphicsData object.
         */
    
    
        Graphics.prototype.drawShape = function drawShape(shape) {
            if (this.currentPath) {
                // check current path!
                if (this.currentPath.shape.points.length <= 2) {
                    this.graphicsData.pop();
                }
            }
    
            this.currentPath = null;
    
            var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, shape);
    
            this.graphicsData.push(data);
    
            if (data.type === _const.SHAPES.POLY) {
                data.shape.closed = data.shape.closed || this.filling;
                this.currentPath = data;
            }
    
            this.dirty++;
    
            return data;
        };
    
        /**
         * Generates a canvas texture.
         *
         * @param {number} scaleMode - The scale mode of the texture.
         * @param {number} resolution - The resolution of the texture.
         * @return {PIXI.Texture} The new texture.
         */
    
    
        Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {
            var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    
            var bounds = this.getLocalBounds();
    
            var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);
    
            if (!canvasRenderer) {
                canvasRenderer = new _CanvasRenderer2.default();
            }
    
            this.transform.updateLocalTransform();
            this.transform.localTransform.copy(tempMatrix);
    
            tempMatrix.invert();
    
            tempMatrix.tx -= bounds.x;
            tempMatrix.ty -= bounds.y;
    
            canvasRenderer.render(this, canvasBuffer, true, tempMatrix);
    
            var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');
    
            texture.baseTexture.resolution = resolution;
            texture.baseTexture.update();
    
            return texture;
        };
    
        /**
         * Closes the current path.
         *
         * @return {PIXI.Graphics} Returns itself.
         */
    
    
        Graphics.prototype.closePath = function closePath() {
            // ok so close path assumes next one is a hole!
            var currentPath = this.currentPath;
    
            if (currentPath && currentPath.shape) {
                currentPath.shape.close();
            }
    
            return this;
        };
    
        /**
         * Adds a hole in the current path.
         *
         * @return {PIXI.Graphics} Returns itself.
         */
    
    
        Graphics.prototype.addHole = function addHole() {
            // this is a hole!
            var hole = this.graphicsData.pop();
    
            this.currentPath = this.graphicsData[this.graphicsData.length - 1];
    
            this.currentPath.addHole(hole.shape);
            this.currentPath = null;
    
            return this;
        };
    
        /**
         * Destroys the Graphics object.
         *
         * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
         *  options have been set to that value
         * @param {boolean} [options.children=false] - if set to true, all the children will have
         *  their destroy method called as well. 'options' will be passed on to those calls.
         * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the texture of the child sprite
         * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
         *  Should it destroy the base texture of the child sprite
         */
    
    
        Graphics.prototype.destroy = function destroy(options) {
            _Container.prototype.destroy.call(this, options);
    
            // destroy each of the GraphicsData objects
            for (var i = 0; i < this.graphicsData.length; ++i) {
                this.graphicsData[i].destroy();
            }
    
            // for each webgl data entry, destroy the WebGLGraphicsData
            for (var id in this._webgl) {
                for (var j = 0; j < this._webgl[id].data.length; ++j) {
                    this._webgl[id].data[j].destroy();
                }
            }
    
            if (this._spriteRect) {
                this._spriteRect.destroy();
            }
    
            this.graphicsData = null;
    
            this.currentPath = null;
            this._webgl = null;
            this._localBounds = null;
        };
    
        return Graphics;
    }(_Container3.default);
    
    exports.default = Graphics;
    
    
    Graphics._SPRITE_TEXTURE = null;
    
    /***/ }),
    /* 135 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = bezierCurveTo;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @param {number} fromX - Starting point x
     * @param {number} fromY - Starting point y
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} [path=[]] - Path array to push points into
     * @return {number[]} Array of points of the curve
     */
    function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var path = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
    
        var n = 20;
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
    
        path.push(fromX, fromY);
    
        for (var i = 1, j = 0; i <= n; ++i) {
            j = i / n;
    
            dt = 1 - j;
            dt2 = dt * dt;
            dt3 = dt2 * dt;
    
            t2 = j * j;
            t3 = t2 * j;
    
            path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
        }
    
        return path;
    }
    
    /***/ }),
    /* 136 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _utils = __webpack_require__(1);
    
    var _const = __webpack_require__(0);
    
    var _ObjectRenderer2 = __webpack_require__(13);
    
    var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);
    
    var _WebGLRenderer = __webpack_require__(14);
    
    var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);
    
    var _WebGLGraphicsData = __webpack_require__(137);
    
    var _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);
    
    var _PrimitiveShader = __webpack_require__(138);
    
    var _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);
    
    var _buildPoly = __webpack_require__(139);
    
    var _buildPoly2 = _interopRequireDefault(_buildPoly);
    
    var _buildRectangle = __webpack_require__(140);
    
    var _buildRectangle2 = _interopRequireDefault(_buildRectangle);
    
    var _buildRoundedRectangle = __webpack_require__(141);
    
    var _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);
    
    var _buildCircle = __webpack_require__(142);
    
    var _buildCircle2 = _interopRequireDefault(_buildCircle);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * Renders the graphics object.
     *
     * @class
     * @memberof PIXI
     * @extends PIXI.ObjectRenderer
     */
    var GraphicsRenderer = function (_ObjectRenderer) {
        _inherits(GraphicsRenderer, _ObjectRenderer);
    
        /**
         * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.
         */
        function GraphicsRenderer(renderer) {
            _classCallCheck(this, GraphicsRenderer);
    
            var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));
    
            _this.graphicsDataPool = [];
    
            _this.primitiveShader = null;
    
            _this.gl = renderer.gl;
    
            // easy access!
            _this.CONTEXT_UID = 0;
            return _this;
        }
    
        /**
         * Called when there is a WebGL context change
         *
         * @private
         *
         */
    
    
        GraphicsRenderer.prototype.onContextChange = function onContextChange() {
            this.gl = this.renderer.gl;
            this.CONTEXT_UID = this.renderer.CONTEXT_UID;
            this.primitiveShader = new _PrimitiveShader2.default(this.gl);
        };
    
        /**
         * Destroys this renderer.
         *
         */
    
    
        GraphicsRenderer.prototype.destroy = function destroy() {
            _ObjectRenderer3.default.prototype.destroy.call(this);
    
            for (var i = 0; i < this.graphicsDataPool.length; ++i) {
                this.graphicsDataPool[i].destroy();
            }
    
            this.graphicsDataPool = null;
        };
    
        /**
         * Renders a graphics object.
         *
         * @param {PIXI.Graphics} graphics - The graphics object to render.
         */
    
    
        GraphicsRenderer.prototype.render = function render(graphics) {
            var renderer = this.renderer;
            var gl = renderer.gl;
    
            var webGLData = void 0;
            var webGL = graphics._webGL[this.CONTEXT_UID];
    
            if (!webGL || graphics.dirty !== webGL.dirty) {
                this.updateGraphics(graphics);
    
                webGL = graphics._webGL[this.CONTEXT_UID];
            }
    
            // This  could be speeded up for sure!
            var shader = this.primitiveShader;
    
            renderer.bindShader(shader);
            renderer.state.setBlendMode(graphics.blendMode);
    
            for (var i = 0, n = webGL.data.length; i < n; i++) {
                webGLData = webGL.data[i];
                var shaderTemp = webGLData.shader;
    
                renderer.bindShader(shaderTemp);
                shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);
                shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);
                shaderTemp.uniforms.alpha = graphics.worldAlpha;
    
                renderer.bindVao(webGLData.vao);
    
                if (webGLData.nativeLines) {
                    gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);
                } else {
                    webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);
                }
            }
        };
    
        /**
         * Updates the graphics object
         *
         * @private
         * @param {PIXI.Graphics} graphics - The graphics object to update
         */
    
    
        GraphicsRenderer.prototype.updateGraphics = function updateGraphics(graphics) {
            var gl = this.renderer.gl;
    
            // get the contexts graphics object
            var webGL = graphics._webGL[this.CONTEXT_UID];
    
            // if the graphics object does not exist in the webGL context time to create it!
            if (!webGL) {
                webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 };
            }
    
            // flag the graphics as not dirty as we are about to update it...
            webGL.dirty = graphics.dirty;
    
            // if the user cleared the graphics object we will need to clear every object
            if (graphics.clearDirty !== webGL.clearDirty) {
                webGL.clearDirty = graphics.clearDirty;
    
                // loop through and return all the webGLDatas to the object pool so than can be reused later on
                for (var i = 0; i < webGL.data.length; i++) {
                    this.graphicsDataPool.push(webGL.data[i]);
                }
    
                // clear the array and reset the index..
                webGL.data.length = 0;
                webGL.lastIndex = 0;
            }
    
            var webGLData = void 0;
            var webGLDataNativeLines = void 0;
    
            // loop through the graphics datas and construct each one..
            // if the object is a complex fill then the new stencil buffer technique will be used
            // other wise graphics objects will be pushed into a batch..
            for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {
                var data = graphics.graphicsData[_i];
    
                // TODO - this can be simplified
                webGLData = this.getWebGLData(webGL, 0);
    
                if (data.nativeLines && data.lineWidth) {
                    webGLDataNativeLines = this.getWebGLData(webGL, 0, true);
                    webGL.lastIndex++;
                }
    
                if (data.type === _const.SHAPES.POLY) {
                    (0, _buildPoly2.default)(data, webGLData, webGLDataNativeLines);
                }
                if (data.type === _const.SHAPES.RECT) {
                    (0, _buildRectangle2.default)(data, webGLData, webGLDataNativeLines);
                } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {
                    (0, _buildCircle2.default)(data, webGLData, webGLDataNativeLines);
                } else if (data.type === _const.SHAPES.RREC) {
                    (0, _buildRoundedRectangle2.default)(data, webGLData, webGLDataNativeLines);
                }
    
                webGL.lastIndex++;
            }
    
            this.renderer.bindVao(null);
    
            // upload all the dirty data...
            for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {
                webGLData = webGL.data[_i2];
    
                if (webGLData.dirty) {
                    webGLData.upload();
                }
            }
        };
    
        /**
         *
         * @private
         * @param {WebGLRenderingContext} gl - the current WebGL drawing context
         * @param {number} type - TODO @Alvin
         * @param {number} nativeLines - indicate whether the webGLData use for nativeLines.
         * @return {*} TODO
         */
    
    
        GraphicsRenderer.prototype.getWebGLData = function getWebGLData(gl, type, nativeLines) {
            var webGLData = gl.data[gl.data.length - 1];
    
            if (!webGLData || webGLData.nativeLines !== nativeLines || webGLData.points.length > 320000) {
                webGLData = this.graphicsDataPool.pop() || new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);
                webGLData.nativeLines = nativeLines;
                webGLData.reset(type);
                gl.data.push(webGLData);
            }
    
            webGLData.dirty = true;
    
            return webGLData;
        };
    
        return GraphicsRenderer;
    }(_ObjectRenderer3.default);
    
    exports.default = GraphicsRenderer;
    
    
    _WebGLRenderer2.default.registerPlugin('graphics', GraphicsRenderer);
    
    /***/ }),
    /* 137 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * An object containing WebGL specific properties to be used by the WebGL renderer
     *
     * @class
     * @private
     * @memberof PIXI
     */
    var WebGLGraphicsData = function () {
      /**
       * @param {WebGLRenderingContext} gl - The current WebGL drawing context
       * @param {PIXI.Shader} shader - The shader
       * @param {object} attribsState - The state for the VAO
       */
      function WebGLGraphicsData(gl, shader, attribsState) {
        _classCallCheck(this, WebGLGraphicsData);
    
        /**
         * The current WebGL drawing context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = gl;
    
        // TODO does this need to be split before uploading??
        /**
         * An array of color components (r,g,b)
         * @member {number[]}
         */
        this.color = [0, 0, 0]; // color split!
    
        /**
         * An array of points to draw
         * @member {PIXI.Point[]}
         */
        this.points = [];
    
        /**
         * The indices of the vertices
         * @member {number[]}
         */
        this.indices = [];
        /**
         * The main buffer
         * @member {WebGLBuffer}
         */
        this.buffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl);
    
        /**
         * The index buffer
         * @member {WebGLBuffer}
         */
        this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl);
    
        /**
         * Whether this graphics is dirty or not
         * @member {boolean}
         */
        this.dirty = true;
    
        /**
         * Whether this graphics is nativeLines or not
         * @member {boolean}
         */
        this.nativeLines = false;
    
        this.glPoints = null;
        this.glIndices = null;
    
        /**
         *
         * @member {PIXI.Shader}
         */
        this.shader = shader;
    
        this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, attribsState).addIndex(this.indexBuffer).addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4);
      }
    
      /**
       * Resets the vertices and the indices
       */
    
    
      WebGLGraphicsData.prototype.reset = function reset() {
        this.points.length = 0;
        this.indices.length = 0;
      };
    
      /**
       * Binds the buffers and uploads the data
       */
    
    
      WebGLGraphicsData.prototype.upload = function upload() {
        this.glPoints = new Float32Array(this.points);
        this.buffer.upload(this.glPoints);
    
        this.glIndices = new Uint16Array(this.indices);
        this.indexBuffer.upload(this.glIndices);
    
        this.dirty = false;
      };
    
      /**
       * Empties all the data
       */
    
    
      WebGLGraphicsData.prototype.destroy = function destroy() {
        this.color = null;
        this.points = null;
        this.indices = null;
    
        this.vao.destroy();
        this.buffer.destroy();
        this.indexBuffer.destroy();
    
        this.gl = null;
    
        this.buffer = null;
        this.indexBuffer = null;
    
        this.glPoints = null;
        this.glIndices = null;
      };
    
      return WebGLGraphicsData;
    }();
    
    exports.default = WebGLGraphicsData;
    
    /***/ }),
    /* 138 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Shader2 = __webpack_require__(16);
    
    var _Shader3 = _interopRequireDefault(_Shader2);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * This shader is used to draw simple primitive shapes for {@link PIXI.Graphics}.
     *
     * @class
     * @memberof PIXI
     * @extends PIXI.Shader
     */
    var PrimitiveShader = function (_Shader) {
        _inherits(PrimitiveShader, _Shader);
    
        /**
         * @param {WebGLRenderingContext} gl - The webgl shader manager this shader works for.
         */
        function PrimitiveShader(gl) {
            _classCallCheck(this, PrimitiveShader);
    
            return _possibleConstructorReturn(this, _Shader.call(this, gl,
            // vertex shader
            ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'),
            // fragment shader
            ['varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n')));
        }
    
        return PrimitiveShader;
    }(_Shader3.default);
    
    exports.default = PrimitiveShader;
    
    /***/ }),
    /* 139 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = buildPoly;
    
    var _buildLine = __webpack_require__(17);
    
    var _buildLine2 = _interopRequireDefault(_buildLine);
    
    var _utils = __webpack_require__(1);
    
    var _earcut = __webpack_require__(62);
    
    var _earcut2 = _interopRequireDefault(_earcut);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * Builds a polygon to draw
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
     * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
     * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
     */
    function buildPoly(graphicsData, webGLData, webGLDataNativeLines) {
        graphicsData.points = graphicsData.shape.points.slice();
    
        var points = graphicsData.points;
    
        if (graphicsData.fill && points.length >= 6) {
            var holeArray = [];
            // Process holes..
            var holes = graphicsData.holes;
    
            for (var i = 0; i < holes.length; i++) {
                var hole = holes[i];
    
                holeArray.push(points.length / 2);
    
                points = points.concat(hole.points);
            }
    
            // get first and last point.. figure out the middle!
            var verts = webGLData.points;
            var indices = webGLData.indices;
    
            var length = points.length / 2;
    
            // sort color
            var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
    
            var triangles = (0, _earcut2.default)(points, holeArray, 2);
    
            if (!triangles) {
                return;
            }
    
            var vertPos = verts.length / 6;
    
            for (var _i = 0; _i < triangles.length; _i += 3) {
                indices.push(triangles[_i] + vertPos);
                indices.push(triangles[_i] + vertPos);
                indices.push(triangles[_i + 1] + vertPos);
                indices.push(triangles[_i + 2] + vertPos);
                indices.push(triangles[_i + 2] + vertPos);
            }
    
            for (var _i2 = 0; _i2 < length; _i2++) {
                verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);
            }
        }
    
        if (graphicsData.lineWidth > 0) {
            (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
        }
    }
    
    /***/ }),
    /* 140 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = buildRectangle;
    
    var _buildLine = __webpack_require__(17);
    
    var _buildLine2 = _interopRequireDefault(_buildLine);
    
    var _utils = __webpack_require__(1);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * Builds a rectangle to draw
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
     * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
     * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
     */
    function buildRectangle(graphicsData, webGLData, webGLDataNativeLines) {
        // --- //
        // need to convert points to a nice regular data
        //
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
    
        if (graphicsData.fill) {
            var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
    
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
    
            var verts = webGLData.points;
            var indices = webGLData.indices;
    
            var vertPos = verts.length / 6;
    
            // start
            verts.push(x, y);
            verts.push(r, g, b, alpha);
    
            verts.push(x + width, y);
            verts.push(r, g, b, alpha);
    
            verts.push(x, y + height);
            verts.push(r, g, b, alpha);
    
            verts.push(x + width, y + height);
            verts.push(r, g, b, alpha);
    
            // insert 2 dead triangles..
            indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3);
        }
    
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
    
            graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];
    
            (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
    
            graphicsData.points = tempPoints;
        }
    }
    
    /***/ }),
    /* 141 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = buildRoundedRectangle;
    
    var _earcut = __webpack_require__(62);
    
    var _earcut2 = _interopRequireDefault(_earcut);
    
    var _buildLine = __webpack_require__(17);
    
    var _buildLine2 = _interopRequireDefault(_buildLine);
    
    var _utils = __webpack_require__(1);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * Builds a rounded rectangle to draw
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
     * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
     * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
     */
    function buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines) {
        var rrectData = graphicsData.shape;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
    
        var radius = rrectData.radius;
    
        var recPoints = [];
    
        recPoints.push(x, y + radius);
        quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
        quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
        quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
        quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);
    
        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
        // TODO - fix this properly, this is not very elegant.. but it works for now.
    
        if (graphicsData.fill) {
            var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
    
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
    
            var verts = webGLData.points;
            var indices = webGLData.indices;
    
            var vecPos = verts.length / 6;
    
            var triangles = (0, _earcut2.default)(recPoints, null, 2);
    
            for (var i = 0, j = triangles.length; i < j; i += 3) {
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i] + vecPos);
                indices.push(triangles[i + 1] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
                indices.push(triangles[i + 2] + vecPos);
            }
    
            for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {
                verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);
            }
        }
    
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
    
            graphicsData.points = recPoints;
    
            (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
    
            graphicsData.points = tempPoints;
        }
    }
    
    /**
     * Calculate a single point for a quadratic bezier curve.
     * Utility function used by quadraticBezierCurve.
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {number} n1 - first number
     * @param {number} n2 - second number
     * @param {number} perc - percentage
     * @return {number} the result
     *
     */
    function getPt(n1, n2, perc) {
        var diff = n2 - n1;
    
        return n1 + diff * perc;
    }
    
    /**
     * Calculate the points for a quadratic bezier curve. (helper function..)
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {number} fromX - Origin point x
     * @param {number} fromY - Origin point x
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
     * @return {number[]} an array of points
     */
    function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {
        var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
    
        var n = 20;
        var points = out;
    
        var xa = 0;
        var ya = 0;
        var xb = 0;
        var yb = 0;
        var x = 0;
        var y = 0;
    
        for (var i = 0, j = 0; i <= n; ++i) {
            j = i / n;
    
            // The Green Line
            xa = getPt(fromX, cpX, j);
            ya = getPt(fromY, cpY, j);
            xb = getPt(cpX, toX, j);
            yb = getPt(cpY, toY, j);
    
            // The Black Dot
            x = getPt(xa, xb, j);
            y = getPt(ya, yb, j);
    
            points.push(x, y);
        }
    
        return points;
    }
    
    /***/ }),
    /* 142 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = buildCircle;
    
    var _buildLine = __webpack_require__(17);
    
    var _buildLine2 = _interopRequireDefault(_buildLine);
    
    var _const = __webpack_require__(0);
    
    var _utils = __webpack_require__(1);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * Builds a circle to draw
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @private
     * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
     * @param {object} webGLData - an object containing all the webGL-specific information to create this shape
     * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines
     */
    function buildCircle(graphicsData, webGLData, webGLDataNativeLines) {
        // need to convert points to a nice regular data
        var circleData = graphicsData.shape;
        var x = circleData.x;
        var y = circleData.y;
        var width = void 0;
        var height = void 0;
    
        // TODO - bit hacky??
        if (graphicsData.type === _const.SHAPES.CIRC) {
            width = circleData.radius;
            height = circleData.radius;
        } else {
            width = circleData.width;
            height = circleData.height;
        }
    
        if (width === 0 || height === 0) {
            return;
        }
    
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
    
        var seg = Math.PI * 2 / totalSegs;
    
        if (graphicsData.fill) {
            var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
            var alpha = graphicsData.fillAlpha;
    
            var r = color[0] * alpha;
            var g = color[1] * alpha;
            var b = color[2] * alpha;
    
            var verts = webGLData.points;
            var indices = webGLData.indices;
    
            var vecPos = verts.length / 6;
    
            indices.push(vecPos);
    
            for (var i = 0; i < totalSegs + 1; i++) {
                verts.push(x, y, r, g, b, alpha);
    
                verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);
    
                indices.push(vecPos++, vecPos++);
            }
    
            indices.push(vecPos - 1);
        }
    
        if (graphicsData.lineWidth) {
            var tempPoints = graphicsData.points;
    
            graphicsData.points = [];
    
            for (var _i = 0; _i < totalSegs + 1; _i++) {
                graphicsData.points.push(x + Math.sin(seg * _i) * width, y + Math.cos(seg * _i) * height);
            }
    
            (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
    
            graphicsData.points = tempPoints;
        }
    }
    
    /***/ }),
    /* 143 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _CanvasRenderer = __webpack_require__(10);
    
    var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
    
    var _const = __webpack_require__(0);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * @author Mat Groves
     *
     * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/
     * for creating the original pixi version!
     * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they
     * now share 4 bytes on the vertex buffer
     *
     * Heavily inspired by LibGDX's CanvasGraphicsRenderer:
     * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java
     */
    
    /**
     * Renderer dedicated to drawing and batching graphics objects.
     *
     * @class
     * @private
     * @memberof PIXI
     */
    var CanvasGraphicsRenderer = function () {
        /**
         * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.
         */
        function CanvasGraphicsRenderer(renderer) {
            _classCallCheck(this, CanvasGraphicsRenderer);
    
            this.renderer = renderer;
        }
    
        /**
         * Renders a Graphics object to a canvas.
         *
         * @param {PIXI.Graphics} graphics - the actual graphics object to render
         */
    
    
        CanvasGraphicsRenderer.prototype.render = function render(graphics) {
            var renderer = this.renderer;
            var context = renderer.context;
            var worldAlpha = graphics.worldAlpha;
            var transform = graphics.transform.worldTransform;
            var resolution = renderer.resolution;
    
            // if the tint has changed, set the graphics object to dirty.
            if (this._prevTint !== this.tint) {
                this.dirty = true;
            }
    
            context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
    
            if (graphics.dirty) {
                this.updateGraphicsTint(graphics);
                graphics.dirty = false;
            }
    
            renderer.setBlendMode(graphics.blendMode);
    
            for (var i = 0; i < graphics.graphicsData.length; i++) {
                var data = graphics.graphicsData[i];
                var shape = data.shape;
    
                var fillColor = data._fillTint;
                var lineColor = data._lineTint;
    
                context.lineWidth = data.lineWidth;
    
                if (data.type === _const.SHAPES.POLY) {
                    context.beginPath();
    
                    this.renderPolygon(shape.points, shape.closed, context);
    
                    for (var j = 0; j < data.holes.length; j++) {
                        this.renderPolygon(data.holes[j].points, true, context);
                    }
    
                    if (data.fill) {
                        context.globalAlpha = data.fillAlpha * worldAlpha;
                        context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                        context.fill();
                    }
                    if (data.lineWidth) {
                        context.globalAlpha = data.lineAlpha * worldAlpha;
                        context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                        context.stroke();
                    }
                } else if (data.type === _const.SHAPES.RECT) {
                    if (data.fillColor || data.fillColor === 0) {
                        context.globalAlpha = data.fillAlpha * worldAlpha;
                        context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                        context.fillRect(shape.x, shape.y, shape.width, shape.height);
                    }
                    if (data.lineWidth) {
                        context.globalAlpha = data.lineAlpha * worldAlpha;
                        context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                        context.strokeRect(shape.x, shape.y, shape.width, shape.height);
                    }
                } else if (data.type === _const.SHAPES.CIRC) {
                    // TODO - need to be Undefined!
                    context.beginPath();
                    context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                    context.closePath();
    
                    if (data.fill) {
                        context.globalAlpha = data.fillAlpha * worldAlpha;
                        context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                        context.fill();
                    }
                    if (data.lineWidth) {
                        context.globalAlpha = data.lineAlpha * worldAlpha;
                        context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                        context.stroke();
                    }
                } else if (data.type === _const.SHAPES.ELIP) {
                    // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
    
                    var w = shape.width * 2;
                    var h = shape.height * 2;
    
                    var x = shape.x - w / 2;
                    var y = shape.y - h / 2;
    
                    context.beginPath();
    
                    var kappa = 0.5522848;
                    var ox = w / 2 * kappa; // control point offset horizontal
                    var oy = h / 2 * kappa; // control point offset vertical
                    var xe = x + w; // x-end
                    var ye = y + h; // y-end
                    var xm = x + w / 2; // x-middle
                    var ym = y + h / 2; // y-middle
    
                    context.moveTo(x, ym);
                    context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                    context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                    context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                    context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    
                    context.closePath();
    
                    if (data.fill) {
                        context.globalAlpha = data.fillAlpha * worldAlpha;
                        context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                        context.fill();
                    }
                    if (data.lineWidth) {
                        context.globalAlpha = data.lineAlpha * worldAlpha;
                        context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                        context.stroke();
                    }
                } else if (data.type === _const.SHAPES.RREC) {
                    var rx = shape.x;
                    var ry = shape.y;
                    var width = shape.width;
                    var height = shape.height;
                    var radius = shape.radius;
    
                    var maxRadius = Math.min(width, height) / 2 | 0;
    
                    radius = radius > maxRadius ? maxRadius : radius;
    
                    context.beginPath();
                    context.moveTo(rx, ry + radius);
                    context.lineTo(rx, ry + height - radius);
                    context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                    context.lineTo(rx + width - radius, ry + height);
                    context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                    context.lineTo(rx + width, ry + radius);
                    context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                    context.lineTo(rx + radius, ry);
                    context.quadraticCurveTo(rx, ry, rx, ry + radius);
                    context.closePath();
    
                    if (data.fillColor || data.fillColor === 0) {
                        context.globalAlpha = data.fillAlpha * worldAlpha;
                        context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                        context.fill();
                    }
    
                    if (data.lineWidth) {
                        context.globalAlpha = data.lineAlpha * worldAlpha;
                        context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                        context.stroke();
                    }
                }
            }
        };
    
        /**
         * Updates the tint of a graphics object
         *
         * @private
         * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated
         */
    
    
        CanvasGraphicsRenderer.prototype.updateGraphicsTint = function updateGraphicsTint(graphics) {
            graphics._prevTint = graphics.tint;
    
            var tintR = (graphics.tint >> 16 & 0xFF) / 255;
            var tintG = (graphics.tint >> 8 & 0xFF) / 255;
            var tintB = (graphics.tint & 0xFF) / 255;
    
            for (var i = 0; i < graphics.graphicsData.length; ++i) {
                var data = graphics.graphicsData[i];
    
                var fillColor = data.fillColor | 0;
                var lineColor = data.lineColor | 0;
    
                // super inline cos im an optimization NAZI :)
                data._fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;
    
                data._lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255;
            }
        };
    
        /**
         * Renders a polygon.
         *
         * @param {PIXI.Point[]} points - The points to render
         * @param {boolean} close - Should the polygon be closed
         * @param {CanvasRenderingContext2D} context - The rendering context to use
         */
    
    
        CanvasGraphicsRenderer.prototype.renderPolygon = function renderPolygon(points, close, context) {
            context.moveTo(points[0], points[1]);
    
            for (var j = 1; j < points.length / 2; ++j) {
                context.lineTo(points[j * 2], points[j * 2 + 1]);
            }
    
            if (close) {
                context.closePath();
            }
        };
    
        /**
         * destroy graphics object
         *
         */
    
    
        CanvasGraphicsRenderer.prototype.destroy = function destroy() {
            this.renderer = null;
        };
    
        return CanvasGraphicsRenderer;
    }();
    
    exports.default = CanvasGraphicsRenderer;
    
    
    _CanvasRenderer2.default.registerPlugin('graphics', CanvasGraphicsRenderer);
    
    /***/ }),
    /* 144 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _ = __webpack_require__(4);
    
    var _utils = __webpack_require__(1);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Utility class for maintaining reference to a collection
     * of Textures on a single Spritesheet.
     *
     * @class
     * @memberof PIXI
     */
    var Spritesheet = function () {
        _createClass(Spritesheet, null, [{
            key: 'BATCH_SIZE',
    
            /**
             * The maximum number of Textures to build per process.
             *
             * @type {number}
             * @default 1000
             */
            get: function get() {
                return 1000;
            }
    
            /**
             * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.
             * @param {Object} data - Spritesheet image data.
             * @param {string} [resolutionFilename] - The filename to consider when determining
             *        the resolution of the spritesheet. If not provided, the imageUrl will
             *        be used on the BaseTexture.
             */
    
        }]);
    
        function Spritesheet(baseTexture, data) {
            var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    
            _classCallCheck(this, Spritesheet);
    
            /**
             * Reference to ths source texture
             * @type {PIXI.BaseTexture}
             */
            this.baseTexture = baseTexture;
    
            /**
             * Map of spritesheet textures.
             * @type {Object}
             */
            this.textures = {};
    
            /**
             * Reference to the original JSON data.
             * @type {Object}
             */
            this.data = data;
    
            /**
             * The resolution of the spritesheet.
             * @type {number}
             */
            this.resolution = this._updateResolution(resolutionFilename || this.baseTexture.imageUrl);
    
            /**
             * Map of spritesheet frames.
             * @type {Object}
             * @private
             */
            this._frames = this.data.frames;
    
            /**
             * Collection of frame names.
             * @type {string[]}
             * @private
             */
            this._frameKeys = Object.keys(this._frames);
    
            /**
             * Current batch index being processed.
             * @type {number}
             * @private
             */
            this._batchIndex = 0;
    
            /**
             * Callback when parse is completed.
             * @type {Function}
             * @private
             */
            this._callback = null;
        }
    
        /**
         * Generate the resolution from the filename or fallback
         * to the meta.scale field of the JSON data.
         *
         * @private
         * @param {string} resolutionFilename - The filename to use for resolving
         *        the default resolution.
         * @return {number} Resolution to use for spritesheet.
         */
    
    
        Spritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {
            var scale = this.data.meta.scale;
    
            // Use a defaultValue of `null` to check if a url-based resolution is set
            var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null);
    
            // No resolution found via URL
            if (resolution === null) {
                // Use the scale value or default to 1
                resolution = scale !== undefined ? parseFloat(scale) : 1;
            }
    
            // For non-1 resolutions, update baseTexture
            if (resolution !== 1) {
                this.baseTexture.resolution = resolution;
                this.baseTexture.update();
            }
    
            return resolution;
        };
    
        /**
         * Parser spritesheet from loaded data. This is done asynchronously
         * to prevent creating too many Texture within a single process.
         *
         * @param {Function} callback - Callback when complete returns
         *        a map of the Textures for this spritesheet.
         */
    
    
        Spritesheet.prototype.parse = function parse(callback) {
            this._batchIndex = 0;
            this._callback = callback;
    
            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
                this._processFrames(0);
                this._parseComplete();
            } else {
                this._nextBatch();
            }
        };
    
        /**
         * Process a batch of frames
         *
         * @private
         * @param {number} initialFrameIndex - The index of frame to start.
         */
    
    
        Spritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {
            var frameIndex = initialFrameIndex;
            var maxFrames = Spritesheet.BATCH_SIZE;
    
            while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
                var i = this._frameKeys[frameIndex];
                var rect = this._frames[i].frame;
    
                if (rect) {
                    var frame = null;
                    var trim = null;
                    var orig = new _.Rectangle(0, 0, this._frames[i].sourceSize.w / this.resolution, this._frames[i].sourceSize.h / this.resolution);
    
                    if (this._frames[i].rotated) {
                        frame = new _.Rectangle(rect.x / this.resolution, rect.y / this.resolution, rect.h / this.resolution, rect.w / this.resolution);
                    } else {
                        frame = new _.Rectangle(rect.x / this.resolution, rect.y / this.resolution, rect.w / this.resolution, rect.h / this.resolution);
                    }
    
                    //  Check to see if the sprite is trimmed
                    if (this._frames[i].trimmed) {
                        trim = new _.Rectangle(this._frames[i].spriteSourceSize.x / this.resolution, this._frames[i].spriteSourceSize.y / this.resolution, rect.w / this.resolution, rect.h / this.resolution);
                    }
    
                    this.textures[i] = new _.Texture(this.baseTexture, frame, orig, trim, this._frames[i].rotated ? 2 : 0);
    
                    // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                    _.Texture.addToCache(this.textures[i], i);
                }
    
                frameIndex++;
            }
        };
    
        /**
         * The parse has completed.
         *
         * @private
         */
    
    
        Spritesheet.prototype._parseComplete = function _parseComplete() {
            var callback = this._callback;
    
            this._callback = null;
            this._batchIndex = 0;
            callback.call(this, this.textures);
        };
    
        /**
         * Begin the next batch of textures.
         *
         * @private
         */
    
    
        Spritesheet.prototype._nextBatch = function _nextBatch() {
            var _this = this;
    
            this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
            this._batchIndex++;
            setTimeout(function () {
                if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {
                    _this._nextBatch();
                } else {
                    _this._parseComplete();
                }
            }, 0);
        };
    
        /**
         * Destroy Spritesheet and don't use after this.
         *
         * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
         */
    
    
        Spritesheet.prototype.destroy = function destroy() {
            var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    
            for (var i in this.textures) {
                this.textures[i].destroy();
            }
            this._frames = null;
            this._frameKeys = null;
            this.data = null;
            this.textures = null;
            if (destroyBase) {
                this.baseTexture.destroy();
            }
            this.baseTexture = null;
        };
    
        return Spritesheet;
    }();
    
    exports.default = Spritesheet;
    
    /***/ }),
    /* 145 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _InteractionData = __webpack_require__(65);
    
    Object.defineProperty(exports, 'InteractionData', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_InteractionData).default;
      }
    });
    
    var _InteractionManager = __webpack_require__(146);
    
    Object.defineProperty(exports, 'InteractionManager', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_InteractionManager).default;
      }
    });
    
    var _interactiveTarget = __webpack_require__(66);
    
    Object.defineProperty(exports, 'interactiveTarget', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_interactiveTarget).default;
      }
    });
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /***/ }),
    /* 146 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    var _InteractionData = __webpack_require__(65);
    
    var _InteractionData2 = _interopRequireDefault(_InteractionData);
    
    var _InteractionEvent = __webpack_require__(147);
    
    var _InteractionEvent2 = _interopRequireDefault(_InteractionEvent);
    
    var _InteractionTrackingData = __webpack_require__(148);
    
    var _InteractionTrackingData2 = _interopRequireDefault(_InteractionTrackingData);
    
    var _eventemitter = __webpack_require__(6);
    
    var _eventemitter2 = _interopRequireDefault(_eventemitter);
    
    var _interactiveTarget = __webpack_require__(66);
    
    var _interactiveTarget2 = _interopRequireDefault(_interactiveTarget);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    // Mix interactiveTarget into core.DisplayObject.prototype, after deprecation has been handled
    core.utils.mixins.delayMixin(core.DisplayObject.prototype, _interactiveTarget2.default);
    
    var MOUSE_POINTER_ID = 'MOUSE';
    
    // helpers for hitTest() - only used inside hitTest()
    var hitTestEvent = {
        target: null,
        data: {
            global: null
        }
    };
    
    /**
     * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive
     * if its interactive parameter is set to true
     * This manager also supports multitouch.
     *
     * An instance of this class is automatically created by default, and can be found at renderer.plugins.interaction
     *
     * @class
     * @extends EventEmitter
     * @memberof PIXI.interaction
     */
    
    var InteractionManager = function (_EventEmitter) {
        _inherits(InteractionManager, _EventEmitter);
    
        /**
         * @param {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - A reference to the current renderer
         * @param {object} [options] - The options for the manager.
         * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.
         * @param {number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.
         */
        function InteractionManager(renderer, options) {
            _classCallCheck(this, InteractionManager);
    
            var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
    
            options = options || {};
    
            /**
             * The renderer this interaction manager works for.
             *
             * @member {PIXI.SystemRenderer}
             */
            _this.renderer = renderer;
    
            /**
             * Should default browser actions automatically be prevented.
             * Does not apply to pointer events for backwards compatibility
             * preventDefault on pointer events stops mouse events from firing
             * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
             *
             * @member {boolean}
             * @default true
             */
            _this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;
    
            /**
             * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.
             *
             * @member {number}
             * @default 10
             */
            _this.interactionFrequency = options.interactionFrequency || 10;
    
            /**
             * The mouse data
             *
             * @member {PIXI.interaction.InteractionData}
             */
            _this.mouse = new _InteractionData2.default();
            _this.mouse.identifier = MOUSE_POINTER_ID;
    
            // setting the mouse to start off far off screen will mean that mouse over does
            //  not get called before we even move the mouse.
            _this.mouse.global.set(-999999);
    
            /**
             * Actively tracked InteractionData
             *
             * @private
             * @member {Object.<number,PIXI.interation.InteractionData>}
             */
            _this.activeInteractionData = {};
            _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
    
            /**
             * Pool of unused InteractionData
             *
             * @private
             * @member {PIXI.interation.InteractionData[]}
             */
            _this.interactionDataPool = [];
    
            /**
             * An event data object to handle all the event tracking/dispatching
             *
             * @member {object}
             */
            _this.eventData = new _InteractionEvent2.default();
    
            /**
             * The DOM element to bind to.
             *
             * @private
             * @member {HTMLElement}
             */
            _this.interactionDOMElement = null;
    
            /**
             * This property determines if mousemove and touchmove events are fired only when the cursor
             * is over the object.
             * Setting to true will make things work more in line with how the DOM verison works.
             * Setting to false can make things easier for things like dragging
             * It is currently set to false as this is how pixi used to work. This will be set to true in
             * future versions of pixi.
             *
             * @member {boolean}
             * @default false
             */
            _this.moveWhenInside = false;
    
            /**
             * Have events been attached to the dom element?
             *
             * @private
             * @member {boolean}
             */
            _this.eventsAdded = false;
    
            /**
             * Is the mouse hovering over the renderer?
             *
             * @private
             * @member {boolean}
             */
            _this.mouseOverRenderer = false;
    
            /**
             * Does the device support touch events
             * https://www.w3.org/TR/touch-events/
             *
             * @readonly
             * @member {boolean}
             */
            _this.supportsTouchEvents = 'ontouchstart' in window;
    
            /**
             * Does the device support pointer events
             * https://www.w3.org/Submission/pointer-events/
             *
             * @readonly
             * @member {boolean}
             */
            _this.supportsPointerEvents = !!window.PointerEvent;
    
            // this will make it so that you don't have to call bind all the time
    
            /**
             * @private
             * @member {Function}
             */
            _this.onPointerUp = _this.onPointerUp.bind(_this);
            _this.processPointerUp = _this.processPointerUp.bind(_this);
    
            /**
             * @private
             * @member {Function}
             */
            _this.onPointerCancel = _this.onPointerCancel.bind(_this);
            _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    
            /**
             * @private
             * @member {Function}
             */
            _this.onPointerDown = _this.onPointerDown.bind(_this);
            _this.processPointerDown = _this.processPointerDown.bind(_this);
    
            /**
             * @private
             * @member {Function}
             */
            _this.onPointerMove = _this.onPointerMove.bind(_this);
            _this.processPointerMove = _this.processPointerMove.bind(_this);
    
            /**
             * @private
             * @member {Function}
             */
            _this.onPointerOut = _this.onPointerOut.bind(_this);
            _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    
            /**
             * @private
             * @member {Function}
             */
            _this.onPointerOver = _this.onPointerOver.bind(_this);
    
            /**
             * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor
             * values, objects are handled as dictionaries of CSS values for interactionDOMElement,
             * and functions are called instead of changing the CSS.
             * Default CSS cursor values are provided for 'default' and 'pointer' modes.
             * @member {Object.<string, (string|Function|Object.<string, string>)>}
             */
            _this.cursorStyles = {
                default: 'inherit',
                pointer: 'pointer'
            };
    
            /**
             * The mode of the cursor that is being used.
             * The value of this is a key from the cursorStyles dictionary.
             *
             * @member {string}
             */
            _this.currentCursorMode = null;
    
            /**
             * Internal cached let.
             *
             * @private
             * @member {string}
             */
            _this.cursor = null;
    
            /**
             * Internal cached let.
             *
             * @private
             * @member {PIXI.Point}
             */
            _this._tempPoint = new core.Point();
    
            /**
             * The current resolution / device pixel ratio.
             *
             * @member {number}
             * @default 1
             */
            _this.resolution = 1;
    
            _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is pressed on the display
             * object.
             *
             * @event PIXI.interaction.InteractionManager#mousedown
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
             * on the display object.
             *
             * @event PIXI.interaction.InteractionManager#rightdown
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is released over the display
             * object.
             *
             * @event PIXI.interaction.InteractionManager#mouseup
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is released
             * over the display object.
             *
             * @event PIXI.interaction.InteractionManager#rightup
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
             * the display object.
             *
             * @event PIXI.interaction.InteractionManager#click
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
             * and released on the display object.
             *
             * @event PIXI.interaction.InteractionManager#rightclick
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is released outside the
             * display object that initially registered a
             * [mousedown]{@link PIXI.interaction.InteractionManager#event:mousedown}.
             *
             * @event PIXI.interaction.InteractionManager#mouseupoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is released
             * outside the display object that initially registered a
             * [rightdown]{@link PIXI.interaction.InteractionManager#event:rightdown}.
             *
             * @event PIXI.interaction.InteractionManager#rightupoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device (usually a mouse) is moved while over the display object
             *
             * @event PIXI.interaction.InteractionManager#mousemove
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device (usually a mouse) is moved onto the display object
             *
             * @event PIXI.interaction.InteractionManager#mouseover
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device (usually a mouse) is moved off the display object
             *
             * @event PIXI.interaction.InteractionManager#mouseout
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is pressed on the display object.
             *
             * @event PIXI.interaction.InteractionManager#pointerdown
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is released over the display object.
             *
             * @event PIXI.interaction.InteractionManager#pointerup
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when the operating system cancels a pointer event
             *
             * @event PIXI.interaction.InteractionManager#pointercancel
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is pressed and released on the display object.
             *
             * @event PIXI.interaction.InteractionManager#pointertap
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is released outside the display object that initially
             * registered a [pointerdown]{@link PIXI.interaction.InteractionManager#event:pointerdown}.
             *
             * @event PIXI.interaction.InteractionManager#pointerupoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device is moved while over the display object
             *
             * @event PIXI.interaction.InteractionManager#pointermove
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device is moved onto the display object
             *
             * @event PIXI.interaction.InteractionManager#pointerover
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device is moved off the display object
             *
             * @event PIXI.interaction.InteractionManager#pointerout
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is placed on the display object.
             *
             * @event PIXI.interaction.InteractionManager#touchstart
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is removed from the display object.
             *
             * @event PIXI.interaction.InteractionManager#touchend
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when the operating system cancels a touch
             *
             * @event PIXI.interaction.InteractionManager#touchcancel
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is placed and removed from the display object.
             *
             * @event PIXI.interaction.InteractionManager#tap
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is removed outside of the display object that initially
             * registered a [touchstart]{@link PIXI.interaction.InteractionManager#event:touchstart}.
             *
             * @event PIXI.interaction.InteractionManager#touchendoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is moved along the display object.
             *
             * @event PIXI.interaction.InteractionManager#touchmove
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.
             * object. DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#mousedown
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
             * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#rightdown
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is released over the display
             * object. DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#mouseup
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is released
             * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#rightup
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is pressed and released on
             * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#click
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is pressed
             * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#rightclick
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button (usually a mouse left-button) is released outside the
             * display object that initially registered a
             * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#mouseupoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device secondary button (usually a mouse right-button) is released
             * outside the display object that initially registered a
             * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#rightupoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device (usually a mouse) is moved while over the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#mousemove
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device (usually a mouse) is moved onto the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#mouseover
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device (usually a mouse) is moved off the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#mouseout
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is pressed on the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointerdown
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is released over the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointerup
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when the operating system cancels a pointer event.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointercancel
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is pressed and released on the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointertap
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device button is released outside the display object that initially
             * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointerupoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device is moved while over the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointermove
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device is moved onto the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointerover
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a pointer device is moved off the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#pointerout
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is placed on the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#touchstart
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is removed from the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#touchend
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when the operating system cancels a touch.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#touchcancel
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is placed and removed from the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#tap
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is removed outside of the display object that initially
             * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#touchendoutside
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
    
            /**
             * Fired when a touch point is moved along the display object.
             * DisplayObject's `interactive` property must be set to `true` to fire event.
             *
             * @event PIXI.DisplayObject#touchmove
             * @param {PIXI.interaction.InteractionEvent} event - Interaction event
             */
            return _this;
        }
    
        /**
         * Hit tests a point against the display tree, returning the first interactive object that is hit.
         *
         * @param {PIXI.Point} globalPoint - A point to hit test with, in global space.
         * @param {PIXI.Container} [root] - The root display object to start from. If omitted, defaults
         * to the last rendered root of the associated renderer.
         * @return {PIXI.DisplayObject} The hit display object, if any.
         */
    
    
        InteractionManager.prototype.hitTest = function hitTest(globalPoint, root) {
            // clear the target for our hit test
            hitTestEvent.target = null;
            // assign the global point
            hitTestEvent.data.global = globalPoint;
            // ensure safety of the root
            if (!root) {
                root = this.renderer._lastObjectRendered;
            }
            // run the hit test
            this.processInteractive(hitTestEvent, root, null, true);
            // return our found object - it'll be null if we didn't hit anything
    
            return hitTestEvent.target;
        };
    
        /**
         * Sets the DOM element which will receive mouse/touch events. This is useful for when you have
         * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate
         * another DOM element to receive those events.
         *
         * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.
         * @param {number} [resolution=1] - The resolution / device pixel ratio of the new element (relative to the canvas).
         * @private
         */
    
    
        InteractionManager.prototype.setTargetElement = function setTargetElement(element) {
            var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    
            this.removeEvents();
    
            this.interactionDOMElement = element;
    
            this.resolution = resolution;
    
            this.addEvents();
        };
    
        /**
         * Registers all the DOM events
         *
         * @private
         */
    
    
        InteractionManager.prototype.addEvents = function addEvents() {
            if (!this.interactionDOMElement) {
                return;
            }
    
            core.ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.INTERACTION);
    
            if (window.navigator.msPointerEnabled) {
                this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
                this.interactionDOMElement.style['-ms-touch-action'] = 'none';
            } else if (this.supportsPointerEvents) {
                this.interactionDOMElement.style['touch-action'] = 'none';
            }
    
            /**
             * These events are added first, so that if pointer events are normalised, they are fired
             * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd
             */
            if (this.supportsPointerEvents) {
                window.document.addEventListener('pointermove', this.onPointerMove, true);
                this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);
                // pointerout is fired in addition to pointerup (for touch events) and pointercancel
                // we already handle those, so for the purposes of what we do in onPointerOut, we only
                // care about the pointerleave event
                this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);
                this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);
                window.addEventListener('pointercancel', this.onPointerCancel, true);
                window.addEventListener('pointerup', this.onPointerUp, true);
            } else {
                window.document.addEventListener('mousemove', this.onPointerMove, true);
                this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);
                this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);
                this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);
                window.addEventListener('mouseup', this.onPointerUp, true);
            }
    
            // always look directly for touch events so that we can provide original data
            // In a future version we should change this to being just a fallback and rely solely on
            // PointerEvents whenever available
            if (this.supportsTouchEvents) {
                this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);
                this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);
                this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);
                this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);
            }
    
            this.eventsAdded = true;
        };
    
        /**
         * Removes all the DOM events that were previously registered
         *
         * @private
         */
    
    
        InteractionManager.prototype.removeEvents = function removeEvents() {
            if (!this.interactionDOMElement) {
                return;
            }
    
            core.ticker.shared.remove(this.update, this);
    
            if (window.navigator.msPointerEnabled) {
                this.interactionDOMElement.style['-ms-content-zooming'] = '';
                this.interactionDOMElement.style['-ms-touch-action'] = '';
            } else if (this.supportsPointerEvents) {
                this.interactionDOMElement.style['touch-action'] = '';
            }
    
            if (this.supportsPointerEvents) {
                window.document.removeEventListener('pointermove', this.onPointerMove, true);
                this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);
                this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);
                this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);
                window.removeEventListener('pointercancel', this.onPointerCancel, true);
                window.removeEventListener('pointerup', this.onPointerUp, true);
            } else {
                window.document.removeEventListener('mousemove', this.onPointerMove, true);
                this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);
                this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);
                this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);
                window.removeEventListener('mouseup', this.onPointerUp, true);
            }
    
            if (this.supportsTouchEvents) {
                this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);
                this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);
                this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);
                this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);
            }
    
            this.interactionDOMElement = null;
    
            this.eventsAdded = false;
        };
    
        /**
         * Updates the state of interactive objects.
         * Invoked by a throttled ticker update from {@link PIXI.ticker.shared}.
         *
         * @param {number} deltaTime - time delta since last tick
         */
    
    
        InteractionManager.prototype.update = function update(deltaTime) {
            this._deltaTime += deltaTime;
    
            if (this._deltaTime < this.interactionFrequency) {
                return;
            }
    
            this._deltaTime = 0;
    
            if (!this.interactionDOMElement) {
                return;
            }
    
            // if the user move the mouse this check has already been done using the mouse move!
            if (this.didMove) {
                this.didMove = false;
    
                return;
            }
    
            this.cursor = null;
    
            // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,
            // but there was a scenario of a display object moving under a static mouse cursor.
            // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function
            for (var k in this.activeInteractionData) {
                // eslint-disable-next-line no-prototype-builtins
                if (this.activeInteractionData.hasOwnProperty(k)) {
                    var interactionData = this.activeInteractionData[k];
    
                    if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
                        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
    
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);
                    }
                }
            }
    
            this.setCursorMode(this.cursor);
    
            // TODO
        };
    
        /**
         * Sets the current cursor mode, handling any callbacks or CSS style changes.
         *
         * @param {string} mode - cursor mode, a key from the cursorStyles dictionary
         */
    
    
        InteractionManager.prototype.setCursorMode = function setCursorMode(mode) {
            mode = mode || 'default';
            // if the mode didn't actually change, bail early
            if (this.currentCursorMode === mode) {
                return;
            }
            this.currentCursorMode = mode;
            var style = this.cursorStyles[mode];
    
            // only do things if there is a cursor style for it
            if (style) {
                switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {
                    case 'string':
                        // string styles are handled as cursor CSS
                        this.interactionDOMElement.style.cursor = style;
                        break;
                    case 'function':
                        // functions are just called, and passed the cursor mode
                        style(mode);
                        break;
                    case 'object':
                        // if it is an object, assume that it is a dictionary of CSS styles,
                        // apply it to the interactionDOMElement
                        Object.assign(this.interactionDOMElement.style, style);
                        break;
                }
            } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
                // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry
                // for the mode, then assume that the dev wants it to be CSS for the cursor.
                this.interactionDOMElement.style.cursor = mode;
            }
        };
    
        /**
         * Dispatches an event on the display object that was interacted with
         *
         * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - the display object in question
         * @param {string} eventString - the name of the event (e.g, mousedown)
         * @param {object} eventData - the event data object
         * @private
         */
    
    
        InteractionManager.prototype.dispatchEvent = function dispatchEvent(displayObject, eventString, eventData) {
            if (!eventData.stopped) {
                eventData.currentTarget = displayObject;
                eventData.type = eventString;
    
                displayObject.emit(eventString, eventData);
    
                if (displayObject[eventString]) {
                    displayObject[eventString](eventData);
                }
            }
        };
    
        /**
         * Maps x and y coords from a DOM object and maps them correctly to the pixi view. The
         * resulting value is stored in the point. This takes into account the fact that the DOM
         * element could be scaled and positioned anywhere on the screen.
         *
         * @param  {PIXI.Point} point - the point that the result will be stored in
         * @param  {number} x - the x coord of the position to map
         * @param  {number} y - the y coord of the position to map
         */
    
    
        InteractionManager.prototype.mapPositionToPoint = function mapPositionToPoint(point, x, y) {
            var rect = void 0;
    
            // IE 11 fix
            if (!this.interactionDOMElement.parentElement) {
                rect = { x: 0, y: 0, width: 0, height: 0 };
            } else {
                rect = this.interactionDOMElement.getBoundingClientRect();
            }
    
            var resolutionMultiplier = navigator.isCocoonJS ? this.resolution : 1.0 / this.resolution;
    
            point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
            point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
        };
    
        /**
         * This function is provides a neat way of crawling through the scene graph and running a
         * specified function on all interactive objects it finds. It will also take care of hit
         * testing the interactive objects and passes the hit across in the function.
         *
         * @private
         * @param {PIXI.interaction.InteractionEvent} interactionEvent - event containing the point that
         *  is tested for collision
         * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - the displayObject
         *  that will be hit test (recursively crawls its children)
         * @param {Function} [func] - the function that will be called on each interactive object. The
         *  interactionEvent, displayObject and hit will be passed to the function
         * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point
         * @param {boolean} [interactive] - Whether the displayObject is interactive
         * @return {boolean} returns true if the displayObject hit the point
         */
    
    
        InteractionManager.prototype.processInteractive = function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {
            if (!displayObject || !displayObject.visible) {
                return false;
            }
    
            var point = interactionEvent.data.global;
    
            // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^
            //
            // This function will now loop through all objects and then only hit test the objects it HAS
            // to, not all of them. MUCH faster..
            // An object will be hit test if the following is true:
            //
            // 1: It is interactive.
            // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.
            //
            // As another little optimisation once an interactive object has been hit we can carry on
            // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests
            // A final optimisation is that an object is not hit test directly if a child has already been hit.
    
            interactive = displayObject.interactive || interactive;
    
            var hit = false;
            var interactiveParent = interactive;
    
            // if the displayobject has a hitArea, then it does not need to hitTest children.
            if (displayObject.hitArea) {
                interactiveParent = false;
            }
            // it has a mask! Then lets hit test that before continuing
            else if (hitTest && displayObject._mask) {
                    if (!displayObject._mask.containsPoint(point)) {
                        hitTest = false;
                    }
                }
    
            // ** FREE TIP **! If an object is not interactive or has no buttons in it
            // (such as a game scene!) set interactiveChildren to false for that displayObject.
            // This will allow pixi to completely ignore and bypass checking the displayObjects children.
            if (displayObject.interactiveChildren && displayObject.children) {
                var children = displayObject.children;
    
                for (var i = children.length - 1; i >= 0; i--) {
                    var child = children[i];
    
                    // time to get recursive.. if this function will return if something is hit..
                    var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
    
                    if (childHit) {
                        // its a good idea to check if a child has lost its parent.
                        // this means it has been removed whilst looping so its best
                        if (!child.parent) {
                            continue;
                        }
    
                        // we no longer need to hit test any more objects in this container as we we
                        // now know the parent has been hit
                        interactiveParent = false;
    
                        // If the child is interactive , that means that the object hit was actually
                        // interactive and not just the child of an interactive object.
                        // This means we no longer need to hit test anything else. We still need to run
                        // through all objects, but we don't need to perform any hit tests.
    
                        if (childHit) {
                            if (interactionEvent.target) {
                                hitTest = false;
                            }
                            hit = true;
                        }
                    }
                }
            }
    
            // no point running this if the item is not interactive or does not have an interactive parent.
            if (interactive) {
                // if we are hit testing (as in we have no hit any objects yet)
                // We also don't need to worry about hit testing if once of the displayObjects children
                // has already been hit - but only if it was interactive, otherwise we need to keep
                // looking for an interactive child, just in case we hit one
                if (hitTest && !interactionEvent.target) {
                    if (displayObject.hitArea) {
                        displayObject.worldTransform.applyInverse(point, this._tempPoint);
                        if (displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
                            hit = true;
                        }
                    } else if (displayObject.containsPoint) {
                        if (displayObject.containsPoint(point)) {
                            hit = true;
                        }
                    }
                }
    
                if (displayObject.interactive) {
                    if (hit && !interactionEvent.target) {
                        interactionEvent.target = displayObject;
                    }
    
                    if (func) {
                        func(interactionEvent, displayObject, !!hit);
                    }
                }
            }
    
            return hit;
        };
    
        /**
         * Is called when the pointer button is pressed down on the renderer element
         *
         * @private
         * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down
         */
    
    
        InteractionManager.prototype.onPointerDown = function onPointerDown(originalEvent) {
            // if we support touch events, then only use those for touch events, not pointer events
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
    
            var events = this.normalizeToPointerData(originalEvent);
    
            /**
             * No need to prevent default on natural pointer events, as there are no side effects
             * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,
             * so still need to be prevented.
             */
    
            // Guaranteed that there will be at least one event in events, and all events must have the same pointer type
    
            if (this.autoPreventDefault && events[0].isNormalized) {
                originalEvent.preventDefault();
            }
    
            var eventLen = events.length;
    
            for (var i = 0; i < eventLen; i++) {
                var event = events[i];
    
                var interactionData = this.getInteractionDataForPointerId(event);
    
                var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    
                interactionEvent.data.originalEvent = originalEvent;
    
                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);
    
                this.emit('pointerdown', interactionEvent);
                if (event.pointerType === 'touch') {
                    this.emit('touchstart', interactionEvent);
                }
                // emit a mouse event for "pen" pointers, the way a browser would emit a fallback event
                else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                        var isRightButton = event.button === 2;
    
                        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);
                    }
            }
        };
    
        /**
         * Processes the result of the pointer down check and dispatches the event if need be
         *
         * @private
         * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
         * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
         * @param {boolean} hit - the result of the hit test on the display object
         */
    
    
        InteractionManager.prototype.processPointerDown = function processPointerDown(interactionEvent, displayObject, hit) {
            var data = interactionEvent.data;
            var id = interactionEvent.data.identifier;
    
            if (hit) {
                if (!displayObject.trackedPointers[id]) {
                    displayObject.trackedPointers[id] = new _InteractionTrackingData2.default(id);
                }
                this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);
    
                if (data.pointerType === 'touch') {
                    this.dispatchEvent(displayObject, 'touchstart', interactionEvent);
                } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
                    var isRightButton = data.button === 2;
    
                    if (isRightButton) {
                        displayObject.trackedPointers[id].rightDown = true;
                    } else {
                        displayObject.trackedPointers[id].leftDown = true;
                    }
    
                    this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);
                }
            }
        };
    
        /**
         * Is called when the pointer button is released on the renderer element
         *
         * @private
         * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released
         * @param {boolean} cancelled - true if the pointer is cancelled
         * @param {Function} func - Function passed to {@link processInteractive}
         */
    
    
        InteractionManager.prototype.onPointerComplete = function onPointerComplete(originalEvent, cancelled, func) {
            var events = this.normalizeToPointerData(originalEvent);
    
            var eventLen = events.length;
    
            // if the event wasn't targeting our canvas, then consider it to be pointerupoutside
            // in all cases (unless it was a pointercancel)
            var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';
    
            for (var i = 0; i < eventLen; i++) {
                var event = events[i];
    
                var interactionData = this.getInteractionDataForPointerId(event);
    
                var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    
                interactionEvent.data.originalEvent = originalEvent;
    
                // perform hit testing for events targeting our canvas or cancel events
                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);
    
                this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);
    
                if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    var isRightButton = event.button === 2;
    
                    this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);
                } else if (event.pointerType === 'touch') {
                    this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);
                    this.releaseInteractionDataForPointerId(event.pointerId, interactionData);
                }
            }
        };
    
        /**
         * Is called when the pointer button is cancelled
         *
         * @private
         * @param {PointerEvent} event - The DOM event of a pointer button being released
         */
    
    
        InteractionManager.prototype.onPointerCancel = function onPointerCancel(event) {
            // if we support touch events, then only use those for touch events, not pointer events
            if (this.supportsTouchEvents && event.pointerType === 'touch') return;
    
            this.onPointerComplete(event, true, this.processPointerCancel);
        };
    
        /**
         * Processes the result of the pointer cancel check and dispatches the event if need be
         *
         * @private
         * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
         * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
         */
    
    
        InteractionManager.prototype.processPointerCancel = function processPointerCancel(interactionEvent, displayObject) {
            var data = interactionEvent.data;
    
            var id = interactionEvent.data.identifier;
    
            if (displayObject.trackedPointers[id] !== undefined) {
                delete displayObject.trackedPointers[id];
                this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);
    
                if (data.pointerType === 'touch') {
                    this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);
                }
            }
        };
    
        /**
         * Is called when the pointer button is released on the renderer element
         *
         * @private
         * @param {PointerEvent} event - The DOM event of a pointer button being released
         */
    
    
        InteractionManager.prototype.onPointerUp = function onPointerUp(event) {
            // if we support touch events, then only use those for touch events, not pointer events
            if (this.supportsTouchEvents && event.pointerType === 'touch') return;
    
            this.onPointerComplete(event, false, this.processPointerUp);
        };
    
        /**
         * Processes the result of the pointer up check and dispatches the event if need be
         *
         * @private
         * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
         * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
         * @param {boolean} hit - the result of the hit test on the display object
         */
    
    
        InteractionManager.prototype.processPointerUp = function processPointerUp(interactionEvent, displayObject, hit) {
            var data = interactionEvent.data;
    
            var id = interactionEvent.data.identifier;
    
            var trackingData = displayObject.trackedPointers[id];
    
            var isTouch = data.pointerType === 'touch';
    
            var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';
    
            // Mouse only
            if (isMouse) {
                var isRightButton = data.button === 2;
    
                var flags = _InteractionTrackingData2.default.FLAGS;
    
                var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
    
                var isDown = trackingData !== undefined && trackingData.flags & test;
    
                if (hit) {
                    this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);
    
                    if (isDown) {
                        this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent);
                    }
                } else if (isDown) {
                    this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);
                }
                // update the down state of the tracking data
                if (trackingData) {
                    if (isRightButton) {
                        trackingData.rightDown = false;
                    } else {
                        trackingData.leftDown = false;
                    }
                }
            }
    
            // Pointers and Touches, and Mouse
            if (hit) {
                this.dispatchEvent(displayObject, 'pointerup', interactionEvent);
                if (isTouch) this.dispatchEvent(displayObject, 'touchend', interactionEvent);
    
                if (trackingData) {
                    this.dispatchEvent(displayObject, 'pointertap', interactionEvent);
                    if (isTouch) {
                        this.dispatchEvent(displayObject, 'tap', interactionEvent);
                        // touches are no longer over (if they ever were) when we get the touchend
                        // so we should ensure that we don't keep pretending that they are
                        trackingData.over = false;
                    }
                }
            } else if (trackingData) {
                this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);
                if (isTouch) this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent);
            }
            // Only remove the tracking data if there is no over/down state still associated with it
            if (trackingData && trackingData.none) {
                delete displayObject.trackedPointers[id];
            }
        };
    
        /**
         * Is called when the pointer moves across the renderer element
         *
         * @private
         * @param {PointerEvent} originalEvent - The DOM event of a pointer moving
         */
    
    
        InteractionManager.prototype.onPointerMove = function onPointerMove(originalEvent) {
            // if we support touch events, then only use those for touch events, not pointer events
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
    
            var events = this.normalizeToPointerData(originalEvent);
    
            if (events[0].pointerType === 'mouse') {
                this.didMove = true;
    
                this.cursor = null;
            }
    
            var eventLen = events.length;
    
            for (var i = 0; i < eventLen; i++) {
                var event = events[i];
    
                var interactionData = this.getInteractionDataForPointerId(event);
    
                var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    
                interactionEvent.data.originalEvent = originalEvent;
    
                var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
    
                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive);
                this.emit('pointermove', interactionEvent);
                if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);
                if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);
            }
    
            if (events[0].pointerType === 'mouse') {
                this.setCursorMode(this.cursor);
    
                // TODO BUG for parents interactive object (border order issue)
            }
        };
    
        /**
         * Processes the result of the pointer move check and dispatches the event if need be
         *
         * @private
         * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
         * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
         * @param {boolean} hit - the result of the hit test on the display object
         */
    
    
        InteractionManager.prototype.processPointerMove = function processPointerMove(interactionEvent, displayObject, hit) {
            var data = interactionEvent.data;
    
            var isTouch = data.pointerType === 'touch';
    
            var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';
    
            if (isMouse) {
                this.processPointerOverOut(interactionEvent, displayObject, hit);
            }
    
            if (!this.moveWhenInside || hit) {
                this.dispatchEvent(displayObject, 'pointermove', interactionEvent);
                if (isTouch) this.dispatchEvent(displayObject, 'touchmove', interactionEvent);
                if (isMouse) this.dispatchEvent(displayObject, 'mousemove', interactionEvent);
            }
        };
    
        /**
         * Is called when the pointer is moved out of the renderer element
         *
         * @private
         * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out
         */
    
    
        InteractionManager.prototype.onPointerOut = function onPointerOut(originalEvent) {
            // if we support touch events, then only use those for touch events, not pointer events
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;
    
            var events = this.normalizeToPointerData(originalEvent);
    
            // Only mouse and pointer can call onPointerOut, so events will always be length 1
            var event = events[0];
    
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = false;
                this.setCursorMode(null);
            }
    
            var interactionData = this.getInteractionDataForPointerId(event);
    
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    
            interactionEvent.data.originalEvent = event;
    
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);
    
            this.emit('pointerout', interactionEvent);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                this.emit('mouseout', interactionEvent);
            } else {
                // we can get touchleave events after touchend, so we want to make sure we don't
                // introduce memory leaks
                this.releaseInteractionDataForPointerId(interactionData.identifier);
            }
        };
    
        /**
         * Processes the result of the pointer over/out check and dispatches the event if need be
         *
         * @private
         * @param {PIXI.interaction.InteractionEvent} interactionEvent - The interaction event wrapping the DOM event
         * @param {PIXI.Container|PIXI.Sprite|PIXI.extras.TilingSprite} displayObject - The display object that was tested
         * @param {boolean} hit - the result of the hit test on the display object
         */
    
    
        InteractionManager.prototype.processPointerOverOut = function processPointerOverOut(interactionEvent, displayObject, hit) {
            var data = interactionEvent.data;
    
            var id = interactionEvent.data.identifier;
    
            var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';
    
            var trackingData = displayObject.trackedPointers[id];
    
            // if we just moused over the display object, then we need to track that state
            if (hit && !trackingData) {
                trackingData = displayObject.trackedPointers[id] = new _InteractionTrackingData2.default(id);
            }
    
            if (trackingData === undefined) return;
    
            if (hit && this.mouseOverRenderer) {
                if (!trackingData.over) {
                    trackingData.over = true;
                    this.dispatchEvent(displayObject, 'pointerover', interactionEvent);
                    if (isMouse) {
                        this.dispatchEvent(displayObject, 'mouseover', interactionEvent);
                    }
                }
    
                // only change the cursor if it has not already been changed (by something deeper in the
                // display tree)
                if (isMouse && this.cursor === null) {
                    this.cursor = displayObject.cursor;
                }
            } else if (trackingData.over) {
                trackingData.over = false;
                this.dispatchEvent(displayObject, 'pointerout', this.eventData);
                if (isMouse) {
                    this.dispatchEvent(displayObject, 'mouseout', interactionEvent);
                }
                // if there is no mouse down information for the pointer, then it is safe to delete
                if (trackingData.none) {
                    delete displayObject.trackedPointers[id];
                }
            }
        };
    
        /**
         * Is called when the pointer is moved into the renderer element
         *
         * @private
         * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view
         */
    
    
        InteractionManager.prototype.onPointerOver = function onPointerOver(originalEvent) {
            var events = this.normalizeToPointerData(originalEvent);
    
            // Only mouse and pointer can call onPointerOver, so events will always be length 1
            var event = events[0];
    
            var interactionData = this.getInteractionDataForPointerId(event);
    
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    
            interactionEvent.data.originalEvent = event;
    
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = true;
            }
    
            this.emit('pointerover', interactionEvent);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                this.emit('mouseover', interactionEvent);
            }
        };
    
        /**
         * Get InteractionData for a given pointerId. Store that data as well
         *
         * @private
         * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData
         * @return {PIXI.interaction.InteractionData} - Interaction data for the given pointer identifier
         */
    
    
        InteractionManager.prototype.getInteractionDataForPointerId = function getInteractionDataForPointerId(event) {
            var pointerId = event.pointerId;
    
            var interactionData = void 0;
    
            if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {
                interactionData = this.mouse;
            } else if (this.activeInteractionData[pointerId]) {
                interactionData = this.activeInteractionData[pointerId];
            } else {
                interactionData = this.interactionDataPool.pop() || new _InteractionData2.default();
                interactionData.identifier = pointerId;
                this.activeInteractionData[pointerId] = interactionData;
            }
            // copy properties from the event, so that we can make sure that touch/pointer specific
            // data is available
            interactionData._copyEvent(event);
    
            return interactionData;
        };
    
        /**
         * Return unused InteractionData to the pool, for a given pointerId
         *
         * @private
         * @param {number} pointerId - Identifier from a pointer event
         */
    
    
        InteractionManager.prototype.releaseInteractionDataForPointerId = function releaseInteractionDataForPointerId(pointerId) {
            var interactionData = this.activeInteractionData[pointerId];
    
            if (interactionData) {
                delete this.activeInteractionData[pointerId];
                interactionData._reset();
                this.interactionDataPool.push(interactionData);
            }
        };
    
        /**
         * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData
         *
         * @private
         * @param {PIXI.interaction.InteractionEvent} interactionEvent - The event to be configured
         * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent
         * @param {PIXI.interaction.InteractionData} interactionData - The InteractionData that will be paired
         *        with the InteractionEvent
         * @return {PIXI.interaction.InteractionEvent} the interaction event that was passed in
         */
    
    
        InteractionManager.prototype.configureInteractionEventForDOMEvent = function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
            interactionEvent.data = interactionData;
    
            this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
    
            // This is the way InteractionManager processed touch events before the refactoring, so I've kept
            // it here. But it doesn't make that much sense to me, since mapPositionToPoint already factors
            // in this.resolution, so this just divides by this.resolution twice for touch events...
            if (navigator.isCocoonJS && pointerEvent.pointerType === 'touch') {
                interactionData.global.x = interactionData.global.x / this.resolution;
                interactionData.global.y = interactionData.global.y / this.resolution;
            }
    
            // Not really sure why this is happening, but it's how a previous version handled things
            if (pointerEvent.pointerType === 'touch') {
                pointerEvent.globalX = interactionData.global.x;
                pointerEvent.globalY = interactionData.global.y;
            }
    
            interactionData.originalEvent = pointerEvent;
            interactionEvent._reset();
    
            return interactionEvent;
        };
    
        /**
         * Ensures that the original event object contains all data that a regular pointer event would have
         *
         * @private
         * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event
         * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer
         *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
         */
    
    
        InteractionManager.prototype.normalizeToPointerData = function normalizeToPointerData(event) {
            var normalizedEvents = [];
    
            if (this.supportsTouchEvents && event instanceof TouchEvent) {
                for (var i = 0, li = event.changedTouches.length; i < li; i++) {
                    var touch = event.changedTouches[i];
    
                    if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;
                    if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;
                    if (typeof touch.isPrimary === 'undefined') {
                        touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                    }
                    if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;
                    if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;
                    if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;
                    if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;
                    if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';
                    if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;
                    if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;
                    touch.twist = 0;
                    touch.tangentialPressure = 0;
                    // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven
                    // support, and the fill ins are not quite the same
                    // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top
                    // left is not 0,0 on the page
                    if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;
                    if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;
    
                    // mark the touch as normalized, just so that we know we did it
                    touch.isNormalized = true;
    
                    normalizedEvents.push(touch);
                }
            }
            // apparently PointerEvent subclasses MouseEvent, so yay
            else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
                    if (typeof event.isPrimary === 'undefined') event.isPrimary = true;
                    if (typeof event.width === 'undefined') event.width = 1;
                    if (typeof event.height === 'undefined') event.height = 1;
                    if (typeof event.tiltX === 'undefined') event.tiltX = 0;
                    if (typeof event.tiltY === 'undefined') event.tiltY = 0;
                    if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';
                    if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;
                    if (typeof event.pressure === 'undefined') event.pressure = 0.5;
                    event.twist = 0;
                    event.tangentialPressure = 0;
    
                    // mark the mouse event as normalized, just so that we know we did it
                    event.isNormalized = true;
    
                    normalizedEvents.push(event);
                } else {
                    normalizedEvents.push(event);
                }
    
            return normalizedEvents;
        };
    
        /**
         * Destroys the interaction manager
         *
         */
    
    
        InteractionManager.prototype.destroy = function destroy() {
            this.removeEvents();
    
            this.removeAllListeners();
    
            this.renderer = null;
    
            this.mouse = null;
    
            this.eventData = null;
    
            this.interactionDOMElement = null;
    
            this.onPointerDown = null;
            this.processPointerDown = null;
    
            this.onPointerUp = null;
            this.processPointerUp = null;
    
            this.onPointerCancel = null;
            this.processPointerCancel = null;
    
            this.onPointerMove = null;
            this.processPointerMove = null;
    
            this.onPointerOut = null;
            this.processPointerOverOut = null;
    
            this.onPointerOver = null;
    
            this._tempPoint = null;
        };
    
        return InteractionManager;
    }(_eventemitter2.default);
    
    exports.default = InteractionManager;
    
    
    core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
    core.CanvasRenderer.registerPlugin('interaction', InteractionManager);
    
    /***/ }),
    /* 147 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Event class that mimics native DOM events.
     *
     * @class
     * @memberof PIXI.interaction
     */
    var InteractionEvent = function () {
      /**
       *
       */
      function InteractionEvent() {
        _classCallCheck(this, InteractionEvent);
    
        /**
         * Whether this event will continue propagating in the tree
         *
         * @member {boolean}
         */
        this.stopped = false;
    
        /**
         * The object which caused this event to be dispatched.
         * For listener callback see {@link PIXI.interaction.InteractionEvent.currentTarget}.
         *
         * @member {PIXI.DisplayObject}
         */
        this.target = null;
    
        /**
         * The object whose event listener’s callback is currently being invoked.
         *
         * @member {PIXI.DisplayObject}
         */
        this.currentTarget = null;
    
        /**
         * Type of the event
         *
         * @member {string}
         */
        this.type = null;
    
        /**
         * InteractionData related to this event
         *
         * @member {PIXI.interaction.InteractionData}
         */
        this.data = null;
      }
    
      /**
       * Prevents event from reaching any objects other than the current object.
       *
       */
    
    
      InteractionEvent.prototype.stopPropagation = function stopPropagation() {
        this.stopped = true;
      };
    
      /**
       * Resets the event.
       *
       * @private
       */
    
    
      InteractionEvent.prototype._reset = function _reset() {
        this.stopped = false;
        this.currentTarget = null;
        this.target = null;
      };
    
      return InteractionEvent;
    }();
    
    exports.default = InteractionEvent;
    
    /***/ }),
    /* 148 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * DisplayObjects with the {@link PIXI.interaction.interactiveTarget} mixin use this class to track interactions
     *
     * @class
     * @private
     * @memberof PIXI.interaction
     */
    var InteractionTrackingData = function () {
        /**
         * @param {number} pointerId - Unique pointer id of the event
         */
        function InteractionTrackingData(pointerId) {
            _classCallCheck(this, InteractionTrackingData);
    
            this._pointerId = pointerId;
            this._flags = InteractionTrackingData.FLAGS.NONE;
        }
    
        /**
         *
         * @private
         * @param {number} flag - The interaction flag to set
         * @param {boolean} yn - Should the flag be set or unset
         */
    
    
        InteractionTrackingData.prototype._doSet = function _doSet(flag, yn) {
            if (yn) {
                this._flags = this._flags | flag;
            } else {
                this._flags = this._flags & ~flag;
            }
        };
    
        /**
         * Unique pointer id of the event
         *
         * @readonly
         * @member {number}
         */
    
    
        _createClass(InteractionTrackingData, [{
            key: "pointerId",
            get: function get() {
                return this._pointerId;
            }
    
            /**
             * State of the tracking data, expressed as bit flags
             *
             * @member {number}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
    
        }, {
            key: "flags",
            get: function get() {
                return this._flags;
            }
    
            /**
             * Set the flags for the tracking data
             *
             * @param {number} flags - Flags to set
             */
            ,
            set: function set(flags) {
                this._flags = flags;
            }
    
            /**
             * Is the tracked event inactive (not over or down)?
             *
             * @member {number}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
    
        }, {
            key: "none",
            get: function get() {
                return this._flags === this.constructor.FLAGS.NONE;
            }
    
            /**
             * Is the tracked event over the DisplayObject?
             *
             * @member {boolean}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
    
        }, {
            key: "over",
            get: function get() {
                return (this._flags & this.constructor.FLAGS.OVER) !== 0;
            }
    
            /**
             * Set the over flag
             *
             * @param {boolean} yn - Is the event over?
             */
            ,
            set: function set(yn) {
                this._doSet(this.constructor.FLAGS.OVER, yn);
            }
    
            /**
             * Did the right mouse button come down in the DisplayObject?
             *
             * @member {boolean}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
    
        }, {
            key: "rightDown",
            get: function get() {
                return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;
            }
    
            /**
             * Set the right down flag
             *
             * @param {boolean} yn - Is the right mouse button down?
             */
            ,
            set: function set(yn) {
                this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);
            }
    
            /**
             * Did the left mouse button come down in the DisplayObject?
             *
             * @member {boolean}
             * @memberof PIXI.interaction.InteractionTrackingData#
             */
    
        }, {
            key: "leftDown",
            get: function get() {
                return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;
            }
    
            /**
             * Set the left down flag
             *
             * @param {boolean} yn - Is the left mouse button down?
             */
            ,
            set: function set(yn) {
                this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);
            }
        }]);
    
        return InteractionTrackingData;
    }();
    
    exports.default = InteractionTrackingData;
    
    
    InteractionTrackingData.FLAGS = Object.freeze({
        NONE: 0,
        OVER: 1 << 0,
        LEFT_DOWN: 1 << 1,
        RIGHT_DOWN: 1 << 2
    });
    
    /***/ }),
    /* 149 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _BlurFilter = __webpack_require__(150);
    
    Object.defineProperty(exports, 'BlurFilter', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_BlurFilter).default;
      }
    });
    
    var _BlurXFilter = __webpack_require__(67);
    
    Object.defineProperty(exports, 'BlurXFilter', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_BlurXFilter).default;
      }
    });
    
    var _BlurYFilter = __webpack_require__(71);
    
    Object.defineProperty(exports, 'BlurYFilter', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_BlurYFilter).default;
      }
    });
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /***/ }),
    /* 150 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    var _BlurXFilter = __webpack_require__(67);
    
    var _BlurXFilter2 = _interopRequireDefault(_BlurXFilter);
    
    var _BlurYFilter = __webpack_require__(71);
    
    var _BlurYFilter2 = _interopRequireDefault(_BlurYFilter);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     * The BlurFilter applies a Gaussian blur to an object.
     * The strength of the blur can be set for x- and y-axis separately.
     *
     * @class
     * @extends PIXI.Filter
     * @memberof PIXI.filters
     */
    var BlurFilter = function (_core$Filter) {
        _inherits(BlurFilter, _core$Filter);
    
        /**
         * @param {number} strength - The strength of the blur filter.
         * @param {number} quality - The quality of the blur filter.
         * @param {number} resolution - The resolution of the blur filter.
         * @param {number} [kernelSize=5] - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
         */
        function BlurFilter(strength, quality, resolution, kernelSize) {
            _classCallCheck(this, BlurFilter);
    
            var _this = _possibleConstructorReturn(this, _core$Filter.call(this));
    
            _this.blurXFilter = new _BlurXFilter2.default(strength, quality, resolution, kernelSize);
            _this.blurYFilter = new _BlurYFilter2.default(strength, quality, resolution, kernelSize);
    
            _this.padding = 0;
            _this.resolution = resolution || core.settings.RESOLUTION;
            _this.quality = quality || 4;
            _this.blur = strength || 8;
            return _this;
        }
    
        /**
         * Applies the filter.
         *
         * @param {PIXI.FilterManager} filterManager - The manager.
         * @param {PIXI.RenderTarget} input - The input target.
         * @param {PIXI.RenderTarget} output - The output target.
         */
    
    
        BlurFilter.prototype.apply = function apply(filterManager, input, output) {
            var renderTarget = filterManager.getRenderTarget(true);
    
            this.blurXFilter.apply(filterManager, input, renderTarget, true);
            this.blurYFilter.apply(filterManager, renderTarget, output, false);
    
            filterManager.returnRenderTarget(renderTarget);
        };
    
        /**
         * Sets the strength of both the blurX and blurY properties simultaneously
         *
         * @member {number}
         * @default 2
         */
    
    
        _createClass(BlurFilter, [{
            key: 'blur',
            get: function get() {
                return this.blurXFilter.blur;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.blurXFilter.blur = this.blurYFilter.blur = value;
                this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
            }
    
            /**
             * Sets the number of passes for blur. More passes means higher quaility bluring.
             *
             * @member {number}
             * @default 1
             */
    
        }, {
            key: 'quality',
            get: function get() {
                return this.blurXFilter.quality;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.blurXFilter.quality = this.blurYFilter.quality = value;
            }
    
            /**
             * Sets the strength of the blurX property
             *
             * @member {number}
             * @default 2
             */
    
        }, {
            key: 'blurX',
            get: function get() {
                return this.blurXFilter.blur;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.blurXFilter.blur = value;
                this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
            }
    
            /**
             * Sets the strength of the blurY property
             *
             * @member {number}
             * @default 2
             */
    
        }, {
            key: 'blurY',
            get: function get() {
                return this.blurYFilter.blur;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this.blurYFilter.blur = value;
                this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
            }
        }]);
    
        return BlurFilter;
    }(core.Filter);
    
    exports.default = BlurFilter;
    
    /***/ }),
    /* 151 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.shared = exports.Resource = exports.textureParser = exports.getResourcePath = exports.spritesheetParser = exports.Loader = undefined;
    
    var _spritesheetParser = __webpack_require__(72);
    
    Object.defineProperty(exports, 'spritesheetParser', {
        enumerable: true,
        get: function get() {
            return _interopRequireDefault(_spritesheetParser).default;
        }
    });
    Object.defineProperty(exports, 'getResourcePath', {
        enumerable: true,
        get: function get() {
            return _spritesheetParser.getResourcePath;
        }
    });
    
    var _textureParser = __webpack_require__(77);
    
    Object.defineProperty(exports, 'textureParser', {
        enumerable: true,
        get: function get() {
            return _interopRequireDefault(_textureParser).default;
        }
    });
    
    var _resourceLoader = __webpack_require__(18);
    
    Object.defineProperty(exports, 'Resource', {
        enumerable: true,
        get: function get() {
            return _resourceLoader.Resource;
        }
    });
    
    var _Application = __webpack_require__(63);
    
    var _Application2 = _interopRequireDefault(_Application);
    
    var _loader = __webpack_require__(153);
    
    var _loader2 = _interopRequireDefault(_loader);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /**
     * This namespace contains APIs which extends the {@link https://github.com/englercj/resource-loader resource-loader} module
     * for loading assets, data, and other resources dynamically.
     * @example
     * const loader = new PIXI.loaders.Loader();
     * loader.add('bunny', 'data/bunny.png')
     *       .add('spaceship', 'assets/spritesheet.json');
     * loader.load((loader, resources) => {
     *    // resources.bunny
     *    // resources.spaceship
     * });
     * @namespace PIXI.loaders
     */
    exports.Loader = _loader2.default;
    
    
    /**
     * A premade instance of the loader that can be used to load resources.
     * @name shared
     * @memberof PIXI.loaders
     * @type {PIXI.loaders.Loader}
     */
    var shared = new _loader2.default();
    
    shared.destroy = function () {
        // protect destroying shared loader
    };
    
    exports.shared = shared;
    
    // Mixin the loader construction
    
    var AppPrototype = _Application2.default.prototype;
    
    AppPrototype._loader = null;
    
    /**
     * Loader instance to help with asset loading.
     * @name PIXI.Application#loader
     * @type {PIXI.loaders.Loader}
     */
    Object.defineProperty(AppPrototype, 'loader', {
        get: function get() {
            if (!this._loader) {
                var sharedLoader = this._options.sharedLoader;
    
                this._loader = sharedLoader ? shared : new _loader2.default();
            }
    
            return this._loader;
        }
    });
    
    // Override the destroy function
    // making sure to destroy the current Loader
    AppPrototype._parentDestroy = AppPrototype.destroy;
    AppPrototype.destroy = function destroy() {
        if (this._loader) {
            this._loader.destroy();
            this._loader = null;
        }
        this._parentDestroy();
    };
    
    /***/ }),
    /* 152 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    var _miniSignals = __webpack_require__(73);
    
    var _miniSignals2 = _interopRequireDefault(_miniSignals);
    
    var _parseUri = __webpack_require__(74);
    
    var _parseUri2 = _interopRequireDefault(_parseUri);
    
    var _async = __webpack_require__(75);
    
    var async = _interopRequireWildcard(_async);
    
    var _Resource = __webpack_require__(31);
    
    var _Resource2 = _interopRequireDefault(_Resource);
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    // some constants
    var MAX_PROGRESS = 100;
    var rgxExtractUrlHash = /(#[\w-]+)?$/;
    
    /**
     * Manages the state and loading of multiple resources to load.
     *
     * @class
     */
    
    var Loader = function () {
        /**
         * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
         * @param {number} [concurrency=10] - The number of resources to load concurrently.
         */
        function Loader() {
            var _this = this;
    
            var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            var concurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    
            _classCallCheck(this, Loader);
    
            /**
             * The base url for all resources loaded by this loader.
             *
             * @member {string}
             */
            this.baseUrl = baseUrl;
    
            /**
             * The progress percent of the loader going through the queue.
             *
             * @member {number}
             */
            this.progress = 0;
    
            /**
             * Loading state of the loader, true if it is currently loading resources.
             *
             * @member {boolean}
             */
            this.loading = false;
    
            /**
             * A querystring to append to every URL added to the loader.
             *
             * This should be a valid query string *without* the question-mark (`?`). The loader will
             * also *not* escape values for you. Make sure to escape your parameters with
             * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.
             *
             * @example
             * const loader = new Loader();
             *
             * loader.defaultQueryString = 'user=me&password=secret';
             *
             * // This will request 'image.png?user=me&password=secret'
             * loader.add('image.png').load();
             *
             * loader.reset();
             *
             * // This will request 'image.png?v=1&user=me&password=secret'
             * loader.add('iamge.png?v=1').load();
             */
            this.defaultQueryString = '';
    
            /**
             * The middleware to run before loading each resource.
             *
             * @member {function[]}
             */
            this._beforeMiddleware = [];
    
            /**
             * The middleware to run after loading each resource.
             *
             * @member {function[]}
             */
            this._afterMiddleware = [];
    
            /**
             * The tracks the resources we are currently completing parsing for.
             *
             * @member {Resource[]}
             */
            this._resourcesParsing = [];
    
            /**
             * The `_loadResource` function bound with this object context.
             *
             * @private
             * @member {function}
             * @param {Resource} r - The resource to load
             * @param {Function} d - The dequeue function
             * @return {undefined}
             */
            this._boundLoadResource = function (r, d) {
                return _this._loadResource(r, d);
            };
    
            /**
             * The resources waiting to be loaded.
             *
             * @private
             * @member {Resource[]}
             */
            this._queue = async.queue(this._boundLoadResource, concurrency);
    
            this._queue.pause();
    
            /**
             * All the resources for this loader keyed by name.
             *
             * @member {object<string, Resource>}
             */
            this.resources = {};
    
            /**
             * Dispatched once per loaded or errored resource.
             *
             * The callback looks like {@link Loader.OnProgressSignal}.
             *
             * @member {Signal}
             */
            this.onProgress = new _miniSignals2.default();
    
            /**
             * Dispatched once per errored resource.
             *
             * The callback looks like {@link Loader.OnErrorSignal}.
             *
             * @member {Signal}
             */
            this.onError = new _miniSignals2.default();
    
            /**
             * Dispatched once per loaded resource.
             *
             * The callback looks like {@link Loader.OnLoadSignal}.
             *
             * @member {Signal}
             */
            this.onLoad = new _miniSignals2.default();
    
            /**
             * Dispatched when the loader begins to process the queue.
             *
             * The callback looks like {@link Loader.OnStartSignal}.
             *
             * @member {Signal}
             */
            this.onStart = new _miniSignals2.default();
    
            /**
             * Dispatched when the queued resources all load.
             *
             * The callback looks like {@link Loader.OnCompleteSignal}.
             *
             * @member {Signal}
             */
            this.onComplete = new _miniSignals2.default();
    
            /**
             * When the progress changes the loader and resource are disaptched.
             *
             * @memberof Loader
             * @callback OnProgressSignal
             * @param {Loader} loader - The loader the progress is advancing on.
             * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.
             */
    
            /**
             * When an error occurrs the loader and resource are disaptched.
             *
             * @memberof Loader
             * @callback OnErrorSignal
             * @param {Loader} loader - The loader the error happened in.
             * @param {Resource} resource - The resource that caused the error.
             */
    
            /**
             * When a load completes the loader and resource are disaptched.
             *
             * @memberof Loader
             * @callback OnLoadSignal
             * @param {Loader} loader - The loader that laoded the resource.
             * @param {Resource} resource - The resource that has completed loading.
             */
    
            /**
             * When the loader starts loading resources it dispatches this callback.
             *
             * @memberof Loader
             * @callback OnStartSignal
             * @param {Loader} loader - The loader that has started loading resources.
             */
    
            /**
             * When the loader completes loading resources it dispatches this callback.
             *
             * @memberof Loader
             * @callback OnCompleteSignal
             * @param {Loader} loader - The loader that has finished loading resources.
             */
        }
    
        /**
         * Adds a resource (or multiple resources) to the loader queue.
         *
         * This function can take a wide variety of different parameters. The only thing that is always
         * required the url to load. All the following will work:
         *
         * ```js
         * loader
         *     // normal param syntax
         *     .add('key', 'http://...', function () {})
         *     .add('http://...', function () {})
         *     .add('http://...')
         *
         *     // object syntax
         *     .add({
         *         name: 'key2',
         *         url: 'http://...'
         *     }, function () {})
         *     .add({
         *         url: 'http://...'
         *     }, function () {})
         *     .add({
         *         name: 'key3',
         *         url: 'http://...'
         *         onComplete: function () {}
         *     })
         *     .add({
         *         url: 'https://...',
         *         onComplete: function () {},
         *         crossOrigin: true
         *     })
         *
         *     // you can also pass an array of objects or urls or both
         *     .add([
         *         { name: 'key4', url: 'http://...', onComplete: function () {} },
         *         { url: 'http://...', onComplete: function () {} },
         *         'http://...'
         *     ])
         *
         *     // and you can use both params and options
         *     .add('key', 'http://...', { crossOrigin: true }, function () {})
         *     .add('http://...', { crossOrigin: true }, function () {});
         * ```
         *
         * @param {string} [name] - The name of the resource to load, if not passed the url is used.
         * @param {string} [url] - The url for this resource, relative to the baseUrl of this loader.
         * @param {object} [options] - The options for the load.
         * @param {boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.
         * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?
         * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should
         *      the data being loaded be interpreted when using XHR?
         * @param {object} [options.metadata] - Extra configuration for middleware and the Resource object.
         * @param {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [options.metadata.loadElement=null] - The
         *      element to use for loading, instead of creating one.
         * @param {boolean} [options.metadata.skipSource=false] - Skips adding source(s) to the load element. This
         *      is useful if you want to pass in a `loadElement` that you already added load sources to.
         * @param {function} [cb] - Function to call when this specific resource completes loading.
         * @return {Loader} Returns itself.
         */
    
    
        Loader.prototype.add = function add(name, url, options, cb) {
            // special case of an array of objects or urls
            if (Array.isArray(name)) {
                for (var i = 0; i < name.length; ++i) {
                    this.add(name[i]);
                }
    
                return this;
            }
    
            // if an object is passed instead of params
            if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
                cb = url || name.callback || name.onComplete;
                options = name;
                url = name.url;
                name = name.name || name.key || name.url;
            }
    
            // case where no name is passed shift all args over by one.
            if (typeof url !== 'string') {
                cb = options;
                options = url;
                url = name;
            }
    
            // now that we shifted make sure we have a proper url.
            if (typeof url !== 'string') {
                throw new Error('No url passed to add resource to loader.');
            }
    
            // options are optional so people might pass a function and no options
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }
    
            // if loading already you can only add resources that have a parent.
            if (this.loading && (!options || !options.parentResource)) {
                throw new Error('Cannot add resources while the loader is running.');
            }
    
            // check if resource already exists.
            if (this.resources[name]) {
                throw new Error('Resource named "' + name + '" already exists.');
            }
    
            // add base url if this isn't an absolute url
            url = this._prepareUrl(url);
    
            // create the store the resource
            this.resources[name] = new _Resource2.default(name, url, options);
    
            if (typeof cb === 'function') {
                this.resources[name].onAfterMiddleware.once(cb);
            }
    
            // if actively loading, make sure to adjust progress chunks for that parent and its children
            if (this.loading) {
                var parent = options.parentResource;
                var incompleteChildren = [];
    
                for (var _i = 0; _i < parent.children.length; ++_i) {
                    if (!parent.children[_i].isComplete) {
                        incompleteChildren.push(parent.children[_i]);
                    }
                }
    
                var fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent
                var eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child
    
                parent.children.push(this.resources[name]);
                parent.progressChunk = eachChunk;
    
                for (var _i2 = 0; _i2 < incompleteChildren.length; ++_i2) {
                    incompleteChildren[_i2].progressChunk = eachChunk;
                }
    
                this.resources[name].progressChunk = eachChunk;
            }
    
            // add the resource to the queue
            this._queue.push(this.resources[name]);
    
            return this;
        };
    
        /**
         * Sets up a middleware function that will run *before* the
         * resource is loaded.
         *
         * @method before
         * @param {function} fn - The middleware function to register.
         * @return {Loader} Returns itself.
         */
    
    
        Loader.prototype.pre = function pre(fn) {
            this._beforeMiddleware.push(fn);
    
            return this;
        };
    
        /**
         * Sets up a middleware function that will run *after* the
         * resource is loaded.
         *
         * @alias use
         * @method after
         * @param {function} fn - The middleware function to register.
         * @return {Loader} Returns itself.
         */
    
    
        Loader.prototype.use = function use(fn) {
            this._afterMiddleware.push(fn);
    
            return this;
        };
    
        /**
         * Resets the queue of the loader to prepare for a new load.
         *
         * @return {Loader} Returns itself.
         */
    
    
        Loader.prototype.reset = function reset() {
            this.progress = 0;
            this.loading = false;
    
            this._queue.kill();
            this._queue.pause();
    
            // abort all resource loads
            for (var k in this.resources) {
                var res = this.resources[k];
    
                if (res._onLoadBinding) {
                    res._onLoadBinding.detach();
                }
    
                if (res.isLoading) {
                    res.abort();
                }
            }
    
            this.resources = {};
    
            return this;
        };
    
        /**
         * Starts loading the queued resources.
         *
         * @param {function} [cb] - Optional callback that will be bound to the `complete` event.
         * @return {Loader} Returns itself.
         */
    
    
        Loader.prototype.load = function load(cb) {
            // register complete callback if they pass one
            if (typeof cb === 'function') {
                this.onComplete.once(cb);
            }
    
            // if the queue has already started we are done here
            if (this.loading) {
                return this;
            }
    
            // distribute progress chunks
            var chunk = 100 / this._queue._tasks.length;
    
            for (var i = 0; i < this._queue._tasks.length; ++i) {
                this._queue._tasks[i].data.progressChunk = chunk;
            }
    
            // update loading state
            this.loading = true;
    
            // notify of start
            this.onStart.dispatch(this);
    
            // start loading
            this._queue.resume();
    
            return this;
        };
    
        /**
         * Prepares a url for usage based on the configuration of this object
         *
         * @private
         * @param {string} url - The url to prepare.
         * @return {string} The prepared url.
         */
    
    
        Loader.prototype._prepareUrl = function _prepareUrl(url) {
            var parsedUrl = (0, _parseUri2.default)(url, { strictMode: true });
            var result = void 0;
    
            // absolute url, just use it as is.
            if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {
                result = url;
            }
            // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween
            else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {
                    result = this.baseUrl + '/' + url;
                } else {
                    result = this.baseUrl + url;
                }
    
            // if we need to add a default querystring, there is a bit more work
            if (this.defaultQueryString) {
                var hash = rgxExtractUrlHash.exec(result)[0];
    
                result = result.substr(0, result.length - hash.length);
    
                if (result.indexOf('?') !== -1) {
                    result += '&' + this.defaultQueryString;
                } else {
                    result += '?' + this.defaultQueryString;
                }
    
                result += hash;
            }
    
            return result;
        };
    
        /**
         * Loads a single resource.
         *
         * @private
         * @param {Resource} resource - The resource to load.
         * @param {function} dequeue - The function to call when we need to dequeue this item.
         */
    
    
        Loader.prototype._loadResource = function _loadResource(resource, dequeue) {
            var _this2 = this;
    
            resource._dequeue = dequeue;
    
            // run before middleware
            async.eachSeries(this._beforeMiddleware, function (fn, next) {
                fn.call(_this2, resource, function () {
                    // if the before middleware marks the resource as complete,
                    // break and don't process any more before middleware
                    next(resource.isComplete ? {} : null);
                });
            }, function () {
                if (resource.isComplete) {
                    _this2._onLoad(resource);
                } else {
                    resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
                    resource.load();
                }
            }, true);
        };
    
        /**
         * Called once each resource has loaded.
         *
         * @private
         */
    
    
        Loader.prototype._onComplete = function _onComplete() {
            this.loading = false;
    
            this.onComplete.dispatch(this, this.resources);
        };
    
        /**
         * Called each time a resources is loaded.
         *
         * @private
         * @param {Resource} resource - The resource that was loaded
         */
    
    
        Loader.prototype._onLoad = function _onLoad(resource) {
            var _this3 = this;
    
            resource._onLoadBinding = null;
    
            // remove this resource from the async queue, and add it to our list of resources that are being parsed
            this._resourcesParsing.push(resource);
            resource._dequeue();
    
            // run all the after middleware for this resource
            async.eachSeries(this._afterMiddleware, function (fn, next) {
                fn.call(_this3, resource, next);
            }, function () {
                resource.onAfterMiddleware.dispatch(resource);
    
                _this3.progress += resource.progressChunk;
                _this3.onProgress.dispatch(_this3, resource);
    
                if (resource.error) {
                    _this3.onError.dispatch(resource.error, _this3, resource);
                } else {
                    _this3.onLoad.dispatch(_this3, resource);
                }
    
                _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);
    
                // do completion check
                if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {
                    _this3.progress = MAX_PROGRESS;
                    _this3._onComplete();
                }
            }, true);
        };
    
        return Loader;
    }();
    
    exports.default = Loader;
    //# sourceMappingURL=Loader.js.map
    
    /***/ }),
    /* 153 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _resourceLoader = __webpack_require__(18);
    
    var _resourceLoader2 = _interopRequireDefault(_resourceLoader);
    
    var _blob = __webpack_require__(154);
    
    var _eventemitter = __webpack_require__(6);
    
    var _eventemitter2 = _interopRequireDefault(_eventemitter);
    
    var _textureParser = __webpack_require__(77);
    
    var _textureParser2 = _interopRequireDefault(_textureParser);
    
    var _spritesheetParser = __webpack_require__(72);
    
    var _spritesheetParser2 = _interopRequireDefault(_spritesheetParser);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    /**
     *
     * The new loader, extends Resource Loader by Chad Engler: https://github.com/englercj/resource-loader
     *
     * ```js
     * const loader = PIXI.loader; // pixi exposes a premade instance for you to use.
     * //or
     * const loader = new PIXI.loaders.Loader(); // you can also create your own if you want
     *
     * const sprites = {};
     *
     * // Chainable `add` to enqueue a resource
     * loader.add('bunny', 'data/bunny.png')
     *       .add('spaceship', 'assets/spritesheet.json');
     * loader.add('scoreFont', 'assets/score.fnt');
     *
     * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.
     * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).
     * loader.pre(cachingMiddleware);
     *
     * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.
     * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).
     * loader.use(parsingMiddleware);
     *
     * // The `load` method loads the queue of resources, and calls the passed in callback called once all
     * // resources have loaded.
     * loader.load((loader, resources) => {
     *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.
     *     // They have a couple default properties:
     *     // - `url`: The URL that the resource was loaded from
     *     // - `error`: The error that happened when trying to load (if any)
     *     // - `data`: The raw data that was loaded
     *     // also may contain other properties based on the middleware that runs.
     *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);
     *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);
     *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);
     * });
     *
     * // throughout the process multiple signals can be dispatched.
     * loader.onProgress.add(() => {}); // called once per loaded/errored file
     * loader.onError.add(() => {}); // called once per errored file
     * loader.onLoad.add(() => {}); // called once per loaded file
     * loader.onComplete.add(() => {}); // called once when the queued resources all load.
     * ```
     *
     * @see https://github.com/englercj/resource-loader
     *
     * @class
     * @extends module:resource-loader.ResourceLoader
     * @memberof PIXI.loaders
     */
    var Loader = function (_ResourceLoader) {
        _inherits(Loader, _ResourceLoader);
    
        /**
         * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.
         * @param {number} [concurrency=10] - The number of resources to load concurrently.
         */
        function Loader(baseUrl, concurrency) {
            _classCallCheck(this, Loader);
    
            var _this = _possibleConstructorReturn(this, _ResourceLoader.call(this, baseUrl, concurrency));
    
            _eventemitter2.default.call(_this);
    
            for (var i = 0; i < Loader._pixiMiddleware.length; ++i) {
                _this.use(Loader._pixiMiddleware[i]());
            }
    
            // Compat layer, translate the new v2 signals into old v1 events.
            _this.onStart.add(function (l) {
                return _this.emit('start', l);
            });
            _this.onProgress.add(function (l, r) {
                return _this.emit('progress', l, r);
            });
            _this.onError.add(function (e, l, r) {
                return _this.emit('error', e, l, r);
            });
            _this.onLoad.add(function (l, r) {
                return _this.emit('load', l, r);
            });
            _this.onComplete.add(function (l, r) {
                return _this.emit('complete', l, r);
            });
            return _this;
        }
    
        /**
         * Adds a default middleware to the pixi loader.
         *
         * @static
         * @param {Function} fn - The middleware to add.
         */
    
    
        Loader.addPixiMiddleware = function addPixiMiddleware(fn) {
            Loader._pixiMiddleware.push(fn);
        };
    
        /**
         * Destroy the loader, removes references.
         */
    
    
        Loader.prototype.destroy = function destroy() {
            this.removeAllListeners();
            this.reset();
        };
    
        return Loader;
    }(_resourceLoader2.default);
    
    // Copy EE3 prototype (mixin)
    
    
    exports.default = Loader;
    for (var k in _eventemitter2.default.prototype) {
        Loader.prototype[k] = _eventemitter2.default.prototype[k];
    }
    
    Loader._pixiMiddleware = [
    // parse any blob into more usable objects (e.g. Image)
    _blob.blobMiddlewareFactory,
    // parse any Image objects into textures
    _textureParser2.default,
    // parse any spritesheet data into multiple textures
    _spritesheetParser2.default];
    
    // Add custom extentions
    var Resource = _resourceLoader2.default.Resource;
    
    Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);
    
    /***/ }),
    /* 154 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    exports.blobMiddlewareFactory = blobMiddlewareFactory;
    
    var _Resource = __webpack_require__(31);
    
    var _Resource2 = _interopRequireDefault(_Resource);
    
    var _b = __webpack_require__(76);
    
    var _b2 = _interopRequireDefault(_b);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var Url = window.URL || window.webkitURL;
    
    // a middleware for transforming XHR loaded Blobs into more useful objects
    function blobMiddlewareFactory() {
        return function blobMiddleware(resource, next) {
            if (!resource.data) {
                next();
    
                return;
            }
    
            // if this was an XHR load of a blob
            if (resource.xhr && resource.xhrType === _Resource2.default.XHR_RESPONSE_TYPE.BLOB) {
                // if there is no blob support we probably got a binary string back
                if (!window.Blob || typeof resource.data === 'string') {
                    var type = resource.xhr.getResponseHeader('content-type');
    
                    // this is an image, convert the binary string into a data url
                    if (type && type.indexOf('image') === 0) {
                        resource.data = new Image();
                        resource.data.src = 'data:' + type + ';base64,' + _b2.default.encodeBinary(resource.xhr.responseText);
    
                        resource.type = _Resource2.default.TYPE.IMAGE;
    
                        // wait until the image loads and then callback
                        resource.data.onload = function () {
                            resource.data.onload = null;
    
                            next();
                        };
    
                        // next will be called on load
                        return;
                    }
                }
                // if content type says this is an image, then we should transform the blob into an Image object
                else if (resource.data.type.indexOf('image') === 0) {
                        var _ret = function () {
                            var src = Url.createObjectURL(resource.data);
    
                            resource.blob = resource.data;
                            resource.data = new Image();
                            resource.data.src = src;
    
                            resource.type = _Resource2.default.TYPE.IMAGE;
    
                            // cleanup the no longer used blob after the image loads
                            // TODO: Is this correct? Will the image be invalid after revoking?
                            resource.data.onload = function () {
                                Url.revokeObjectURL(src);
                                resource.data.onload = null;
    
                                next();
                            };
    
                            // next will be called on load.
                            return {
                                v: void 0
                            };
                        }();
    
                        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                    }
            }
    
            next();
        };
    }
    //# sourceMappingURL=blob.js.map
    
    /***/ }),
    /* 155 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _Mesh = __webpack_require__(32);
    
    Object.defineProperty(exports, 'Mesh', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_Mesh).default;
      }
    });
    
    var _MeshRenderer = __webpack_require__(157);
    
    Object.defineProperty(exports, 'MeshRenderer', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_MeshRenderer).default;
      }
    });
    
    var _CanvasMeshRenderer = __webpack_require__(158);
    
    Object.defineProperty(exports, 'CanvasMeshRenderer', {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_CanvasMeshRenderer).default;
      }
    });
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /***/ }),
    /* 156 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _Matrix = __webpack_require__(22);
    
    var _Matrix2 = _interopRequireDefault(_Matrix);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var tempMat = new _Matrix2.default();
    
    /**
     * class controls uv transform and frame clamp for texture
     *
     * @class
     * @memberof PIXI.extras
     */
    
    var TextureTransform = function () {
        /**
         *
         * @param {PIXI.Texture} texture observed texture
         * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
         * @constructor
         */
        function TextureTransform(texture, clampMargin) {
            _classCallCheck(this, TextureTransform);
    
            this._texture = texture;
    
            this.mapCoord = new _Matrix2.default();
    
            this.uClampFrame = new Float32Array(4);
    
            this.uClampOffset = new Float32Array(2);
    
            this._lastTextureID = -1;
    
            /**
             * Changes frame clamping
             * Works with TilingSprite and Mesh
             * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
             *
             * @default 0
             * @member {number}
             */
            this.clampOffset = 0;
    
            /**
             * Changes frame clamping
             * Works with TilingSprite and Mesh
             * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
             *
             * @default 0.5
             * @member {number}
             */
            this.clampMargin = typeof clampMargin === 'undefined' ? 0.5 : clampMargin;
        }
    
        /**
         * texture property
         * @member {PIXI.Texture}
         */
    
    
        /**
         * Multiplies uvs array to transform
         * @param {Float32Array} uvs mesh uvs
         * @param {Float32Array} [out=uvs] output
         * @returns {Float32Array} output
         */
        TextureTransform.prototype.multiplyUvs = function multiplyUvs(uvs, out) {
            if (out === undefined) {
                out = uvs;
            }
    
            var mat = this.mapCoord;
    
            for (var i = 0; i < uvs.length; i += 2) {
                var x = uvs[i];
                var y = uvs[i + 1];
    
                out[i] = x * mat.a + y * mat.c + mat.tx;
                out[i + 1] = x * mat.b + y * mat.d + mat.ty;
            }
    
            return out;
        };
    
        /**
         * updates matrices if texture was changed
         * @param {boolean} forceUpdate if true, matrices will be updated any case
         * @returns {boolean} whether or not it was updated
         */
    
    
        TextureTransform.prototype.update = function update(forceUpdate) {
            var tex = this._texture;
    
            if (!tex || !tex.valid) {
                return false;
            }
    
            if (!forceUpdate && this._lastTextureID === tex._updateID) {
                return false;
            }
    
            this._lastTextureID = tex._updateID;
    
            var uvs = tex._uvs;
    
            this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    
            var orig = tex.orig;
            var trim = tex.trim;
    
            if (trim) {
                tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
                this.mapCoord.append(tempMat);
            }
    
            var texBase = tex.baseTexture;
            var frame = this.uClampFrame;
            var margin = this.clampMargin / texBase.resolution;
            var offset = this.clampOffset;
    
            frame[0] = (tex._frame.x + margin + offset) / texBase.width;
            frame[1] = (tex._frame.y + margin + offset) / texBase.height;
            frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
            frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
            this.uClampOffset[0] = offset / texBase.realWidth;
            this.uClampOffset[1] = offset / texBase.realHeight;
    
            return true;
        };
    
        _createClass(TextureTransform, [{
            key: 'texture',
            get: function get() {
                return this._texture;
            },
            set: function set(value) // eslint-disable-line require-jsdoc
            {
                this._texture = value;
                this._lastTextureID = -1;
            }
        }]);
    
        return TextureTransform;
    }();
    
    exports.default = TextureTransform;
    
    /***/ }),
    /* 157 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    var _pixiGlCore = __webpack_require__(5);
    
    var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
    
    var _Mesh = __webpack_require__(32);
    
    var _Mesh2 = _interopRequireDefault(_Mesh);
    
    var _path = __webpack_require__(30);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var matrixIdentity = core.Matrix.IDENTITY;
    
    /**
     * WebGL renderer plugin for tiling sprites
     *
     * @class
     * @memberof PIXI
     * @extends PIXI.ObjectRenderer
     */
    
    var MeshRenderer = function (_core$ObjectRenderer) {
        _inherits(MeshRenderer, _core$ObjectRenderer);
    
        /**
         * constructor for renderer
         *
         * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.
         */
        function MeshRenderer(renderer) {
            _classCallCheck(this, MeshRenderer);
    
            var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));
    
            _this.shader = null;
            return _this;
        }
    
        /**
         * Sets up the renderer context and necessary buffers.
         *
         * @private
         */
    
    
        MeshRenderer.prototype.onContextChange = function onContextChange() {
            var gl = this.renderer.gl;
    
            this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\nuniform float alpha;\nuniform vec3 tint;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * vec4(tint * alpha, alpha);\n}\n');
        };
    
        /**
         * renders mesh
         *
         * @param {PIXI.mesh.Mesh} mesh mesh instance
         */
    
    
        MeshRenderer.prototype.render = function render(mesh) {
            var renderer = this.renderer;
            var gl = renderer.gl;
            var texture = mesh._texture;
    
            if (!texture.valid) {
                return;
            }
    
            var glData = mesh._glDatas[renderer.CONTEXT_UID];
    
            if (!glData) {
                renderer.bindVao(null);
    
                glData = {
                    shader: this.shader,
                    vertexBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),
                    uvBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),
                    indexBuffer: _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),
                    // build the vao object that will render..
                    vao: null,
                    dirty: mesh.dirty,
                    indexDirty: mesh.indexDirty
                };
    
                // build the vao object that will render..
                glData.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(glData.indexBuffer).addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0).addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);
    
                mesh._glDatas[renderer.CONTEXT_UID] = glData;
            }
    
            renderer.bindVao(glData.vao);
    
            if (mesh.dirty !== glData.dirty) {
                glData.dirty = mesh.dirty;
                glData.uvBuffer.upload(mesh.uvs);
            }
    
            if (mesh.indexDirty !== glData.indexDirty) {
                glData.indexDirty = mesh.indexDirty;
                glData.indexBuffer.upload(mesh.indices);
            }
    
            glData.vertexBuffer.upload(mesh.vertices);
    
            renderer.bindShader(glData.shader);
    
            glData.shader.uniforms.uSampler = renderer.bindTexture(texture);
    
            renderer.state.setBlendMode(mesh.blendMode);
            if (glData.shader.uniforms.uTransform) {
                if (mesh.uploadUvTransform) {
                    glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);
                } else {
                    glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);
                }
            }
            glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);
            glData.shader.uniforms.alpha = mesh.worldAlpha;
            glData.shader.uniforms.tint = mesh.tintRgb;
    
            var drawMode = mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;
    
            glData.vao.draw(drawMode, mesh.indices.length, 0);
        };
    
        return MeshRenderer;
    }(core.ObjectRenderer);
    
    exports.default = MeshRenderer;
    
    
    core.WebGLRenderer.registerPlugin('mesh', MeshRenderer);
    
    /***/ }),
    /* 158 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _core = __webpack_require__(4);
    
    var core = _interopRequireWildcard(_core);
    
    var _Mesh = __webpack_require__(32);
    
    var _Mesh2 = _interopRequireDefault(_Mesh);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Renderer dedicated to meshes.
     *
     * @class
     * @private
     * @memberof PIXI
     */
    var MeshSpriteRenderer = function () {
        /**
         * @param {PIXI.CanvasRenderer} renderer - The renderer this downport works for
         */
        function MeshSpriteRenderer(renderer) {
            _classCallCheck(this, MeshSpriteRenderer);
    
            this.renderer = renderer;
        }
    
        /**
         * Renders the Mesh
         *
         * @param {PIXI.mesh.Mesh} mesh - the Mesh to render
         */
    
    
        MeshSpriteRenderer.prototype.render = function render(mesh) {
            var renderer = this.renderer;
            var context = renderer.context;
    
            var transform = mesh.worldTransform;
            var res = renderer.resolution;
    
            if (renderer.roundPixels) {
                context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);
            } else {
                context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);
            }
    
            renderer.setBlendMode(mesh.blendMode);
    
            if (mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH) {
                this._renderTriangleMesh(mesh);
            } else {
                this._renderTriangles(mesh);
            }
        };
    
        /**
         * Draws the object in Triangle Mesh mode
         *
         * @private
         * @param {PIXI.mesh.Mesh} mesh - the Mesh to render
         */
    
    
        MeshSpriteRenderer.prototype._renderTriangleMesh = function _renderTriangleMesh(mesh) {
            // draw triangles!!
            var length = mesh.vertices.length / 2;
    
            for (var i = 0; i < length - 2; i++) {
                // draw some triangles!
                var index = i * 2;
    
                this._renderDrawTriangle(mesh, index, index + 2, index + 4);
            }
        };
    
        /**
         * Draws the object in triangle mode using canvas
         *
         * @private
         * @param {PIXI.mesh.Mesh} mesh - the current mesh
         */
    
    
        MeshSpriteRenderer.prototype._renderTriangles = function _renderTriangles(mesh) {
            // draw triangles!!
            var indices = mesh.indices;
            var length = indices.length;
    
            for (var i = 0; i < length; i += 3) {
                // draw some triangles!
                var index0 = indices[i] * 2;
                var index1 = indices[i + 1] * 2;
                var index2 = indices[i + 2] * 2;
    
                this._renderDrawTriangle(mesh, index0, index1, index2);
            }
        };
    
        /**
         * Draws one of the triangles that from the Mesh
         *
         * @private
         * @param {PIXI.mesh.Mesh} mesh - the current mesh
         * @param {number} index0 - the index of the first vertex
         * @param {number} index1 - the index of the second vertex
         * @param {number} index2 - the index of the third vertex
         */
    
    
        MeshSpriteRenderer.prototype._renderDrawTriangle = function _renderDrawTriangle(mesh, index0, index1, index2) {
            var context = this.renderer.context;
            var uvs = mesh.uvs;
            var vertices = mesh.vertices;
            var texture = mesh._texture;
    
            if (!texture.valid) {
                return;
            }
    
            var base = texture.baseTexture;
            var textureSource = base.source;
            var textureWidth = base.width;
            var textureHeight = base.height;
    
            var u0 = void 0;
            var u1 = void 0;
            var u2 = void 0;
            var v0 = void 0;
            var v1 = void 0;
            var v2 = void 0;
    
            if (mesh.uploadUvTransform) {
                var ut = mesh._uvTransform.mapCoord;
    
                u0 = (uvs[index0] * ut.a + uvs[index0 + 1] * ut.c + ut.tx) * base.width;
                u1 = (uvs[index1] * ut.a + uvs[index1 + 1] * ut.c + ut.tx) * base.width;
                u2 = (uvs[index2] * ut.a + uvs[index2 + 1] * ut.c + ut.tx) * base.width;
                v0 = (uvs[index0] * ut.b + uvs[index0 + 1] * ut.d + ut.ty) * base.height;
                v1 = (uvs[index1] * ut.b + uvs[index1 + 1] * ut.d + ut.ty) * base.height;
                v2 = (uvs[index2] * ut.b + uvs[index2 + 1] * ut.d + ut.ty) * base.height;
            } else {
                u0 = uvs[index0] * base.width;
                u1 = uvs[index1] * base.width;
                u2 = uvs[index2] * base.width;
                v0 = uvs[index0 + 1] * base.height;
                v1 = uvs[index1 + 1] * base.height;
                v2 = uvs[index2 + 1] * base.height;
            }
    
            var x0 = vertices[index0];
            var x1 = vertices[index1];
            var x2 = vertices[index2];
            var y0 = vertices[index0 + 1];
            var y1 = vertices[index1 + 1];
            var y2 = vertices[index2 + 1];
    
            if (mesh.canvasPadding > 0) {
                var paddingX = mesh.canvasPadding / mesh.worldTransform.a;
                var paddingY = mesh.canvasPadding / mesh.worldTransform.d;
                var centerX = (x0 + x1 + x2) / 3;
                var centerY = (y0 + y1 + y2) / 3;
    
                var normX = x0 - centerX;
                var normY = y0 - centerY;
    
                var dist = Math.sqrt(normX * normX + normY * normY);
    
                x0 = centerX + normX / dist * (dist + paddingX);
                y0 = centerY + normY / dist * (dist + paddingY);
    
                //
    
                normX = x1 - centerX;
                normY = y1 - centerY;
    
                dist = Math.sqrt(normX * normX + normY * normY);
                x1 = centerX + normX / dist * (dist + paddingX);
                y1 = centerY + normY / dist * (dist + paddingY);
    
                normX = x2 - centerX;
                normY = y2 - centerY;
    
                dist = Math.sqrt(normX * normX + normY * normY);
                x2 = centerX + normX / dist * (dist + paddingX);
                y2 = centerY + normY / dist * (dist + paddingY);
            }
    
            context.save();
            context.beginPath();
    
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
    
            context.closePath();
    
            context.clip();
    
            // Compute matrix transform
            var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
            var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
            var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
            var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
            var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
            var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
            var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
    
            context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
    
            context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);
    
            context.restore();
        };
    
        /**
         * Renders a flat Mesh
         *
         * @private
         * @param {PIXI.mesh.Mesh} mesh - The Mesh to render
         */
    
    
        MeshSpriteRenderer.prototype.renderMeshFlat = function renderMeshFlat(mesh) {
            var context = this.renderer.context;
            var vertices = mesh.vertices;
            var length = vertices.length / 2;
    
            // this.count++;
    
            context.beginPath();
    
            for (var i = 1; i < length - 2; ++i) {
                // draw some triangles!
                var index = i * 2;
    
                var x0 = vertices[index];
                var y0 = vertices[index + 1];
    
                var x1 = vertices[index + 2];
                var y1 = vertices[index + 3];
    
                var x2 = vertices[index + 4];
                var y2 = vertices[index + 5];
    
                context.moveTo(x0, y0);
                context.lineTo(x1, y1);
                context.lineTo(x2, y2);
            }
    
            context.fillStyle = '#FF0000';
            context.fill();
            context.closePath();
        };
    
        /**
         * destroy the the renderer.
         *
         */
    
    
        MeshSpriteRenderer.prototype.destroy = function destroy() {
            this.renderer = null;
        };
    
        return MeshSpriteRenderer;
    }();
    
    exports.default = MeshSpriteRenderer;
    
    
    core.CanvasRenderer.registerPlugin('mesh', MeshSpriteRenderer);
    
    /***/ }),
    /* 159 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _logo = __webpack_require__(79);
    
    var _logo2 = _interopRequireDefault(_logo);
    
    var _layer = __webpack_require__(80);
    
    var _layer2 = _interopRequireDefault(_layer);
    
    var _fastBlur = __webpack_require__(168);
    
    var _stackBlur = __webpack_require__(169);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var scaleFactor = 2;
    var blurCoeff = 3;
    
    var LogoLayerCanvas = function (_LogoLayer) {
        _inherits(LogoLayerCanvas, _LogoLayer);
    
        function LogoLayerCanvas(texture, size) {
            _classCallCheck(this, LogoLayerCanvas);
    
            var _this = _possibleConstructorReturn(this, _LogoLayer.call(this, texture, size));
    
            _this.cacheOrigin(size);
            _this.setup(size, scaleFactor);
            _this.blurRadius = 0;
            return _this;
        }
    
        LogoLayerCanvas.prototype.cacheOrigin = function cacheOrigin(size) {
            this.layerRenderer = new PIXI.CanvasRenderer({
                width: size * scaleFactor,
                height: size * scaleFactor,
                transparent: true,
                clearBeforeRender: true
            });
            this.layerOrigin = this.source;
            this.layerOrigin.x *= scaleFactor;
            this.layerOrigin.y *= scaleFactor;
            this.layerRenderer.render(this.layerOrigin);
    
            var canvas = this.layerRenderer.view;
            var layerTexture = PIXI.Texture.fromCanvas(canvas);
            this.source = new PIXI.Sprite(layerTexture);
            this.context = canvas.getContext("2d");
        };
    
        LogoLayerCanvas.prototype.blurify = function blurify() {
            this.layerRenderer.render(this.layerOrigin);
            (0, _fastBlur.fastBlurRGBA)(this.context, this.blurRadius * blurCoeff, 1);
            this.source.texture.update();
        };
    
        LogoLayerCanvas.prototype.applyTint = function applyTint() {
            this.layerOrigin.tint = this.tintColor.toHex();
            this.blurify();
        };
    
        _createClass(LogoLayerCanvas, [{
            key: "blur",
            get: function get() {
                return this.blurRadius;
            },
            set: function set(val) {
                var coeff = +val;
                coeff = isNaN(coeff) || coeff < 0 ? 0 : Math.round(coeff);
                if (this.blurRadius !== coeff) {
                    this.blurRadius = coeff;
                    this.blurify();
                }
            }
        }]);
    
        return LogoLayerCanvas;
    }(_logo2.default);
    
    exports.default = LogoLayerCanvas;
    
    /***/ }),
    /* 160 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _linear = __webpack_require__(161);
    
    Object.defineProperty(exports, "easeLinear", {
        enumerable: true,
        get: function get() {
            return _linear.linear;
        }
    });
    
    var _quad = __webpack_require__(162);
    
    Object.defineProperty(exports, "easeQuad", {
        enumerable: true,
        get: function get() {
            return _quad.quadInOut;
        }
    });
    Object.defineProperty(exports, "easeQuadIn", {
        enumerable: true,
        get: function get() {
            return _quad.quadIn;
        }
    });
    Object.defineProperty(exports, "easeQuadOut", {
        enumerable: true,
        get: function get() {
            return _quad.quadOut;
        }
    });
    
    var _sin = __webpack_require__(163);
    
    Object.defineProperty(exports, "easeSin", {
        enumerable: true,
        get: function get() {
            return _sin.sinInOut;
        }
    });
    Object.defineProperty(exports, "easeSinIn", {
        enumerable: true,
        get: function get() {
            return _sin.sinIn;
        }
    });
    Object.defineProperty(exports, "easeSinOut", {
        enumerable: true,
        get: function get() {
            return _sin.sinOut;
        }
    });
    
    var _exp = __webpack_require__(164);
    
    Object.defineProperty(exports, "easeExp", {
        enumerable: true,
        get: function get() {
            return _exp.expInOut;
        }
    });
    Object.defineProperty(exports, "easeExpIn", {
        enumerable: true,
        get: function get() {
            return _exp.expIn;
        }
    });
    Object.defineProperty(exports, "easeExpOut", {
        enumerable: true,
        get: function get() {
            return _exp.expOut;
        }
    });
    
    var _circle = __webpack_require__(165);
    
    Object.defineProperty(exports, "easeCircle", {
        enumerable: true,
        get: function get() {
            return _circle.circleInOut;
        }
    });
    Object.defineProperty(exports, "easeCircleIn", {
        enumerable: true,
        get: function get() {
            return _circle.circleIn;
        }
    });
    Object.defineProperty(exports, "easeCircleOut", {
        enumerable: true,
        get: function get() {
            return _circle.circleOut;
        }
    });
    
    var _bounce = __webpack_require__(166);
    
    Object.defineProperty(exports, "easeBounce", {
        enumerable: true,
        get: function get() {
            return _bounce.bounceOut;
        }
    });
    Object.defineProperty(exports, "easeBounceIn", {
        enumerable: true,
        get: function get() {
            return _bounce.bounceIn;
        }
    });
    Object.defineProperty(exports, "easeBounceOut", {
        enumerable: true,
        get: function get() {
            return _bounce.bounceOut;
        }
    });
    
    var _elastic = __webpack_require__(167);
    
    Object.defineProperty(exports, "easeElastic", {
        enumerable: true,
        get: function get() {
            return _elastic.elasticOut;
        }
    });
    Object.defineProperty(exports, "easeElasticIn", {
        enumerable: true,
        get: function get() {
            return _elastic.elasticIn;
        }
    });
    Object.defineProperty(exports, "easeElasticOut", {
        enumerable: true,
        get: function get() {
            return _elastic.elasticOut;
        }
    });
    
    /***/ }),
    /* 161 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.linear = linear;
    function linear(t) {
        return +t;
    }
    
    /***/ }),
    /* 162 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.quadIn = quadIn;
    exports.quadOut = quadOut;
    exports.quadInOut = quadInOut;
    function quadIn(t) {
        return t * t;
    }
    
    function quadOut(t) {
        return t * (2 - t);
    }
    
    function quadInOut(t) {
        return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }
    
    /***/ }),
    /* 163 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.sinIn = sinIn;
    exports.sinOut = sinOut;
    exports.sinInOut = sinInOut;
    var pi = Math.PI,
        halfPi = pi / 2;
    
    function sinIn(t) {
        return 1 - Math.cos(t * halfPi);
    }
    
    function sinOut(t) {
        return Math.sin(t * halfPi);
    }
    
    function sinInOut(t) {
        return (1 - Math.cos(pi * t)) / 2;
    }
    
    /***/ }),
    /* 164 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.expIn = expIn;
    exports.expOut = expOut;
    exports.expInOut = expInOut;
    function expIn(t) {
        return Math.pow(2, 10 * t - 10);
    }
    
    function expOut(t) {
        return 1 - Math.pow(2, -10 * t);
    }
    
    function expInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
    }
    
    /***/ }),
    /* 165 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.circleIn = circleIn;
    exports.circleOut = circleOut;
    exports.circleInOut = circleInOut;
    function circleIn(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    
    function circleOut(t) {
        return Math.sqrt(1 - --t * t);
    }
    
    function circleInOut(t) {
        return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }
    
    /***/ }),
    /* 166 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.bounceIn = bounceIn;
    exports.bounceOut = bounceOut;
    exports.bounceInOut = bounceInOut;
    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;
    
    function bounceIn(t) {
        return 1 - bounceOut(1 - t);
    }
    
    function bounceOut(t) {
        return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }
    
    function bounceInOut(t) {
        return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }
    
    /***/ }),
    /* 167 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    var tau = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;
    
    var elasticIn = exports.elasticIn = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
    
        function elasticIn(t) {
            return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
        }
    
        elasticIn.amplitude = function (a) {
            return custom(a, p * tau);
        };
        elasticIn.period = function (p) {
            return custom(a, p);
        };
    
        return elasticIn;
    }(amplitude, period);
    
    var elasticOut = exports.elasticOut = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
    
        function elasticOut(t) {
            return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
        }
    
        elasticOut.amplitude = function (a) {
            return custom(a, p * tau);
        };
        elasticOut.period = function (p) {
            return custom(a, p);
        };
    
        return elasticOut;
    }(amplitude, period);
    
    var elasticInOut = exports.elasticInOut = function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
    
        function elasticInOut(t) {
            return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
        }
    
        elasticInOut.amplitude = function (a) {
            return custom(a, p * tau);
        };
        elasticInOut.period = function (p) {
            return custom(a, p);
        };
    
        return elasticInOut;
    }(amplitude, period);
    
    /***/ }),
    /* 168 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.fastBlurRGBA = fastBlurRGBA;
    exports.fastBlurRGB = fastBlurRGB;
    /*
     * Based on  Superfast Blur v0.5
     * by Mario Klingemann (mario@quasimondo.com, Twitter:	@quasimondo)
    */
    
    var MulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
    var ShgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
    
    function fastBlurRGBA(context, radius) {
        var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    
        if (isNaN(radius) || radius < 1) {
            return;
        }
    
        var width = context.canvas.width;
        var height = context.canvas.height;
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
    
        var rsum, gsum, bsum, asum, x, y, i, p, p1, p2, yp, yi, yw, pa;
        var wm = width - 1;
        var hm = height - 1;
        var rad1 = radius + 1;
    
        var mul_sum = MulTable[radius];
        var shg_sum = ShgTable[radius];
    
        var r = [];
        var g = [];
        var b = [];
        var a = [];
    
        var vmin = [];
        var vmax = [];
    
        while (iterations-- > 0) {
            yw = yi = 0;
    
            for (y = 0; y < height; y++) {
                rsum = pixels[yw] * rad1;
                gsum = pixels[yw + 1] * rad1;
                bsum = pixels[yw + 2] * rad1;
                asum = pixels[yw + 3] * rad1;
    
                for (i = 1; i <= radius; i++) {
                    p = yw + ((i > wm ? wm : i) << 2);
                    rsum += pixels[p++];
                    gsum += pixels[p++];
                    bsum += pixels[p++];
                    asum += pixels[p];
                }
    
                for (x = 0; x < width; x++) {
                    r[yi] = rsum;
                    g[yi] = gsum;
                    b[yi] = bsum;
                    a[yi] = asum;
    
                    if (y === 0) {
                        vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
                        vmax[x] = (p = x - radius) > 0 ? p << 2 : 0;
                    }
    
                    p1 = yw + vmin[x];
                    p2 = yw + vmax[x];
    
                    rsum += pixels[p1++] - pixels[p2++];
                    gsum += pixels[p1++] - pixels[p2++];
                    bsum += pixels[p1++] - pixels[p2++];
                    asum += pixels[p1] - pixels[p2];
    
                    yi++;
                }
                yw += width << 2;
            }
    
            for (x = 0; x < width; x++) {
                yp = x;
                rsum = r[yp] * rad1;
                gsum = g[yp] * rad1;
                bsum = b[yp] * rad1;
                asum = a[yp] * rad1;
    
                for (i = 1; i <= radius; i++) {
                    yp += i > hm ? 0 : width;
                    rsum += r[yp];
                    gsum += g[yp];
                    bsum += b[yp];
                    asum += a[yp];
                }
    
                yi = x << 2;
                for (y = 0; y < height; y++) {
    
                    pixels[yi + 3] = pa = asum * mul_sum >>> shg_sum;
                    if (pa > 0) {
                        pa = 255 / pa;
                        pixels[yi] = (rsum * mul_sum >>> shg_sum) * pa;
                        pixels[yi + 1] = (gsum * mul_sum >>> shg_sum) * pa;
                        pixels[yi + 2] = (bsum * mul_sum >>> shg_sum) * pa;
                    } else {
                        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                    }
                    if (x === 0) {
                        vmin[y] = ((p = y + rad1) < hm ? p : hm) * width;
                        vmax[y] = (p = y - radius) > 0 ? p * width : 0;
                    }
    
                    p1 = x + vmin[y];
                    p2 = x + vmax[y];
    
                    rsum += r[p1] - r[p2];
                    gsum += g[p1] - g[p2];
                    bsum += b[p1] - b[p2];
                    asum += a[p1] - a[p2];
    
                    yi += width << 2;
                }
            }
        }
    
        context.putImageData(imageData, 0, 0);
    }
    
    function fastBlurRGB(context, radius) {
        var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    
        if (isNaN(radius) || radius < 1) {
            return;
        }
    
        var width = context.canvas.width;
        var height = context.canvas.height;
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
    
        var rsum, gsum, bsum, x, y, i, p, p1, p2, yp, yi, yw;
        var wm = width - 1;
        var hm = height - 1;
        var rad1 = radius + 1;
    
        var r = [];
        var g = [];
        var b = [];
    
        var mul_sum = MulTable[radius];
        var shg_sum = ShgTable[radius];
    
        var vmin = [];
        var vmax = [];
    
        while (iterations-- > 0) {
            yw = yi = 0;
    
            for (y = 0; y < height; y++) {
                rsum = pixels[yw] * rad1;
                gsum = pixels[yw + 1] * rad1;
                bsum = pixels[yw + 2] * rad1;
    
                for (i = 1; i <= radius; i++) {
                    p = yw + ((i > wm ? wm : i) << 2);
                    rsum += pixels[p++];
                    gsum += pixels[p++];
                    bsum += pixels[p++];
                }
    
                for (x = 0; x < width; x++) {
                    r[yi] = rsum;
                    g[yi] = gsum;
                    b[yi] = bsum;
    
                    if (y === 0) {
                        vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
                        vmax[x] = (p = x - radius) > 0 ? p << 2 : 0;
                    }
    
                    p1 = yw + vmin[x];
                    p2 = yw + vmax[x];
    
                    rsum += pixels[p1++] - pixels[p2++];
                    gsum += pixels[p1++] - pixels[p2++];
                    bsum += pixels[p1++] - pixels[p2++];
    
                    yi++;
                }
                yw += width << 2;
            }
    
            for (x = 0; x < width; x++) {
                yp = x;
                rsum = r[yp] * rad1;
                gsum = g[yp] * rad1;
                bsum = b[yp] * rad1;
    
                for (i = 1; i <= radius; i++) {
                    yp += i > hm ? 0 : width;
                    rsum += r[yp];
                    gsum += g[yp];
                    bsum += b[yp];
                }
    
                yi = x << 2;
                for (y = 0; y < height; y++) {
                    pixels[yi] = rsum * mul_sum >>> shg_sum;
                    pixels[yi + 1] = gsum * mul_sum >>> shg_sum;
                    pixels[yi + 2] = bsum * mul_sum >>> shg_sum;
    
                    if (x === 0) {
                        vmin[y] = ((p = y + rad1) < hm ? p : hm) * width;
                        vmax[y] = (p = y - radius) > 0 ? p * width : 0;
                    }
    
                    p1 = x + vmin[y];
                    p2 = x + vmax[y];
    
                    rsum += r[p1] - r[p2];
                    gsum += g[p1] - g[p2];
                    bsum += b[p1] - b[p2];
    
                    yi += width << 2;
                }
            }
        }
        context.putImageData(imageData, 0, 0);
    }
    
    /***/ }),
    /* 169 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.stackBlurRGBA = stackBlurRGBA;
    exports.stackBlurRGB = stackBlurRGB;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /*
     * Based on  StackBlur - a fast almost Gaussian Blur For Canvas
     * by Mario Klingemann (mario@quasimondo.com, Twitter:	@quasimondo)
    */
    
    var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
    
    var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
    
    var BlurStack = function BlurStack() {
        _classCallCheck(this, BlurStack);
    
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = 0;
        this.next = null;
    };
    
    function stackBlurRGBA(context, radius) {
        if (isNaN(radius) || radius < 1) {
            return;
        }
        radius |= 0;
    
        var width = context.canvas.width;
        var height = context.canvas.height;
        var imageData = context.getImageData(0, 0, width, height);
    
        var pixels = imageData.data;
    
        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
    
        var div = radius + radius + 1;
        var widthMinus1 = width - 1;
        var heightMinus1 = height - 1;
        var radiusPlus1 = radius + 1;
        var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    
        var stackStart = new BlurStack();
        var stackEnd = null;
        var stack = stackStart;
        for (i = 1; i < div; i++) {
            stack = stack.next = new BlurStack();
            if (i === radiusPlus1) {
                stackEnd = stack;
            }
        }
        stack.next = stackStart;
        var stackIn = null;
        var stackOut = null;
    
        yw = yi = 0;
    
        var mul_sum = mulTable[radius];
        var shg_sum = shgTable[radius];
    
        for (y = 0; y < height; y++) {
            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
    
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    
            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;
    
            stack = stackStart;
    
            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }
    
            for (i = 1; i < radiusPlus1; i++) {
                p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
                a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
    
                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;
    
                stack = stack.next;
            }
    
            stackIn = stackStart;
            stackOut = stackEnd;
            for (x = 0; x < width; x++) {
                pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
                if (pa !== 0) {
                    pa = 255 / pa;
                    pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
                    pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                    pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
                } else {
                    pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
                }
    
                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;
    
                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;
    
                p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
    
                r_in_sum += stackIn.r = pixels[p];
                g_in_sum += stackIn.g = pixels[p + 1];
                b_in_sum += stackIn.b = pixels[p + 2];
                a_in_sum += stackIn.a = pixels[p + 3];
    
                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
                a_sum += a_in_sum;
    
                stackIn = stackIn.next;
    
                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
                a_out_sum += pa = stackOut.a;
    
                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;
    
                stackOut = stackOut.next;
    
                yi += 4;
            }
            yw += width;
        }
    
        for (x = 0; x < width; x++) {
            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
    
            yi = x << 2;
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
            a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    
            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
            a_sum += sumFactor * pa;
    
            stack = stackStart;
    
            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack.a = pa;
                stack = stack.next;
            }
    
            yp = width;
    
            for (i = 1; i <= radius; i++) {
                yi = yp + x << 2;
    
                r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
                a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
    
                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
                a_in_sum += pa;
    
                stack = stack.next;
    
                if (i < heightMinus1) {
                    yp += width;
                }
            }
    
            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for (y = 0; y < height; y++) {
                p = yi << 2;
                pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
                if (pa > 0) {
                    pa = 255 / pa;
                    pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
                    pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
                    pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
                } else {
                    pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
                }
    
                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
                a_sum -= a_out_sum;
    
                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
                a_out_sum -= stackIn.a;
    
                p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
    
                r_sum += r_in_sum += stackIn.r = pixels[p];
                g_sum += g_in_sum += stackIn.g = pixels[p + 1];
                b_sum += b_in_sum += stackIn.b = pixels[p + 2];
                a_sum += a_in_sum += stackIn.a = pixels[p + 3];
    
                stackIn = stackIn.next;
    
                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
                a_out_sum += pa = stackOut.a;
    
                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
                a_in_sum -= pa;
    
                stackOut = stackOut.next;
    
                yi += width;
            }
        }
        context.putImageData(imageData, 0, 0);
    }
    
    function stackBlurRGB(context, radius) {
        if (isNaN(radius) || radius < 1) return;
        radius |= 0;
    
        var width = context.canvas.width;
        var height = context.canvas.height;
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
    
        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, r_out_sum, g_out_sum, b_out_sum, r_in_sum, g_in_sum, b_in_sum, pr, pg, pb, rbs;
    
        var div = radius + radius + 1;
        var widthMinus1 = width - 1;
        var heightMinus1 = height - 1;
        var radiusPlus1 = radius + 1;
        var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    
        var stackStart = new BlurStack();
        var stackEnd = null;
        var stack = stackStart;
        for (i = 1; i < div; i++) {
            stack = stack.next = new BlurStack();
            if (i === radiusPlus1) {
                stackEnd = stack;
            }
        }
        stack.next = stackStart;
        var stackIn = null;
        var stackOut = null;
    
        yw = yi = 0;
    
        var mul_sum = mulTable[radius];
        var shg_sum = shgTable[radius];
    
        for (y = 0; y < height; y++) {
            r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
    
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    
            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
    
            stack = stackStart;
    
            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack = stack.next;
            }
    
            for (i = 1; i < radiusPlus1; i++) {
                p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
                r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
    
                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
    
                stack = stack.next;
            }
    
            stackIn = stackStart;
            stackOut = stackEnd;
            for (x = 0; x < width; x++) {
                pixels[yi] = r_sum * mul_sum >> shg_sum;
                pixels[yi + 1] = g_sum * mul_sum >> shg_sum;
                pixels[yi + 2] = b_sum * mul_sum >> shg_sum;
    
                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
    
                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
    
                p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
    
                r_in_sum += stackIn.r = pixels[p];
                g_in_sum += stackIn.g = pixels[p + 1];
                b_in_sum += stackIn.b = pixels[p + 2];
    
                r_sum += r_in_sum;
                g_sum += g_in_sum;
                b_sum += b_in_sum;
    
                stackIn = stackIn.next;
    
                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
    
                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
    
                stackOut = stackOut.next;
    
                yi += 4;
            }
            yw += width;
        }
    
        for (x = 0; x < width; x++) {
            g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
    
            yi = x << 2;
            r_out_sum = radiusPlus1 * (pr = pixels[yi]);
            g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
            b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    
            r_sum += sumFactor * pr;
            g_sum += sumFactor * pg;
            b_sum += sumFactor * pb;
    
            stack = stackStart;
    
            for (i = 0; i < radiusPlus1; i++) {
                stack.r = pr;
                stack.g = pg;
                stack.b = pb;
                stack = stack.next;
            }
    
            yp = width;
    
            for (i = 1; i <= radius; i++) {
                yi = yp + x << 2;
    
                r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
                g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
                b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
    
                r_in_sum += pr;
                g_in_sum += pg;
                b_in_sum += pb;
    
                stack = stack.next;
    
                if (i < heightMinus1) {
                    yp += width;
                }
            }
    
            yi = x;
            stackIn = stackStart;
            stackOut = stackEnd;
            for (y = 0; y < height; y++) {
                p = yi << 2;
                pixels[p] = r_sum * mul_sum >> shg_sum;
                pixels[p + 1] = g_sum * mul_sum >> shg_sum;
                pixels[p + 2] = b_sum * mul_sum >> shg_sum;
    
                r_sum -= r_out_sum;
                g_sum -= g_out_sum;
                b_sum -= b_out_sum;
    
                r_out_sum -= stackIn.r;
                g_out_sum -= stackIn.g;
                b_out_sum -= stackIn.b;
    
                p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
    
                r_sum += r_in_sum += stackIn.r = pixels[p];
                g_sum += g_in_sum += stackIn.g = pixels[p + 1];
                b_sum += b_in_sum += stackIn.b = pixels[p + 2];
    
                stackIn = stackIn.next;
    
                r_out_sum += pr = stackOut.r;
                g_out_sum += pg = stackOut.g;
                b_out_sum += pb = stackOut.b;
    
                r_in_sum -= pr;
                g_in_sum -= pg;
                b_in_sum -= pb;
    
                stackOut = stackOut.next;
    
                yi += width;
            }
        }
    
        context.putImageData(imageData, 0, 0);
    }
    
    /***/ }),
    /* 170 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _logo = __webpack_require__(79);
    
    var _logo2 = _interopRequireDefault(_logo);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var LogoLayerWebGl = function (_LogoLayer) {
        _inherits(LogoLayerWebGl, _LogoLayer);
    
        function LogoLayerWebGl(texture, size) {
            _classCallCheck(this, LogoLayerWebGl);
    
            var _this = _possibleConstructorReturn(this, _LogoLayer.call(this, texture, size));
    
            _this.blurFilter = null;
            _this.setupBlurFilter();
            return _this;
        }
    
        LogoLayerWebGl.prototype.setupBlurFilter = function setupBlurFilter() {
            this.blurFilter = new PIXI.filters.BlurFilter();
            this.blurFilter.blur = 0;
            this.source.filters = [this.blurFilter];
        };
    
        LogoLayerWebGl.prototype.applyTint = function applyTint() {
            this.source.tint = this.tintColor.toHex();
        };
    
        _createClass(LogoLayerWebGl, [{
            key: "blur",
            get: function get() {
                return this.blurFilter.blur;
            },
            set: function set(val) {
                var coeff = +val;
                coeff = isNaN(coeff) || coeff < 0 ? 0 : coeff;
                this.blurFilter.blur = coeff;
            }
        }]);
    
        return LogoLayerWebGl;
    }(_logo2.default);
    
    exports.default = LogoLayerWebGl;
    
    /***/ }),
    /* 171 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.MeshMovement = undefined;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _transition = __webpack_require__(20);
    
    var _transition2 = _interopRequireDefault(_transition);
    
    var _index = __webpack_require__(172);
    
    var _index2 = _interopRequireDefault(_index);
    
    var _utils = __webpack_require__(19);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var MeshMovement = exports.MeshMovement = function () {
        function MeshMovement(mesh) {
            _classCallCheck(this, MeshMovement);
    
            this.mesh = mesh;
            this.timer = { x: 0, y: 0 };
            this.originVertices = mesh.vertices.slice();
    
            this.deformer = {
                name: "none",
                func: _index2.default.none
            };
            this.speed = { x: 0, y: 0 };
            this.range = { x: 0, y: 0 };
        }
    
        MeshMovement.prototype.update = function update(deltaTime) {
            this._makeTransition(deltaTime);
            this._updateTimers(deltaTime);
            this.deformer.func.call(this);
        };
    
        MeshMovement.prototype.reset = function reset(vertices) {
            this.originVertices = vertices.slice();
        };
    
        MeshMovement.prototype.getState = function getState() {
            return {
                movement: this.movement,
                xRange: this.xRange,
                yRange: this.yRange,
                xPace: this.xPace,
                yPace: this.yPace
            };
        };
    
        MeshMovement.prototype.setState = function setState(settings) {
            if (!settings) {
                return;
            }
    
            this.movement = settings.movement;
            this.xRange = settings.xRange;
            this.yRange = settings.yRange;
            this.xPace = settings.xPace;
            this.yPace = settings.yPace;
        };
    
        MeshMovement.prototype.transitTo = function transitTo(state, duration, delay, easeType) {
            if (!state) {
                return;
            }
            var transition = new _transition2.default(this, duration, delay, easeType);
            transition.tween("movement", state.movement);
            transition.tween("xRange", state.xRange);
            transition.tween("yRange", state.yRange);
            transition.tween("xSpeed", (0, _utils.convertSpeedPace)(state.xPace));
            transition.tween("ySpeed", (0, _utils.convertSpeedPace)(state.yPace));
        };
    
        MeshMovement.prototype._makeTransition = function _makeTransition(deltaTime) {
            if (!this.__transition) {
                return;
            }
            this.__transition.tick(deltaTime);
        };
    
        MeshMovement.prototype._updateTimers = function _updateTimers(deltaTime) {
            this.timer.x += deltaTime * this.speed.x;
            this.timer.y += deltaTime * this.speed.y;
        };
    
        _createClass(MeshMovement, [{
            key: "movement",
            get: function get() {
                return this.deformer.name;
            },
            set: function set(type) {
                var movement = _index2.default[type];
                if (typeof movement !== "function") {
                    this.deformer = {
                        name: type,
                        func: _index2.default.none
                    };
                    this.timer.x = 0;
                    this.timer.y = 0;
                    return;
                }
                this.deformer = {
                    name: type,
                    func: movement
                };
            }
        }, {
            key: "xRange",
            get: function get() {
                return this.range.x;
            },
            set: function set(val) {
                this.range.x = val || 0;
            }
        }, {
            key: "yRange",
            get: function get() {
                return this.range.y;
            },
            set: function set(val) {
                this.range.y = val || 0;
            }
        }, {
            key: "xSpeed",
            get: function get() {
                return this.speed.x;
            },
            set: function set(val) {
                this.speed.x = val || 0;
            }
        }, {
            key: "ySpeed",
            get: function get() {
                return this.speed.y;
            },
            set: function set(val) {
                this.speed.y = val || 0;
            }
        }, {
            key: "xPace",
            get: function get() {
                return (0, _utils.convertSpeedPace)(this.speed.x);
            },
            set: function set(val) {
                this.speed.x = (0, _utils.convertSpeedPace)(val);
            }
        }, {
            key: "yPace",
            get: function get() {
                return (0, _utils.convertSpeedPace)(this.speed.y);
            },
            set: function set(val) {
                this.speed.y = (0, _utils.convertSpeedPace)(val);
            }
        }]);
    
        return MeshMovement;
    }();
    
    /***/ }),
    /* 172 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _none = __webpack_require__(173);
    
    var _none2 = _interopRequireDefault(_none);
    
    var _wave = __webpack_require__(174);
    
    var _wave2 = _interopRequireDefault(_wave);
    
    var _shake = __webpack_require__(175);
    
    var _shake2 = _interopRequireDefault(_shake);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var deformers = {
        none: _none2.default,
        shake: _shake2.default,
        wave: _wave2.default
    };
    
    exports.default = deformers;
    
    /***/ }),
    /* 173 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = none;
    function none() {
        return; // do nothing 
    };
    
    /***/ }),
    /* 174 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = wave;
    
    var tau = Math.PI * 2;
    var frequency = { x: 6, y: 6 };
    
    function wave() {
        var total = this.mesh.vertices.length;
        for (var i = 1; i < total; i = i + 2) {
            var yOffset = tau * frequency.y * (this.originVertices[i - 1] / this.mesh.width);
            var xOffset = tau * frequency.x * (this.originVertices[i] / this.mesh.height);
            this.mesh.vertices[i - 1] = this.originVertices[i - 1] + this.range.x * Math.sin(this.timer.x + xOffset);
            this.mesh.vertices[i] = this.originVertices[i] + this.range.y * Math.sin(this.timer.y + yOffset);
        }
    }
    
    /***/ }),
    /* 175 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    exports.default = shake;
    function shake() {
        var total = this.mesh.vertices.length - 1;
        for (var i = 0; i < total; i = i + 2) {
            this.mesh.vertices[i] = this.originVertices[i] + this.range.x * Math.sin(this.timer.x + i), this.mesh.vertices[i + 1] = this.originVertices[i + 1] + this.range.y * Math.cos(this.timer.y + i);
        }
    }
    
    /***/ }),
    /* 176 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _logoShape = __webpack_require__(82);
    
    var _logoShape2 = _interopRequireDefault(_logoShape);
    
    var _metaballizer = __webpack_require__(178);
    
    var _metaballizer2 = _interopRequireDefault(_metaballizer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var LogoShapeCanvas = function (_LogoShape) {
        _inherits(LogoShapeCanvas, _LogoShape);
    
        function LogoShapeCanvas(mesh, app) {
            _classCallCheck(this, LogoShapeCanvas);
    
            var _this = _possibleConstructorReturn(this, _LogoShape.call(this, mesh, app));
    
            _this.noMaskColor = "rgba(0,0,0,0)";
            return _this;
        }
    
        LogoShapeCanvas.prototype.prepareMetaballizer = function prepareMetaballizer() {
            this.metaballizer = new _metaballizer2.default(this.maskContext);
            this.metaballizer.registerBalls(this.bubbles);
        };
    
        LogoShapeCanvas.prototype.appendMask = function appendMask(app) {
            this.isApplied = true;
            this.maskSprite = this._createMask(app);
            this.maskSprite.width = this.width;
            this.maskSprite.height = this.height;
        };
    
        LogoShapeCanvas.prototype.setupEmptyMask = function setupEmptyMask() {
            this.cleanupMask();
        };
    
        LogoShapeCanvas.prototype.refreshMask = function refreshMask() {
            if (!this.maskSprite) {
                return;
            }
            this.maskSprite.texture.update();
        };
    
        return LogoShapeCanvas;
    }(_logoShape2.default);
    
    exports.default = LogoShapeCanvas;
    
    /***/ }),
    /* 177 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _rotatablePoint = __webpack_require__(33);
    
    var _rotatablePoint2 = _interopRequireDefault(_rotatablePoint);
    
    var _transition = __webpack_require__(20);
    
    var _transition2 = _interopRequireDefault(_transition);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var settings = {
        minSize: 0.15,
        maxSize: 0.3
    };
    
    var Bubble = function (_RotatablePoint) {
        _inherits(Bubble, _RotatablePoint);
    
        function Bubble(pivot, baseRadius, sizeCoeff, orbitCoeff, initRotation) {
            _classCallCheck(this, Bubble);
    
            var _this = _possibleConstructorReturn(this, _RotatablePoint.call(this, pivot, baseRadius, orbitCoeff, initRotation));
    
            _this._isHidding = false;
            _this._radiusCoeff = sizeCoeff || 1.0;
            _this._radiusSize = _this._radiusCoeff * _this._baseRadius;
    
            _this._prepareCache();
            return _this;
        }
    
        Bubble.prototype.update = function update(deltaTime) {
            this._pivot.update(deltaTime);
            _RotatablePoint.prototype.update.call(this, deltaTime);
        };
    
        Bubble.prototype.render = function render(container) {
            container.beginPath();
            var grad = container.createRadialGradient(this.x, this.y, this._radiusSize, this.x, this.y, 2 * this._radiusSize);
            grad.addColorStop(0, "rgba(255,255,255,1)");
            grad.addColorStop(1, "rgba(255,255,255,0)");
            container.fillStyle = grad;
            container.arc(this.x, this.y, 2 * this._radiusSize, 0, Math.PI * 2);
            container.fill();
        };
    
        Bubble.prototype.hideSlowly = function hideSlowly() {
            this._isHidding = true;
        };
    
        Bubble.prototype.changeMovement = function changeMovement() {
            // todo    
        };
    
        Bubble.prototype.addModifiers = function addModifiers() {
            // todo
        };
    
        Bubble.prototype.removeModifiers = function removeModifiers() {
            // todo
        };
    
        Bubble.prototype.getState = function getState() {
            var state = {
                size: this.size,
                pivot: this.pivot.getState(),
                bubble: _RotatablePoint.prototype.getState.call(this)
            };
            return state;
        };
    
        Bubble.prototype.setState = function setState(settings) {
            if (!settings) {
                return;
            }
            if (settings.hasOwnProperty("size")) {
                this.size = settings.size;
            }
            _RotatablePoint.prototype.setState.call(this, settings.bubble);
            this.pivot.setState(settings.pivot);
        };
    
        Bubble.prototype.transitTo = function transitTo(state, duration) {
            var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var easeType = arguments[3];
    
            if (!state) {
                return;
            }
            if (typeof this.pivot.transitTo === "function") {
                this.pivot.transitTo(state.pivot, duration, delay);
            }
            var transition = new _transition2.default(this, duration, delay, easeType);
            transition.tween("size", state.size);
            for (var key in state.bubble) {
                if (!state.bubble.hasOwnProperty(key)) {
                    continue;
                }
                if (key === "initRotation") {
                    transition.tweenRotation(key, state.bubble[key], 100);
                } else {
                    transition.tween(key, state.bubble[key]);
                }
            }
        };
    
        Bubble.prototype.getBaseRadius = function getBaseRadius() {
            return this._baseRadius;
        };
    
        Bubble.prototype._prepareCache = function _prepareCache() {
            var size = this._radiusSize * 4;
            var tempCanvas = document.createElement("canvas");
            tempCanvas.height = size;
            tempCanvas.width = size;
            this.gradientContext = tempCanvas.getContext("2d");
            this._cacheGradient();
        };
    
        Bubble.prototype._updateCache = function _updateCache() {
            var size = this._radiusSize * 4;
            // rescale cache canvas
            var tempCanvas = this.gradientContext.canvas;
            tempCanvas.height = size;
            tempCanvas.width = size;
            //cleanup context
            this.gradientContext.clearRect(0, 0, size, size);
            // update cached gradient
            this._cacheGradient();
        };
    
        Bubble.prototype._cacheGradient = function _cacheGradient() {
            this.gradientContext.beginPath();
            var grad = this.gradientContext.createRadialGradient(this.x, this.y, this._radiusSize, this.x, this.y, 2 * this._radiusSize);
            grad.addColorStop(0, "rgba(255,255,255,1)");
            grad.addColorStop(1, "rgba(255,255,255,0)");
            this.gradientContext.fillStyle = grad;
            this.gradientContext.arc(this.x, this.y, 2 * this._radiusSize, 0, Math.PI * 2);
            this.gradientContext.fill();
        };
    
        Bubble.getRandom = function getRandom(center, mainRadius) {
            // get pivot
            var pivotOrbitCoeff = 1.0; // todo
            var pivotRotation = Math.random() * 2 * Math.PI;
            var pivot = new _rotatablePoint2.default(center, mainRadius, pivotOrbitCoeff, pivotRotation);
            // bubble
            var initRotation = Math.PI + pivotRotation;
            var radiusCoeff = settings.minSize + (settings.maxSize - settings.minSize) * Math.random();
            var orbitCoeff = 0;
    
            return new Bubble(pivot, mainRadius, radiusCoeff, orbitCoeff, initRotation);
        };
    
        _createClass(Bubble, [{
            key: "radius",
            get: function get() {
                return this._radiusSize;
            }
        }, {
            key: "size",
            get: function get() {
                return this._radiusCoeff * 100;
            },
            set: function set(value) {
                this._radiusCoeff = (value || 0) / 100;
                this._radiusSize = this._radiusCoeff * this._baseRadius;
            }
        }, {
            key: "pivot",
            get: function get() {
                return this._pivot;
            }
        }]);
    
        return Bubble;
    }(_rotatablePoint2.default);
    
    exports.default = Bubble;
    
    /***/ }),
    /* 178 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _paper = __webpack_require__(179);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var rad2degrees = 180 / Math.PI;
    var pi2 = Math.PI / 2;
    
    var handleLenRate = 2.4;
    var offsetCoeff = 1.1;
    var v = 0.5; // todo clearify naming
    
    function getVector(radians, length) {
        return new _paper.Point({
            angle: radians * rad2degrees,
            length: length
        });
    }
    
    function createMetaball(ball1, ball2) {
        var radius1 = ball1.bounds.width / 2;
        var radius2 = ball2.bounds.width / 2;
        if (radius1 === 0 || radius2 === 0) {
            return null;
        }
    
        var center1 = ball1.position;
        var center2 = ball2.position;
        var d = center1.getDistance(center2);
        var maxDistance = (radius1 + radius2) * offsetCoeff;
        if (d > maxDistance || d <= Math.abs(radius1 - radius2)) {
            return null;
        }
    
        var u1 = 0,
            u2 = 0;
    
        if (d < radius1 + radius2) {
            // case circles are overlapping
            u1 = Math.acos((radius1 * radius1 + d * d - radius2 * radius2) / (2 * radius1 * d));
            u2 = Math.acos((radius2 * radius2 + d * d - radius1 * radius1) / (2 * radius2 * d));
        }
    
        var angle1 = center2.subtract(center1).getAngleInRadians();
        var angle2 = Math.acos((radius1 - radius2) / d);
        var angle1a = angle1 + u1 + (angle2 - u1) * v;
        var angle1b = angle1 - u1 - (angle2 - u1) * v;
        var angle2a = angle1 + Math.PI - u2 - (Math.PI - u2 - angle2) * v;
        var angle2b = angle1 - Math.PI + u2 + (Math.PI - u2 - angle2) * v;
        var p1a = center1.add(getVector(angle1a, radius1));
        var p1b = center1.add(getVector(angle1b, radius1));
        var p2a = center2.add(getVector(angle2a, radius2));
        var p2b = center2.add(getVector(angle2b, radius2));
    
        // define handle length by the distance between
        // both ends of the curve to draw
        var totalRadius = radius1 + radius2;
        var d2 = Math.min(v * handleLenRate, p1a.subtract(p2a).length / totalRadius);
    
        // case circles are overlapping:
        d2 *= Math.min(1, d * 2 / (radius1 + radius2));
    
        radius1 *= d2;
        radius2 *= d2;
    
        var path = new _paper.Path({
            segments: [p1a, p2a, p2b, p1b],
            style: ball1.style,
            closed: true
        });
    
        var segments = path.segments;
        segments[0].handleOut = getVector(angle1a - pi2, radius1);
        segments[1].handleIn = getVector(angle2a + pi2, radius2);
        segments[2].handleOut = getVector(angle2b - pi2, radius2);
        segments[3].handleIn = getVector(angle1b + pi2, radius1);
        return path;
    }
    
    function getCenters(balls) {
        var centers = [];
        for (var i = 0; i < balls.length; i++) {
            var ball = balls[i];
            var shape = new _paper.Path.Circle({
                center: [ball.x, ball.y],
                radius: ball.radius
            });
            centers.push(shape);
        }
        return centers;
    }
    
    function getConnections(centers, maxDistance) {
        var connections = [];
        for (var i = 0, l = centers.length; i < l; i++) {
            for (var j = i - 1; j >= 0; j--) {
                var path = createMetaball(centers[i], centers[j], maxDistance);
                if (path) {
                    connections.push(path);
                }
            }
        }
        return connections;
    }
    
    var Metaballizer = function () {
        function Metaballizer(context) {
            var fillColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "white";
    
            _classCallCheck(this, Metaballizer);
    
            this.balls = [];
    
            this.setup(context.canvas, fillColor);
        }
    
        Metaballizer.prototype.setup = function setup(canvas, color) {
            _paper.paper.setup(canvas);
            _paper.project.currentStyle = { fillColor: color, strokeColor: color };
    
            var baseRectangle = new _paper.Path.Rectangle({
                from: [0, 0],
                to: [canvas.width, canvas.height]
            });
    
            this.maskGroup = new _paper.Group();
            this.maskGroup.blendMode = "destination-out";
        };
    
        Metaballizer.prototype.registerBalls = function registerBalls(balls) {
            this.balls = balls || [];
        };
    
        Metaballizer.prototype.render = function render() {
            this.maskGroup.removeChildren();
            var centers = getCenters(this.balls);
            var connections = getConnections(centers);
            this.maskGroup.addChildren(connections);
            this.maskGroup.addChildren(centers);
            _paper.view.draw();
        };
    
        return Metaballizer;
    }();
    
    exports.default = Metaballizer;
    
    /***/ }),
    /* 179 */
    /***/ (function(module, exports, __webpack_require__) {
    
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
     * Paper.js v0.11.5 - The Swiss Army Knife of Vector Graphics Scripting.
     * http://paperjs.org/
     *
     * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey
     * http://scratchdisk.com/ & http://jonathanpuckey.com/
     *
     * Distributed under the MIT license. See LICENSE file for details.
     *
     * All rights reserved.
     *
     * Date: Thu Oct 5 16:16:29 2017 +0200
     *
     ***
     *
     * Straps.js - Class inheritance library with support for bean-style accessors
     *
     * Copyright (c) 2006 - 2016 Juerg Lehni
     * http://scratchdisk.com/
     *
     * Distributed under the MIT license.
     *
     ***
     *
     * Acorn.js
     * http://marijnhaverbeke.nl/acorn/
     *
     * Acorn is a tiny, fast JavaScript parser written in JavaScript,
     * created by Marijn Haverbeke and released under an MIT license.
     *
     */
    
    var paper = function(self, undefined) {
    
    self = self || __webpack_require__(180);
    var window = self.window,
        document = self.document;
    
    var Base = new function() {
        var hidden = /^(statics|enumerable|beans|preserve)$/,
            array = [],
            slice = array.slice,
            create = Object.create,
            describe = Object.getOwnPropertyDescriptor,
            define = Object.defineProperty,
    
            forEach = array.forEach || function(iter, bind) {
                for (var i = 0, l = this.length; i < l; i++) {
                    iter.call(bind, this[i], i, this);
                }
            },
    
            forIn = function(iter, bind) {
                for (var i in this) {
                    if (this.hasOwnProperty(i))
                        iter.call(bind, this[i], i, this);
                }
            },
    
            set = Object.assign || function(dst) {
                for (var i = 1, l = arguments.length; i < l; i++) {
                    var src = arguments[i];
                    for (var key in src) {
                        if (src.hasOwnProperty(key))
                            dst[key] = src[key];
                    }
                }
                return dst;
            },
    
            each = function(obj, iter, bind) {
                if (obj) {
                    var desc = describe(obj, 'length');
                    (desc && typeof desc.value === 'number' ? forEach : forIn)
                        .call(obj, iter, bind = bind || obj);
                }
                return bind;
            };
    
        function inject(dest, src, enumerable, beans, preserve) {
            var beansNames = {};
    
            function field(name, val) {
                val = val || (val = describe(src, name))
                        && (val.get ? val : val.value);
                if (typeof val === 'string' && val[0] === '#')
                    val = dest[val.substring(1)] || val;
                var isFunc = typeof val === 'function',
                    res = val,
                    prev = preserve || isFunc && !val.base
                            ? (val && val.get ? name in dest : dest[name])
                            : null,
                    bean;
                if (!preserve || !prev) {
                    if (isFunc && prev)
                        val.base = prev;
                    if (isFunc && beans !== false
                            && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
                        beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
                    if (!res || isFunc || !res.get || typeof res.get !== 'function'
                            || !Base.isPlainObject(res)) {
                        res = { value: res, writable: true };
                    }
                    if ((describe(dest, name)
                            || { configurable: true }).configurable) {
                        res.configurable = true;
                        res.enumerable = enumerable != null ? enumerable : !bean;
                    }
                    define(dest, name, res);
                }
            }
            if (src) {
                for (var name in src) {
                    if (src.hasOwnProperty(name) && !hidden.test(name))
                        field(name);
                }
                for (var name in beansNames) {
                    var part = beansNames[name],
                        set = dest['set' + part],
                        get = dest['get' + part] || set && dest['is' + part];
                    if (get && (beans === true || get.length === 0))
                        field(name, { get: get, set: set });
                }
            }
            return dest;
        }
    
        function Base() {
            for (var i = 0, l = arguments.length; i < l; i++) {
                var src = arguments[i];
                if (src)
                    set(this, src);
            }
            return this;
        }
    
        return inject(Base, {
            inject: function(src) {
                if (src) {
                    var statics = src.statics === true ? src : src.statics,
                        beans = src.beans,
                        preserve = src.preserve;
                    if (statics !== src)
                        inject(this.prototype, src, src.enumerable, beans, preserve);
                    inject(this, statics, null, beans, preserve);
                }
                for (var i = 1, l = arguments.length; i < l; i++)
                    this.inject(arguments[i]);
                return this;
            },
    
            extend: function() {
                var base = this,
                    ctor,
                    proto;
                for (var i = 0, obj, l = arguments.length;
                        i < l && !(ctor && proto); i++) {
                    obj = arguments[i];
                    ctor = ctor || obj.initialize;
                    proto = proto || obj.prototype;
                }
                ctor = ctor || function() {
                    base.apply(this, arguments);
                };
                proto = ctor.prototype = proto || create(this.prototype);
                define(proto, 'constructor',
                        { value: ctor, writable: true, configurable: true });
                inject(ctor, this);
                if (arguments.length)
                    this.inject.apply(ctor, arguments);
                ctor.base = base;
                return ctor;
            }
        }).inject({
            enumerable: false,
    
            initialize: Base,
    
            set: Base,
    
            inject: function() {
                for (var i = 0, l = arguments.length; i < l; i++) {
                    var src = arguments[i];
                    if (src) {
                        inject(this, src, src.enumerable, src.beans, src.preserve);
                    }
                }
                return this;
            },
    
            extend: function() {
                var res = create(this);
                return res.inject.apply(res, arguments);
            },
    
            each: function(iter, bind) {
                return each(this, iter, bind);
            },
    
            clone: function() {
                return new this.constructor(this);
            },
    
            statics: {
                set: set,
                each: each,
                create: create,
                define: define,
                describe: describe,
    
                clone: function(obj) {
                    return set(new obj.constructor(), obj);
                },
    
                isPlainObject: function(obj) {
                    var ctor = obj != null && obj.constructor;
                    return ctor && (ctor === Object || ctor === Base
                            || ctor.name === 'Object');
                },
    
                pick: function(a, b) {
                    return a !== undefined ? a : b;
                },
    
                slice: function(list, begin, end) {
                    return slice.call(list, begin, end);
                }
            }
        });
    };
    
    if (true)
        module.exports = Base;
    
    Base.inject({
        enumerable: false,
    
        toString: function() {
            return this._id != null
                ?  (this._class || 'Object') + (this._name
                    ? " '" + this._name + "'"
                    : ' @' + this._id)
                : '{ ' + Base.each(this, function(value, key) {
                    if (!/^_/.test(key)) {
                        var type = typeof value;
                        this.push(key + ': ' + (type === 'number'
                                ? Formatter.instance.number(value)
                                : type === 'string' ? "'" + value + "'" : value));
                    }
                }, []).join(', ') + ' }';
        },
    
        getClassName: function() {
            return this._class || '';
        },
    
        importJSON: function(json) {
            return Base.importJSON(json, this);
        },
    
        exportJSON: function(options) {
            return Base.exportJSON(this, options);
        },
    
        toJSON: function() {
            return Base.serialize(this);
        },
    
        set: function(props, exclude) {
            if (props)
                Base.filter(this, props, exclude, this._prioritize);
            return this;
        }
    }, {
    
    beans: false,
    statics: {
        exports: {},
    
        extend: function extend() {
            var res = extend.base.apply(this, arguments),
                name = res.prototype._class;
            if (name && !Base.exports[name])
                Base.exports[name] = res;
            return res;
        },
    
        equals: function(obj1, obj2) {
            if (obj1 === obj2)
                return true;
            if (obj1 && obj1.equals)
                return obj1.equals(obj2);
            if (obj2 && obj2.equals)
                return obj2.equals(obj1);
            if (obj1 && obj2
                    && typeof obj1 === 'object' && typeof obj2 === 'object') {
                if (Array.isArray(obj1) && Array.isArray(obj2)) {
                    var length = obj1.length;
                    if (length !== obj2.length)
                        return false;
                    while (length--) {
                        if (!Base.equals(obj1[length], obj2[length]))
                            return false;
                    }
                } else {
                    var keys = Object.keys(obj1),
                        length = keys.length;
                    if (length !== Object.keys(obj2).length)
                        return false;
                    while (length--) {
                        var key = keys[length];
                        if (!(obj2.hasOwnProperty(key)
                                && Base.equals(obj1[key], obj2[key])))
                            return false;
                    }
                }
                return true;
            }
            return false;
        },
    
        read: function(list, start, options, amount) {
            if (this === Base) {
                var value = this.peek(list, start);
                list.__index++;
                return value;
            }
            var proto = this.prototype,
                readIndex = proto._readIndex,
                begin = start || readIndex && list.__index || 0,
                length = list.length,
                obj = list[begin];
            amount = amount || length - begin;
            if (obj instanceof this
                || options && options.readNull && obj == null && amount <= 1) {
                if (readIndex)
                    list.__index = begin + 1;
                return obj && options && options.clone ? obj.clone() : obj;
            }
            obj = Base.create(proto);
            if (readIndex)
                obj.__read = true;
            obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length
                    ? Base.slice(list, begin, begin + amount)
                    : list) || obj;
            if (readIndex) {
                list.__index = begin + obj.__read;
                var filtered = obj.__filtered;
                if (filtered) {
                    list.__filtered = filtered;
                    obj.__filtered = undefined;
                }
                obj.__read = undefined;
            }
            return obj;
        },
    
        peek: function(list, start) {
            return list[list.__index = start || list.__index || 0];
        },
    
        remain: function(list) {
            return list.length - (list.__index || 0);
        },
    
        readList: function(list, start, options, amount) {
            var res = [],
                entry,
                begin = start || 0,
                end = amount ? begin + amount : list.length;
            for (var i = begin; i < end; i++) {
                res.push(Array.isArray(entry = list[i])
                        ? this.read(entry, 0, options)
                        : this.read(list, i, options, 1));
            }
            return res;
        },
    
        readNamed: function(list, name, start, options, amount) {
            var value = this.getNamed(list, name),
                hasObject = value !== undefined;
            if (hasObject) {
                var filtered = list.__filtered;
                if (!filtered) {
                    filtered = list.__filtered = Base.create(list[0]);
                    filtered.__unfiltered = list[0];
                }
                filtered[name] = undefined;
            }
            var l = hasObject ? [value] : list,
                res = this.read(l, start, options, amount);
            return res;
        },
    
        getNamed: function(list, name) {
            var arg = list[0];
            if (list._hasObject === undefined)
                list._hasObject = list.length === 1 && Base.isPlainObject(arg);
            if (list._hasObject)
                return name ? arg[name] : list.__filtered || arg;
        },
    
        hasNamed: function(list, name) {
            return !!this.getNamed(list, name);
        },
    
        filter: function(dest, source, exclude, prioritize) {
            var processed;
    
            function handleKey(key) {
                if (!(exclude && key in exclude) &&
                    !(processed && key in processed)) {
                    var value = source[key];
                    if (value !== undefined)
                        dest[key] = value;
                }
            }
    
            if (prioritize) {
                var keys = {};
                for (var i = 0, key, l = prioritize.length; i < l; i++) {
                    if ((key = prioritize[i]) in source) {
                        handleKey(key);
                        keys[key] = true;
                    }
                }
                processed = keys;
            }
    
            Object.keys(source.__unfiltered || source).forEach(handleKey);
            return dest;
        },
    
        isPlainValue: function(obj, asString) {
            return Base.isPlainObject(obj) || Array.isArray(obj)
                    || asString && typeof obj === 'string';
        },
    
        serialize: function(obj, options, compact, dictionary) {
            options = options || {};
    
            var isRoot = !dictionary,
                res;
            if (isRoot) {
                options.formatter = new Formatter(options.precision);
                dictionary = {
                    length: 0,
                    definitions: {},
                    references: {},
                    add: function(item, create) {
                        var id = '#' + item._id,
                            ref = this.references[id];
                        if (!ref) {
                            this.length++;
                            var res = create.call(item),
                                name = item._class;
                            if (name && res[0] !== name)
                                res.unshift(name);
                            this.definitions[id] = res;
                            ref = this.references[id] = [id];
                        }
                        return ref;
                    }
                };
            }
            if (obj && obj._serialize) {
                res = obj._serialize(options, dictionary);
                var name = obj._class;
                if (name && !obj._compactSerialize && (isRoot || !compact)
                        && res[0] !== name) {
                    res.unshift(name);
                }
            } else if (Array.isArray(obj)) {
                res = [];
                for (var i = 0, l = obj.length; i < l; i++)
                    res[i] = Base.serialize(obj[i], options, compact, dictionary);
            } else if (Base.isPlainObject(obj)) {
                res = {};
                var keys = Object.keys(obj);
                for (var i = 0, l = keys.length; i < l; i++) {
                    var key = keys[i];
                    res[key] = Base.serialize(obj[key], options, compact,
                            dictionary);
                }
            } else if (typeof obj === 'number') {
                res = options.formatter.number(obj, options.precision);
            } else {
                res = obj;
            }
            return isRoot && dictionary.length > 0
                    ? [['dictionary', dictionary.definitions], res]
                    : res;
        },
    
        deserialize: function(json, create, _data, _setDictionary, _isRoot) {
            var res = json,
                isFirst = !_data,
                hasDictionary = isFirst && json && json.length
                    && json[0][0] === 'dictionary';
            _data = _data || {};
            if (Array.isArray(json)) {
                var type = json[0],
                    isDictionary = type === 'dictionary';
                if (json.length == 1 && /^#/.test(type)) {
                    return _data.dictionary[type];
                }
                type = Base.exports[type];
                res = [];
                for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
                    res.push(Base.deserialize(json[i], create, _data,
                            isDictionary, hasDictionary));
                }
                if (type) {
                    var args = res;
                    if (create) {
                        res = create(type, args, isFirst || _isRoot);
                    } else {
                        res = Base.create(type.prototype);
                        type.apply(res, args);
                    }
                }
            } else if (Base.isPlainObject(json)) {
                res = {};
                if (_setDictionary)
                    _data.dictionary = res;
                for (var key in json)
                    res[key] = Base.deserialize(json[key], create, _data);
            }
            return hasDictionary ? res[1] : res;
        },
    
        exportJSON: function(obj, options) {
            var json = Base.serialize(obj, options);
            return options && options.asString == false
                    ? json
                    : JSON.stringify(json);
        },
    
        importJSON: function(json, target) {
            return Base.deserialize(
                    typeof json === 'string' ? JSON.parse(json) : json,
                    function(ctor, args, isRoot) {
                        var useTarget = isRoot && target
                                && target.constructor === ctor,
                            obj = useTarget ? target
                                : Base.create(ctor.prototype);
                        if (args.length === 1 && obj instanceof Item
                                && (useTarget || !(obj instanceof Layer))) {
                            var arg = args[0];
                            if (Base.isPlainObject(arg))
                                arg.insert = false;
                        }
                        (useTarget ? obj.set : ctor).apply(obj, args);
                        if (useTarget)
                            target = null;
                        return obj;
                    });
        },
    
        splice: function(list, items, index, remove) {
            var amount = items && items.length,
                append = index === undefined;
            index = append ? list.length : index;
            if (index > list.length)
                index = list.length;
            for (var i = 0; i < amount; i++)
                items[i]._index = index + i;
            if (append) {
                list.push.apply(list, items);
                return [];
            } else {
                var args = [index, remove];
                if (items)
                    args.push.apply(args, items);
                var removed = list.splice.apply(list, args);
                for (var i = 0, l = removed.length; i < l; i++)
                    removed[i]._index = undefined;
                for (var i = index + amount, l = list.length; i < l; i++)
                    list[i]._index = i;
                return removed;
            }
        },
    
        capitalize: function(str) {
            return str.replace(/\b[a-z]/g, function(match) {
                return match.toUpperCase();
            });
        },
    
        camelize: function(str) {
            return str.replace(/-(.)/g, function(match, chr) {
                return chr.toUpperCase();
            });
        },
    
        hyphenate: function(str) {
            return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        }
    }});
    
    var Emitter = {
        on: function(type, func) {
            if (typeof type !== 'string') {
                Base.each(type, function(value, key) {
                    this.on(key, value);
                }, this);
            } else {
                var types = this._eventTypes,
                    entry = types && types[type],
                    handlers = this._callbacks = this._callbacks || {};
                handlers = handlers[type] = handlers[type] || [];
                if (handlers.indexOf(func) === -1) {
                    handlers.push(func);
                    if (entry && entry.install && handlers.length === 1)
                        entry.install.call(this, type);
                }
            }
            return this;
        },
    
        off: function(type, func) {
            if (typeof type !== 'string') {
                Base.each(type, function(value, key) {
                    this.off(key, value);
                }, this);
                return;
            }
            var types = this._eventTypes,
                entry = types && types[type],
                handlers = this._callbacks && this._callbacks[type],
                index;
            if (handlers) {
                if (!func || (index = handlers.indexOf(func)) !== -1
                        && handlers.length === 1) {
                    if (entry && entry.uninstall)
                        entry.uninstall.call(this, type);
                    delete this._callbacks[type];
                } else if (index !== -1) {
                    handlers.splice(index, 1);
                }
            }
            return this;
        },
    
        once: function(type, func) {
            return this.on(type, function() {
                func.apply(this, arguments);
                this.off(type, func);
            });
        },
    
        emit: function(type, event) {
            var handlers = this._callbacks && this._callbacks[type];
            if (!handlers)
                return false;
            var args = Base.slice(arguments, 1),
                setTarget = event && event.target && !event.currentTarget;
            handlers = handlers.slice();
            if (setTarget)
                event.currentTarget = this;
            for (var i = 0, l = handlers.length; i < l; i++) {
                if (handlers[i].apply(this, args) == false) {
                    if (event && event.stop)
                        event.stop();
                    break;
               }
            }
            if (setTarget)
                delete event.currentTarget;
            return true;
        },
    
        responds: function(type) {
            return !!(this._callbacks && this._callbacks[type]);
        },
    
        attach: '#on',
        detach: '#off',
        fire: '#emit',
    
        _installEvents: function(install) {
            var types = this._eventTypes,
                handlers = this._callbacks,
                key = install ? 'install' : 'uninstall';
            if (types) {
                for (var type in handlers) {
                    if (handlers[type].length > 0) {
                        var entry = types[type],
                            func = entry && entry[key];
                        if (func)
                            func.call(this, type);
                    }
                }
            }
        },
    
        statics: {
            inject: function inject(src) {
                var events = src._events;
                if (events) {
                    var types = {};
                    Base.each(events, function(entry, key) {
                        var isString = typeof entry === 'string',
                            name = isString ? entry : key,
                            part = Base.capitalize(name),
                            type = name.substring(2).toLowerCase();
                        types[type] = isString ? {} : entry;
                        name = '_' + name;
                        src['get' + part] = function() {
                            return this[name];
                        };
                        src['set' + part] = function(func) {
                            var prev = this[name];
                            if (prev)
                                this.off(type, prev);
                            if (func)
                                this.on(type, func);
                            this[name] = func;
                        };
                    });
                    src._eventTypes = types;
                }
                return inject.base.apply(this, arguments);
            }
        }
    };
    
    var PaperScope = Base.extend({
        _class: 'PaperScope',
    
        initialize: function PaperScope() {
            paper = this;
            this.settings = new Base({
                applyMatrix: true,
                insertItems: true,
                handleSize: 4,
                hitTolerance: 0
            });
            this.project = null;
            this.projects = [];
            this.tools = [];
            this._id = PaperScope._id++;
            PaperScope._scopes[this._id] = this;
            var proto = PaperScope.prototype;
            if (!this.support) {
                var ctx = CanvasProvider.getContext(1, 1) || {};
                proto.support = {
                    nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
                    nativeBlendModes: BlendMode.nativeModes
                };
                CanvasProvider.release(ctx);
            }
            if (!this.agent) {
                var user = self.navigator.userAgent.toLowerCase(),
                    os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],
                    platform = os === 'darwin' ? 'mac' : os,
                    agent = proto.agent = proto.browser = { platform: platform };
                if (platform)
                    agent[platform] = true;
                user.replace(
                    /(opera|chrome|safari|webkit|firefox|msie|trident|atom|node)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
                    function(match, n, v1, v2, rv) {
                        if (!agent.chrome) {
                            var v = n === 'opera' ? v2 :
                                    /^(node|trident)$/.test(n) ? rv : v1;
                            agent.version = v;
                            agent.versionNumber = parseFloat(v);
                            n = n === 'trident' ? 'msie' : n;
                            agent.name = n;
                            agent[n] = true;
                        }
                    }
                );
                if (agent.chrome)
                    delete agent.webkit;
                if (agent.atom)
                    delete agent.chrome;
            }
        },
    
        version: "0.11.5",
    
        getView: function() {
            var project = this.project;
            return project && project._view;
        },
    
        getPaper: function() {
            return this;
        },
    
        execute: function(code, options) {
            paper.PaperScript.execute(code, this, options);
            View.updateFocus();
        },
    
        install: function(scope) {
            var that = this;
            Base.each(['project', 'view', 'tool'], function(key) {
                Base.define(scope, key, {
                    configurable: true,
                    get: function() {
                        return that[key];
                    }
                });
            });
            for (var key in this)
                if (!/^_/.test(key) && this[key])
                    scope[key] = this[key];
        },
    
        setup: function(element) {
            paper = this;
            this.project = new Project(element);
            return this;
        },
    
        createCanvas: function(width, height) {
            return CanvasProvider.getCanvas(width, height);
        },
    
        activate: function() {
            paper = this;
        },
    
        clear: function() {
            var projects = this.projects,
                tools = this.tools;
            for (var i = projects.length - 1; i >= 0; i--)
                projects[i].remove();
            for (var i = tools.length - 1; i >= 0; i--)
                tools[i].remove();
        },
    
        remove: function() {
            this.clear();
            delete PaperScope._scopes[this._id];
        },
    
        statics: new function() {
            function handleAttribute(name) {
                name += 'Attribute';
                return function(el, attr) {
                    return el[name](attr) || el[name]('data-paper-' + attr);
                };
            }
    
            return {
                _scopes: {},
                _id: 0,
    
                get: function(id) {
                    return this._scopes[id] || null;
                },
    
                getAttribute: handleAttribute('get'),
                hasAttribute: handleAttribute('has')
            };
        }
    });
    
    var PaperScopeItem = Base.extend(Emitter, {
    
        initialize: function(activate) {
            this._scope = paper;
            this._index = this._scope[this._list].push(this) - 1;
            if (activate || !this._scope[this._reference])
                this.activate();
        },
    
        activate: function() {
            if (!this._scope)
                return false;
            var prev = this._scope[this._reference];
            if (prev && prev !== this)
                prev.emit('deactivate');
            this._scope[this._reference] = this;
            this.emit('activate', prev);
            return true;
        },
    
        isActive: function() {
            return this._scope[this._reference] === this;
        },
    
        remove: function() {
            if (this._index == null)
                return false;
            Base.splice(this._scope[this._list], null, this._index, 1);
            if (this._scope[this._reference] == this)
                this._scope[this._reference] = null;
            this._scope = null;
            return true;
        },
    
        getView: function() {
            return this._scope.getView();
        }
    });
    
    var Formatter = Base.extend({
        initialize: function(precision) {
            this.precision = Base.pick(precision, 5);
            this.multiplier = Math.pow(10, this.precision);
        },
    
        number: function(val) {
            return this.precision < 16
                    ? Math.round(val * this.multiplier) / this.multiplier : val;
        },
    
        pair: function(val1, val2, separator) {
            return this.number(val1) + (separator || ',') + this.number(val2);
        },
    
        point: function(val, separator) {
            return this.number(val.x) + (separator || ',') + this.number(val.y);
        },
    
        size: function(val, separator) {
            return this.number(val.width) + (separator || ',')
                    + this.number(val.height);
        },
    
        rectangle: function(val, separator) {
            return this.point(val, separator) + (separator || ',')
                    + this.size(val, separator);
        }
    });
    
    Formatter.instance = new Formatter();
    
    var Numerical = new function() {
    
        var abscissas = [
            [  0.5773502691896257645091488],
            [0,0.7745966692414833770358531],
            [  0.3399810435848562648026658,0.8611363115940525752239465],
            [0,0.5384693101056830910363144,0.9061798459386639927976269],
            [  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
            [0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
            [  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
            [0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
            [  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
            [0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
            [  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
            [0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
            [  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
            [0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
            [  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
        ];
    
        var weights = [
            [1],
            [0.8888888888888888888888889,0.5555555555555555555555556],
            [0.6521451548625461426269361,0.3478548451374538573730639],
            [0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
            [0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
            [0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
            [0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
            [0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
            [0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
            [0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
            [0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
            [0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
            [0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
            [0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
            [0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
        ];
    
        var abs = Math.abs,
            sqrt = Math.sqrt,
            pow = Math.pow,
            log2 = Math.log2 || function(x) {
                return Math.log(x) * Math.LOG2E;
            },
            EPSILON = 1e-12,
            MACHINE_EPSILON = 1.12e-16;
    
        function clamp(value, min, max) {
            return value < min ? min : value > max ? max : value;
        }
    
        function getDiscriminant(a, b, c) {
            function split(v) {
                var x = v * 134217729,
                    y = v - x,
                    hi = y + x,
                    lo = v - hi;
                return [hi, lo];
            }
    
            var D = b * b - a * c,
                E = b * b + a * c;
            if (abs(D) * 3 < E) {
                var ad = split(a),
                    bd = split(b),
                    cd = split(c),
                    p = b * b,
                    dp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],
                    q = a * c,
                    dq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])
                            + ad[1] * cd[1];
                D = (p - q) + (dp - dq);
            }
            return D;
        }
    
        function getNormalizationFactor() {
            var norm = Math.max.apply(Math, arguments);
            return norm && (norm < 1e-8 || norm > 1e8)
                    ? pow(2, -Math.round(log2(norm)))
                    : 0;
        }
    
        return {
            EPSILON: EPSILON,
            MACHINE_EPSILON: MACHINE_EPSILON,
            CURVETIME_EPSILON: 1e-8,
            GEOMETRIC_EPSILON: 1e-7,
            TRIGONOMETRIC_EPSILON: 1e-8,
            KAPPA: 4 * (sqrt(2) - 1) / 3,
    
            isZero: function(val) {
                return val >= -EPSILON && val <= EPSILON;
            },
    
            clamp: clamp,
    
            integrate: function(f, a, b, n) {
                var x = abscissas[n - 2],
                    w = weights[n - 2],
                    A = (b - a) * 0.5,
                    B = A + a,
                    i = 0,
                    m = (n + 1) >> 1,
                    sum = n & 1 ? w[i++] * f(B) : 0;
                while (i < m) {
                    var Ax = A * x[i];
                    sum += w[i++] * (f(B + Ax) + f(B - Ax));
                }
                return A * sum;
            },
    
            findRoot: function(f, df, x, a, b, n, tolerance) {
                for (var i = 0; i < n; i++) {
                    var fx = f(x),
                        dx = fx / df(x),
                        nx = x - dx;
                    if (abs(dx) < tolerance) {
                        x = nx;
                        break;
                    }
                    if (fx > 0) {
                        b = x;
                        x = nx <= a ? (a + b) * 0.5 : nx;
                    } else {
                        a = x;
                        x = nx >= b ? (a + b) * 0.5 : nx;
                    }
                }
                return clamp(x, a, b);
            },
    
            solveQuadratic: function(a, b, c, roots, min, max) {
                var x1, x2 = Infinity;
                if (abs(a) < EPSILON) {
                    if (abs(b) < EPSILON)
                        return abs(c) < EPSILON ? -1 : 0;
                    x1 = -c / b;
                } else {
                    b *= -0.5;
                    var D = getDiscriminant(a, b, c);
                    if (D && abs(D) < MACHINE_EPSILON) {
                        var f = getNormalizationFactor(abs(a), abs(b), abs(c));
                        if (f) {
                            a *= f;
                            b *= f;
                            c *= f;
                            D = getDiscriminant(a, b, c);
                        }
                    }
                    if (D >= -MACHINE_EPSILON) {
                        var Q = D < 0 ? 0 : sqrt(D),
                            R = b + (b < 0 ? -Q : Q);
                        if (R === 0) {
                            x1 = c / a;
                            x2 = -x1;
                        } else {
                            x1 = R / a;
                            x2 = c / R;
                        }
                    }
                }
                var count = 0,
                    boundless = min == null,
                    minB = min - EPSILON,
                    maxB = max + EPSILON;
                if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))
                    roots[count++] = boundless ? x1 : clamp(x1, min, max);
                if (x2 !== x1
                        && isFinite(x2) && (boundless || x2 > minB && x2 < maxB))
                    roots[count++] = boundless ? x2 : clamp(x2, min, max);
                return count;
            },
    
            solveCubic: function(a, b, c, d, roots, min, max) {
                var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
                    x, b1, c2, qd, q;
                if (f) {
                    a *= f;
                    b *= f;
                    c *= f;
                    d *= f;
                }
    
                function evaluate(x0) {
                    x = x0;
                    var tmp = a * x;
                    b1 = tmp + b;
                    c2 = b1 * x + c;
                    qd = (tmp + b1) * x + c2;
                    q = c2 * x + d;
                }
    
                if (abs(a) < EPSILON) {
                    a = b;
                    b1 = c;
                    c2 = d;
                    x = Infinity;
                } else if (abs(d) < EPSILON) {
                    b1 = b;
                    c2 = c;
                    x = 0;
                } else {
                    evaluate(-(b / a) / 3);
                    var t = q / a,
                        r = pow(abs(t), 1/3),
                        s = t < 0 ? -1 : 1,
                        td = -qd / a,
                        rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
                        x0 = x - s * rd;
                    if (x0 !== x) {
                        do {
                            evaluate(x0);
                            x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
                        } while (s * x0 > s * x);
                        if (abs(a) * x * x > abs(d / x)) {
                            c2 = -d / x;
                            b1 = (c2 - c) / x;
                        }
                    }
                }
                var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
                    boundless = min == null;
                if (isFinite(x) && (count === 0
                        || count > 0 && x !== roots[0] && x !== roots[1])
                        && (boundless || x > min - EPSILON && x < max + EPSILON))
                    roots[count++] = boundless ? x : clamp(x, min, max);
                return count;
            }
        };
    };
    
    var UID = {
        _id: 1,
        _pools: {},
    
        get: function(name) {
            if (name) {
                var pool = this._pools[name];
                if (!pool)
                    pool = this._pools[name] = { _id: 1 };
                return pool._id++;
            } else {
                return this._id++;
            }
        }
    };
    
    var Point = Base.extend({
        _class: 'Point',
        _readIndex: true,
    
        initialize: function Point(arg0, arg1) {
            var type = typeof arg0,
                reading = this.__read,
                read = 0;
            if (type === 'number') {
                var hasY = typeof arg1 === 'number';
                this._set(arg0, hasY ? arg1 : arg0);
                if (reading)
                    read = hasY ? 2 : 1;
            } else if (type === 'undefined' || arg0 === null) {
                this._set(0, 0);
                if (reading)
                    read = arg0 === null ? 1 : 0;
            } else {
                var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
                read = 1;
                if (Array.isArray(obj)) {
                    this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
                } else if ('x' in obj) {
                    this._set(obj.x || 0, obj.y || 0);
                } else if ('width' in obj) {
                    this._set(obj.width || 0, obj.height || 0);
                } else if ('angle' in obj) {
                    this._set(obj.length || 0, 0);
                    this.setAngle(obj.angle || 0);
                } else {
                    this._set(0, 0);
                    read = 0;
                }
            }
            if (reading)
                this.__read = read;
            return this;
        },
    
        set: '#initialize',
    
        _set: function(x, y) {
            this.x = x;
            this.y = y;
            return this;
        },
    
        equals: function(point) {
            return this === point || point
                    && (this.x === point.x && this.y === point.y
                        || Array.isArray(point)
                            && this.x === point[0] && this.y === point[1])
                    || false;
        },
    
        clone: function() {
            return new Point(this.x, this.y);
        },
    
        toString: function() {
            var f = Formatter.instance;
            return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
        },
    
        _serialize: function(options) {
            var f = options.formatter;
            return [f.number(this.x), f.number(this.y)];
        },
    
        getLength: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
    
        setLength: function(length) {
            if (this.isZero()) {
                var angle = this._angle || 0;
                this._set(
                    Math.cos(angle) * length,
                    Math.sin(angle) * length
                );
            } else {
                var scale = length / this.getLength();
                if (Numerical.isZero(scale))
                    this.getAngle();
                this._set(
                    this.x * scale,
                    this.y * scale
                );
            }
        },
        getAngle: function() {
            return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
        },
    
        setAngle: function(angle) {
            this.setAngleInRadians.call(this, angle * Math.PI / 180);
        },
    
        getAngleInDegrees: '#getAngle',
        setAngleInDegrees: '#setAngle',
    
        getAngleInRadians: function() {
            if (!arguments.length) {
                return this.isZero()
                        ? this._angle || 0
                        : this._angle = Math.atan2(this.y, this.x);
            } else {
                var point = Point.read(arguments),
                    div = this.getLength() * point.getLength();
                if (Numerical.isZero(div)) {
                    return NaN;
                } else {
                    var a = this.dot(point) / div;
                    return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
                }
            }
        },
    
        setAngleInRadians: function(angle) {
            this._angle = angle;
            if (!this.isZero()) {
                var length = this.getLength();
                this._set(
                    Math.cos(angle) * length,
                    Math.sin(angle) * length
                );
            }
        },
    
        getQuadrant: function() {
            return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
        }
    }, {
        beans: false,
    
        getDirectedAngle: function() {
            var point = Point.read(arguments);
            return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
        },
    
        getDistance: function() {
            var point = Point.read(arguments),
                x = point.x - this.x,
                y = point.y - this.y,
                d = x * x + y * y,
                squared = Base.read(arguments);
            return squared ? d : Math.sqrt(d);
        },
    
        normalize: function(length) {
            if (length === undefined)
                length = 1;
            var current = this.getLength(),
                scale = current !== 0 ? length / current : 0,
                point = new Point(this.x * scale, this.y * scale);
            if (scale >= 0)
                point._angle = this._angle;
            return point;
        },
    
        rotate: function(angle, center) {
            if (angle === 0)
                return this.clone();
            angle = angle * Math.PI / 180;
            var point = center ? this.subtract(center) : this,
                sin = Math.sin(angle),
                cos = Math.cos(angle);
            point = new Point(
                point.x * cos - point.y * sin,
                point.x * sin + point.y * cos
            );
            return center ? point.add(center) : point;
        },
    
        transform: function(matrix) {
            return matrix ? matrix._transformPoint(this) : this;
        },
    
        add: function() {
            var point = Point.read(arguments);
            return new Point(this.x + point.x, this.y + point.y);
        },
    
        subtract: function() {
            var point = Point.read(arguments);
            return new Point(this.x - point.x, this.y - point.y);
        },
    
        multiply: function() {
            var point = Point.read(arguments);
            return new Point(this.x * point.x, this.y * point.y);
        },
    
        divide: function() {
            var point = Point.read(arguments);
            return new Point(this.x / point.x, this.y / point.y);
        },
    
        modulo: function() {
            var point = Point.read(arguments);
            return new Point(this.x % point.x, this.y % point.y);
        },
    
        negate: function() {
            return new Point(-this.x, -this.y);
        },
    
        isInside: function() {
            return Rectangle.read(arguments).contains(this);
        },
    
        isClose: function() {
            var point = Point.read(arguments),
                tolerance = Base.read(arguments);
            return this.getDistance(point) <= tolerance;
        },
    
        isCollinear: function() {
            var point = Point.read(arguments);
            return Point.isCollinear(this.x, this.y, point.x, point.y);
        },
    
        isColinear: '#isCollinear',
    
        isOrthogonal: function() {
            var point = Point.read(arguments);
            return Point.isOrthogonal(this.x, this.y, point.x, point.y);
        },
    
        isZero: function() {
            var isZero = Numerical.isZero;
            return isZero(this.x) && isZero(this.y);
        },
    
        isNaN: function() {
            return isNaN(this.x) || isNaN(this.y);
        },
    
        isInQuadrant: function(q) {
            return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0
                && this.y * (q > 2 ? -1 : 1) >= 0;
        },
    
        dot: function() {
            var point = Point.read(arguments);
            return this.x * point.x + this.y * point.y;
        },
    
        cross: function() {
            var point = Point.read(arguments);
            return this.x * point.y - this.y * point.x;
        },
    
        project: function() {
            var point = Point.read(arguments),
                scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
            return new Point(
                point.x * scale,
                point.y * scale
            );
        },
    
        statics: {
            min: function() {
                var point1 = Point.read(arguments),
                    point2 = Point.read(arguments);
                return new Point(
                    Math.min(point1.x, point2.x),
                    Math.min(point1.y, point2.y)
                );
            },
    
            max: function() {
                var point1 = Point.read(arguments),
                    point2 = Point.read(arguments);
                return new Point(
                    Math.max(point1.x, point2.x),
                    Math.max(point1.y, point2.y)
                );
            },
    
            random: function() {
                return new Point(Math.random(), Math.random());
            },
    
            isCollinear: function(x1, y1, x2, y2) {
                return Math.abs(x1 * y2 - y1 * x2)
                        <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
                            * 1e-8;
            },
    
            isOrthogonal: function(x1, y1, x2, y2) {
                return Math.abs(x1 * x2 + y1 * y2)
                        <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
                            * 1e-8;
            }
        }
    }, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
        var op = Math[key];
        this[key] = function() {
            return new Point(op(this.x), op(this.y));
        };
    }, {}));
    
    var LinkedPoint = Point.extend({
        initialize: function Point(x, y, owner, setter) {
            this._x = x;
            this._y = y;
            this._owner = owner;
            this._setter = setter;
        },
    
        _set: function(x, y, _dontNotify) {
            this._x = x;
            this._y = y;
            if (!_dontNotify)
                this._owner[this._setter](this);
            return this;
        },
    
        getX: function() {
            return this._x;
        },
    
        setX: function(x) {
            this._x = x;
            this._owner[this._setter](this);
        },
    
        getY: function() {
            return this._y;
        },
    
        setY: function(y) {
            this._y = y;
            this._owner[this._setter](this);
        },
    
        isSelected: function() {
            return !!(this._owner._selection & this._getSelection());
        },
    
        setSelected: function(selected) {
            this._owner._changeSelection(this._getSelection(), selected);
        },
    
        _getSelection: function() {
            return this._setter === 'setPosition' ? 4 : 0;
        }
    });
    
    var Size = Base.extend({
        _class: 'Size',
        _readIndex: true,
    
        initialize: function Size(arg0, arg1) {
            var type = typeof arg0,
                reading = this.__read,
                read = 0;
            if (type === 'number') {
                var hasHeight = typeof arg1 === 'number';
                this._set(arg0, hasHeight ? arg1 : arg0);
                if (reading)
                    read = hasHeight ? 2 : 1;
            } else if (type === 'undefined' || arg0 === null) {
                this._set(0, 0);
                if (reading)
                    read = arg0 === null ? 1 : 0;
            } else {
                var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
                read = 1;
                if (Array.isArray(obj)) {
                    this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
                } else if ('width' in obj) {
                    this._set(obj.width || 0, obj.height || 0);
                } else if ('x' in obj) {
                    this._set(obj.x || 0, obj.y || 0);
                } else {
                    this._set(0, 0);
                    read = 0;
                }
            }
            if (reading)
                this.__read = read;
            return this;
        },
    
        set: '#initialize',
    
        _set: function(width, height) {
            this.width = width;
            this.height = height;
            return this;
        },
    
        equals: function(size) {
            return size === this || size && (this.width === size.width
                    && this.height === size.height
                    || Array.isArray(size) && this.width === size[0]
                        && this.height === size[1]) || false;
        },
    
        clone: function() {
            return new Size(this.width, this.height);
        },
    
        toString: function() {
            var f = Formatter.instance;
            return '{ width: ' + f.number(this.width)
                    + ', height: ' + f.number(this.height) + ' }';
        },
    
        _serialize: function(options) {
            var f = options.formatter;
            return [f.number(this.width),
                    f.number(this.height)];
        },
    
        add: function() {
            var size = Size.read(arguments);
            return new Size(this.width + size.width, this.height + size.height);
        },
    
        subtract: function() {
            var size = Size.read(arguments);
            return new Size(this.width - size.width, this.height - size.height);
        },
    
        multiply: function() {
            var size = Size.read(arguments);
            return new Size(this.width * size.width, this.height * size.height);
        },
    
        divide: function() {
            var size = Size.read(arguments);
            return new Size(this.width / size.width, this.height / size.height);
        },
    
        modulo: function() {
            var size = Size.read(arguments);
            return new Size(this.width % size.width, this.height % size.height);
        },
    
        negate: function() {
            return new Size(-this.width, -this.height);
        },
    
        isZero: function() {
            var isZero = Numerical.isZero;
            return isZero(this.width) && isZero(this.height);
        },
    
        isNaN: function() {
            return isNaN(this.width) || isNaN(this.height);
        },
    
        statics: {
            min: function(size1, size2) {
                return new Size(
                    Math.min(size1.width, size2.width),
                    Math.min(size1.height, size2.height));
            },
    
            max: function(size1, size2) {
                return new Size(
                    Math.max(size1.width, size2.width),
                    Math.max(size1.height, size2.height));
            },
    
            random: function() {
                return new Size(Math.random(), Math.random());
            }
        }
    }, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
        var op = Math[key];
        this[key] = function() {
            return new Size(op(this.width), op(this.height));
        };
    }, {}));
    
    var LinkedSize = Size.extend({
        initialize: function Size(width, height, owner, setter) {
            this._width = width;
            this._height = height;
            this._owner = owner;
            this._setter = setter;
        },
    
        _set: function(width, height, _dontNotify) {
            this._width = width;
            this._height = height;
            if (!_dontNotify)
                this._owner[this._setter](this);
            return this;
        },
    
        getWidth: function() {
            return this._width;
        },
    
        setWidth: function(width) {
            this._width = width;
            this._owner[this._setter](this);
        },
    
        getHeight: function() {
            return this._height;
        },
    
        setHeight: function(height) {
            this._height = height;
            this._owner[this._setter](this);
        }
    });
    
    var Rectangle = Base.extend({
        _class: 'Rectangle',
        _readIndex: true,
        beans: true,
    
        initialize: function Rectangle(arg0, arg1, arg2, arg3) {
            var type = typeof arg0,
                read;
            if (type === 'number') {
                this._set(arg0, arg1, arg2, arg3);
                read = 4;
            } else if (type === 'undefined' || arg0 === null) {
                this._set(0, 0, 0, 0);
                read = arg0 === null ? 1 : 0;
            } else if (arguments.length === 1) {
                if (Array.isArray(arg0)) {
                    this._set.apply(this, arg0);
                    read = 1;
                } else if (arg0.x !== undefined || arg0.width !== undefined) {
                    this._set(arg0.x || 0, arg0.y || 0,
                            arg0.width || 0, arg0.height || 0);
                    read = 1;
                } else if (arg0.from === undefined && arg0.to === undefined) {
                    this._set(0, 0, 0, 0);
                    Base.filter(this, arg0);
                    read = 1;
                }
            }
            if (read === undefined) {
                var frm = Point.readNamed(arguments, 'from'),
                    next = Base.peek(arguments),
                    x = frm.x,
                    y = frm.y,
                    width,
                    height;
                if (next && next.x !== undefined
                        || Base.hasNamed(arguments, 'to')) {
                    var to = Point.readNamed(arguments, 'to');
                    width = to.x - x;
                    height = to.y - y;
                    if (width < 0) {
                        x = to.x;
                        width = -width;
                    }
                    if (height < 0) {
                        y = to.y;
                        height = -height;
                    }
                } else {
                    var size = Size.read(arguments);
                    width = size.width;
                    height = size.height;
                }
                this._set(x, y, width, height);
                read = arguments.__index;
                var filtered = arguments.__filtered;
                if (filtered)
                    this.__filtered = filtered;
            }
            if (this.__read)
                this.__read = read;
            return this;
        },
    
        set: '#initialize',
    
        _set: function(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        },
    
        clone: function() {
            return new Rectangle(this.x, this.y, this.width, this.height);
        },
    
        equals: function(rect) {
            var rt = Base.isPlainValue(rect)
                    ? Rectangle.read(arguments)
                    : rect;
            return rt === this
                    || rt && this.x === rt.x && this.y === rt.y
                        && this.width === rt.width && this.height === rt.height
                    || false;
        },
    
        toString: function() {
            var f = Formatter.instance;
            return '{ x: ' + f.number(this.x)
                    + ', y: ' + f.number(this.y)
                    + ', width: ' + f.number(this.width)
                    + ', height: ' + f.number(this.height)
                    + ' }';
        },
    
        _serialize: function(options) {
            var f = options.formatter;
            return [f.number(this.x),
                    f.number(this.y),
                    f.number(this.width),
                    f.number(this.height)];
        },
    
        getPoint: function(_dontLink) {
            var ctor = _dontLink ? Point : LinkedPoint;
            return new ctor(this.x, this.y, this, 'setPoint');
        },
    
        setPoint: function() {
            var point = Point.read(arguments);
            this.x = point.x;
            this.y = point.y;
        },
    
        getSize: function(_dontLink) {
            var ctor = _dontLink ? Size : LinkedSize;
            return new ctor(this.width, this.height, this, 'setSize');
        },
    
        _fw: 1,
        _fh: 1,
    
        setSize: function() {
            var size = Size.read(arguments),
                sx = this._sx,
                sy = this._sy,
                w = size.width,
                h = size.height;
            if (sx) {
                this.x += (this.width - w) * sx;
            }
            if (sy) {
                this.y += (this.height - h) * sy;
            }
            this.width = w;
            this.height = h;
            this._fw = this._fh = 1;
        },
    
        getLeft: function() {
            return this.x;
        },
    
        setLeft: function(left) {
            if (!this._fw) {
                var amount = left - this.x;
                this.width -= this._sx === 0.5 ? amount * 2 : amount;
            }
            this.x = left;
            this._sx = this._fw = 0;
        },
    
        getTop: function() {
            return this.y;
        },
    
        setTop: function(top) {
            if (!this._fh) {
                var amount = top - this.y;
                this.height -= this._sy === 0.5 ? amount * 2 : amount;
            }
            this.y = top;
            this._sy = this._fh = 0;
        },
    
        getRight: function() {
            return this.x + this.width;
        },
    
        setRight: function(right) {
            if (!this._fw) {
                var amount = right - this.x;
                this.width = this._sx === 0.5 ? amount * 2 : amount;
            }
            this.x = right - this.width;
            this._sx = 1;
            this._fw = 0;
        },
    
        getBottom: function() {
            return this.y + this.height;
        },
    
        setBottom: function(bottom) {
            if (!this._fh) {
                var amount = bottom - this.y;
                this.height = this._sy === 0.5 ? amount * 2 : amount;
            }
            this.y = bottom - this.height;
            this._sy = 1;
            this._fh = 0;
        },
    
        getCenterX: function() {
            return this.x + this.width / 2;
        },
    
        setCenterX: function(x) {
            if (this._fw || this._sx === 0.5) {
                this.x = x - this.width / 2;
            } else {
                if (this._sx) {
                    this.x += (x - this.x) * 2 * this._sx;
                }
                this.width = (x - this.x) * 2;
            }
            this._sx = 0.5;
            this._fw = 0;
        },
    
        getCenterY: function() {
            return this.y + this.height / 2;
        },
    
        setCenterY: function(y) {
            if (this._fh || this._sy === 0.5) {
                this.y = y - this.height / 2;
            } else {
                if (this._sy) {
                    this.y += (y - this.y) * 2 * this._sy;
                }
                this.height = (y - this.y) * 2;
            }
            this._sy = 0.5;
            this._fh = 0;
        },
    
        getCenter: function(_dontLink) {
            var ctor = _dontLink ? Point : LinkedPoint;
            return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
        },
    
        setCenter: function() {
            var point = Point.read(arguments);
            this.setCenterX(point.x);
            this.setCenterY(point.y);
            return this;
        },
    
        getArea: function() {
            return this.width * this.height;
        },
    
        isEmpty: function() {
            return this.width === 0 || this.height === 0;
        },
    
        contains: function(arg) {
            return arg && arg.width !== undefined
                    || (Array.isArray(arg) ? arg : arguments).length === 4
                    ? this._containsRectangle(Rectangle.read(arguments))
                    : this._containsPoint(Point.read(arguments));
        },
    
        _containsPoint: function(point) {
            var x = point.x,
                y = point.y;
            return x >= this.x && y >= this.y
                    && x <= this.x + this.width
                    && y <= this.y + this.height;
        },
    
        _containsRectangle: function(rect) {
            var x = rect.x,
                y = rect.y;
            return x >= this.x && y >= this.y
                    && x + rect.width <= this.x + this.width
                    && y + rect.height <= this.y + this.height;
        },
    
        intersects: function() {
            var rect = Rectangle.read(arguments),
                epsilon = Base.read(arguments) || 0;
            return rect.x + rect.width > this.x - epsilon
                    && rect.y + rect.height > this.y - epsilon
                    && rect.x < this.x + this.width + epsilon
                    && rect.y < this.y + this.height + epsilon;
        },
    
        intersect: function() {
            var rect = Rectangle.read(arguments),
                x1 = Math.max(this.x, rect.x),
                y1 = Math.max(this.y, rect.y),
                x2 = Math.min(this.x + this.width, rect.x + rect.width),
                y2 = Math.min(this.y + this.height, rect.y + rect.height);
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        },
    
        unite: function() {
            var rect = Rectangle.read(arguments),
                x1 = Math.min(this.x, rect.x),
                y1 = Math.min(this.y, rect.y),
                x2 = Math.max(this.x + this.width, rect.x + rect.width),
                y2 = Math.max(this.y + this.height, rect.y + rect.height);
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        },
    
        include: function() {
            var point = Point.read(arguments);
            var x1 = Math.min(this.x, point.x),
                y1 = Math.min(this.y, point.y),
                x2 = Math.max(this.x + this.width, point.x),
                y2 = Math.max(this.y + this.height, point.y);
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        },
    
        expand: function() {
            var amount = Size.read(arguments),
                hor = amount.width,
                ver = amount.height;
            return new Rectangle(this.x - hor / 2, this.y - ver / 2,
                    this.width + hor, this.height + ver);
        },
    
        scale: function(hor, ver) {
            return this.expand(this.width * hor - this.width,
                    this.height * (ver === undefined ? hor : ver) - this.height);
        }
    }, Base.each([
            ['Top', 'Left'], ['Top', 'Right'],
            ['Bottom', 'Left'], ['Bottom', 'Right'],
            ['Left', 'Center'], ['Top', 'Center'],
            ['Right', 'Center'], ['Bottom', 'Center']
        ],
        function(parts, index) {
            var part = parts.join(''),
                xFirst = /^[RL]/.test(part);
            if (index >= 4)
                parts[1] += xFirst ? 'Y' : 'X';
            var x = parts[xFirst ? 0 : 1],
                y = parts[xFirst ? 1 : 0],
                getX = 'get' + x,
                getY = 'get' + y,
                setX = 'set' + x,
                setY = 'set' + y,
                get = 'get' + part,
                set = 'set' + part;
            this[get] = function(_dontLink) {
                var ctor = _dontLink ? Point : LinkedPoint;
                return new ctor(this[getX](), this[getY](), this, set);
            };
            this[set] = function() {
                var point = Point.read(arguments);
                this[setX](point.x);
                this[setY](point.y);
            };
        }, {
            beans: true
        }
    ));
    
    var LinkedRectangle = Rectangle.extend({
        initialize: function Rectangle(x, y, width, height, owner, setter) {
            this._set(x, y, width, height, true);
            this._owner = owner;
            this._setter = setter;
        },
    
        _set: function(x, y, width, height, _dontNotify) {
            this._x = x;
            this._y = y;
            this._width = width;
            this._height = height;
            if (!_dontNotify)
                this._owner[this._setter](this);
            return this;
        }
    },
    new function() {
        var proto = Rectangle.prototype;
    
        return Base.each(['x', 'y', 'width', 'height'], function(key) {
            var part = Base.capitalize(key),
                internal = '_' + key;
            this['get' + part] = function() {
                return this[internal];
            };
    
            this['set' + part] = function(value) {
                this[internal] = value;
                if (!this._dontNotify)
                    this._owner[this._setter](this);
            };
        }, Base.each(['Point', 'Size', 'Center',
                'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
                'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
                'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
            function(key) {
                var name = 'set' + key;
                this[name] = function() {
                    this._dontNotify = true;
                    proto[name].apply(this, arguments);
                    this._dontNotify = false;
                    this._owner[this._setter](this);
                };
            }, {
                isSelected: function() {
                    return !!(this._owner._selection & 2);
                },
    
                setSelected: function(selected) {
                    var owner = this._owner;
                    if (owner._changeSelection) {
                        owner._changeSelection(2, selected);
                    }
                }
            })
        );
    });
    
    var Matrix = Base.extend({
        _class: 'Matrix',
    
        initialize: function Matrix(arg, _dontNotify) {
            var count = arguments.length,
                ok = true;
            if (count >= 6) {
                this._set.apply(this, arguments);
            } else if (count === 1 || count === 2) {
                if (arg instanceof Matrix) {
                    this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,
                            _dontNotify);
                } else if (Array.isArray(arg)) {
                    this._set.apply(this,
                            _dontNotify ? arg.concat([_dontNotify]) : arg);
                } else {
                    ok = false;
                }
            } else if (!count) {
                this.reset();
            } else {
                ok = false;
            }
            if (!ok) {
                throw new Error('Unsupported matrix parameters');
            }
            return this;
        },
    
        set: '#initialize',
    
        _set: function(a, b, c, d, tx, ty, _dontNotify) {
            this._a = a;
            this._b = b;
            this._c = c;
            this._d = d;
            this._tx = tx;
            this._ty = ty;
            if (!_dontNotify)
                this._changed();
            return this;
        },
    
        _serialize: function(options, dictionary) {
            return Base.serialize(this.getValues(), options, true, dictionary);
        },
    
        _changed: function() {
            var owner = this._owner;
            if (owner) {
                if (owner._applyMatrix) {
                    owner.transform(null, true);
                } else {
                    owner._changed(9);
                }
            }
        },
    
        clone: function() {
            return new Matrix(this._a, this._b, this._c, this._d,
                    this._tx, this._ty);
        },
    
        equals: function(mx) {
            return mx === this || mx && this._a === mx._a && this._b === mx._b
                    && this._c === mx._c && this._d === mx._d
                    && this._tx === mx._tx && this._ty === mx._ty;
        },
    
        toString: function() {
            var f = Formatter.instance;
            return '[[' + [f.number(this._a), f.number(this._c),
                        f.number(this._tx)].join(', ') + '], ['
                    + [f.number(this._b), f.number(this._d),
                        f.number(this._ty)].join(', ') + ']]';
        },
    
        reset: function(_dontNotify) {
            this._a = this._d = 1;
            this._b = this._c = this._tx = this._ty = 0;
            if (!_dontNotify)
                this._changed();
            return this;
        },
    
        apply: function(recursively, _setApplyMatrix) {
            var owner = this._owner;
            if (owner) {
                owner.transform(null, true, Base.pick(recursively, true),
                        _setApplyMatrix);
                return this.isIdentity();
            }
            return false;
        },
    
        translate: function() {
            var point = Point.read(arguments),
                x = point.x,
                y = point.y;
            this._tx += x * this._a + y * this._c;
            this._ty += x * this._b + y * this._d;
            this._changed();
            return this;
        },
    
        scale: function() {
            var scale = Point.read(arguments),
                center = Point.read(arguments, 0, { readNull: true });
            if (center)
                this.translate(center);
            this._a *= scale.x;
            this._b *= scale.x;
            this._c *= scale.y;
            this._d *= scale.y;
            if (center)
                this.translate(center.negate());
            this._changed();
            return this;
        },
    
        rotate: function(angle ) {
            angle *= Math.PI / 180;
            var center = Point.read(arguments, 1),
                x = center.x,
                y = center.y,
                cos = Math.cos(angle),
                sin = Math.sin(angle),
                tx = x - x * cos + y * sin,
                ty = y - x * sin - y * cos,
                a = this._a,
                b = this._b,
                c = this._c,
                d = this._d;
            this._a = cos * a + sin * c;
            this._b = cos * b + sin * d;
            this._c = -sin * a + cos * c;
            this._d = -sin * b + cos * d;
            this._tx += tx * a + ty * c;
            this._ty += tx * b + ty * d;
            this._changed();
            return this;
        },
    
        shear: function() {
            var shear = Point.read(arguments),
                center = Point.read(arguments, 0, { readNull: true });
            if (center)
                this.translate(center);
            var a = this._a,
                b = this._b;
            this._a += shear.y * this._c;
            this._b += shear.y * this._d;
            this._c += shear.x * a;
            this._d += shear.x * b;
            if (center)
                this.translate(center.negate());
            this._changed();
            return this;
        },
    
        skew: function() {
            var skew = Point.read(arguments),
                center = Point.read(arguments, 0, { readNull: true }),
                toRadians = Math.PI / 180,
                shear = new Point(Math.tan(skew.x * toRadians),
                    Math.tan(skew.y * toRadians));
            return this.shear(shear, center);
        },
    
        append: function(mx, _dontNotify) {
            if (mx) {
                var a1 = this._a,
                    b1 = this._b,
                    c1 = this._c,
                    d1 = this._d,
                    a2 = mx._a,
                    b2 = mx._c,
                    c2 = mx._b,
                    d2 = mx._d,
                    tx2 = mx._tx,
                    ty2 = mx._ty;
                this._a = a2 * a1 + c2 * c1;
                this._c = b2 * a1 + d2 * c1;
                this._b = a2 * b1 + c2 * d1;
                this._d = b2 * b1 + d2 * d1;
                this._tx += tx2 * a1 + ty2 * c1;
                this._ty += tx2 * b1 + ty2 * d1;
                if (!_dontNotify)
                    this._changed();
            }
            return this;
        },
    
        prepend: function(mx, _dontNotify) {
            if (mx) {
                var a1 = this._a,
                    b1 = this._b,
                    c1 = this._c,
                    d1 = this._d,
                    tx1 = this._tx,
                    ty1 = this._ty,
                    a2 = mx._a,
                    b2 = mx._c,
                    c2 = mx._b,
                    d2 = mx._d,
                    tx2 = mx._tx,
                    ty2 = mx._ty;
                this._a = a2 * a1 + b2 * b1;
                this._c = a2 * c1 + b2 * d1;
                this._b = c2 * a1 + d2 * b1;
                this._d = c2 * c1 + d2 * d1;
                this._tx = a2 * tx1 + b2 * ty1 + tx2;
                this._ty = c2 * tx1 + d2 * ty1 + ty2;
                if (!_dontNotify)
                    this._changed();
            }
            return this;
        },
    
        appended: function(mx) {
            return this.clone().append(mx);
        },
    
        prepended: function(mx) {
            return this.clone().prepend(mx);
        },
    
        invert: function() {
            var a = this._a,
                b = this._b,
                c = this._c,
                d = this._d,
                tx = this._tx,
                ty = this._ty,
                det = a * d - b * c,
                res = null;
            if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
                this._a = d / det;
                this._b = -b / det;
                this._c = -c / det;
                this._d = a / det;
                this._tx = (c * ty - d * tx) / det;
                this._ty = (b * tx - a * ty) / det;
                res = this;
            }
            return res;
        },
    
        inverted: function() {
            return this.clone().invert();
        },
    
        concatenate: '#append',
        preConcatenate: '#prepend',
        chain: '#appended',
    
        _shiftless: function() {
            return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
        },
    
        _orNullIfIdentity: function() {
            return this.isIdentity() ? null : this;
        },
    
        isIdentity: function() {
            return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1
                    && this._tx === 0 && this._ty === 0;
        },
    
        isInvertible: function() {
            var det = this._a * this._d - this._c * this._b;
            return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
        },
    
        isSingular: function() {
            return !this.isInvertible();
        },
    
        transform: function( src, dst, count) {
            return arguments.length < 3
                ? this._transformPoint(Point.read(arguments))
                : this._transformCoordinates(src, dst, count);
        },
    
        _transformPoint: function(point, dest, _dontNotify) {
            var x = point.x,
                y = point.y;
            if (!dest)
                dest = new Point();
            return dest._set(
                    x * this._a + y * this._c + this._tx,
                    x * this._b + y * this._d + this._ty,
                    _dontNotify);
        },
    
        _transformCoordinates: function(src, dst, count) {
            for (var i = 0, max = 2 * count; i < max; i += 2) {
                var x = src[i],
                    y = src[i + 1];
                dst[i] = x * this._a + y * this._c + this._tx;
                dst[i + 1] = x * this._b + y * this._d + this._ty;
            }
            return dst;
        },
    
        _transformCorners: function(rect) {
            var x1 = rect.x,
                y1 = rect.y,
                x2 = x1 + rect.width,
                y2 = y1 + rect.height,
                coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
            return this._transformCoordinates(coords, coords, 4);
        },
    
        _transformBounds: function(bounds, dest, _dontNotify) {
            var coords = this._transformCorners(bounds),
                min = coords.slice(0, 2),
                max = min.slice();
            for (var i = 2; i < 8; i++) {
                var val = coords[i],
                    j = i & 1;
                if (val < min[j]) {
                    min[j] = val;
                } else if (val > max[j]) {
                    max[j] = val;
                }
            }
            if (!dest)
                dest = new Rectangle();
            return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],
                    _dontNotify);
        },
    
        inverseTransform: function() {
            return this._inverseTransform(Point.read(arguments));
        },
    
        _inverseTransform: function(point, dest, _dontNotify) {
            var a = this._a,
                b = this._b,
                c = this._c,
                d = this._d,
                tx = this._tx,
                ty = this._ty,
                det = a * d - b * c,
                res = null;
            if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
                var x = point.x - this._tx,
                    y = point.y - this._ty;
                if (!dest)
                    dest = new Point();
                res = dest._set(
                        (x * d - y * c) / det,
                        (y * a - x * b) / det,
                        _dontNotify);
            }
            return res;
        },
    
        decompose: function() {
            var a = this._a,
                b = this._b,
                c = this._c,
                d = this._d,
                det = a * d - b * c,
                sqrt = Math.sqrt,
                atan2 = Math.atan2,
                degrees = 180 / Math.PI,
                rotate,
                scale,
                skew;
            if (a !== 0 || b !== 0) {
                var r = sqrt(a * a + b * b);
                rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
                scale = [r, det / r];
                skew = [atan2(a * c + b * d, r * r), 0];
            } else if (c !== 0 || d !== 0) {
                var s = sqrt(c * c + d * d);
                rotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);
                scale = [det / s, s];
                skew = [0, atan2(a * c + b * d, s * s)];
            } else {
                rotate = 0;
                skew = scale = [0, 0];
            }
            return {
                translation: this.getTranslation(),
                rotation: rotate * degrees,
                scaling: new Point(scale),
                skewing: new Point(skew[0] * degrees, skew[1] * degrees)
            };
        },
    
        getValues: function() {
            return [ this._a, this._b, this._c, this._d, this._tx, this._ty ];
        },
    
        getTranslation: function() {
            return new Point(this._tx, this._ty);
        },
    
        getScaling: function() {
            return (this.decompose() || {}).scaling;
        },
    
        getRotation: function() {
            return (this.decompose() || {}).rotation;
        },
    
        applyToContext: function(ctx) {
            if (!this.isIdentity()) {
                ctx.transform(this._a, this._b, this._c, this._d,
                        this._tx, this._ty);
            }
        }
    }, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {
        var part = Base.capitalize(key),
            prop = '_' + key;
        this['get' + part] = function() {
            return this[prop];
        };
        this['set' + part] = function(value) {
            this[prop] = value;
            this._changed();
        };
    }, {}));
    
    var Line = Base.extend({
        _class: 'Line',
    
        initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
            var asVector = false;
            if (arguments.length >= 4) {
                this._px = arg0;
                this._py = arg1;
                this._vx = arg2;
                this._vy = arg3;
                asVector = arg4;
            } else {
                this._px = arg0.x;
                this._py = arg0.y;
                this._vx = arg1.x;
                this._vy = arg1.y;
                asVector = arg2;
            }
            if (!asVector) {
                this._vx -= this._px;
                this._vy -= this._py;
            }
        },
    
        getPoint: function() {
            return new Point(this._px, this._py);
        },
    
        getVector: function() {
            return new Point(this._vx, this._vy);
        },
    
        getLength: function() {
            return this.getVector().getLength();
        },
    
        intersect: function(line, isInfinite) {
            return Line.intersect(
                    this._px, this._py, this._vx, this._vy,
                    line._px, line._py, line._vx, line._vy,
                    true, isInfinite);
        },
    
        getSide: function(point, isInfinite) {
            return Line.getSide(
                    this._px, this._py, this._vx, this._vy,
                    point.x, point.y, true, isInfinite);
        },
    
        getDistance: function(point) {
            return Math.abs(this.getSignedDistance(point));
        },
    
        getSignedDistance: function(point) {
            return Line.getSignedDistance(this._px, this._py, this._vx, this._vy,
                    point.x, point.y, true);
        },
    
        isCollinear: function(line) {
            return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
        },
    
        isOrthogonal: function(line) {
            return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
        },
    
        statics: {
            intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
                    isInfinite) {
                if (!asVector) {
                    v1x -= p1x;
                    v1y -= p1y;
                    v2x -= p2x;
                    v2y -= p2y;
                }
                var cross = v1x * v2y - v1y * v2x;
                if (!Numerical.isZero(cross)) {
                    var dx = p1x - p2x,
                        dy = p1y - p2y,
                        u1 = (v2x * dy - v2y * dx) / cross,
                        u2 = (v1x * dy - v1y * dx) / cross,
                        epsilon = 1e-12,
                        uMin = -epsilon,
                        uMax = 1 + epsilon;
                    if (isInfinite
                            || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
                        if (!isInfinite) {
                            u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
                        }
                        return new Point(
                                p1x + u1 * v1x,
                                p1y + u1 * v1y);
                    }
                }
            },
    
            getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
                if (!asVector) {
                    vx -= px;
                    vy -= py;
                }
                var v2x = x - px,
                    v2y = y - py,
                    ccw = v2x * vy - v2y * vx;
                if (!isInfinite && Numerical.isZero(ccw)) {
                    ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
                    if (ccw >= 0 && ccw <= 1)
                        ccw = 0;
                }
                return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
            },
    
            getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
                if (!asVector) {
                    vx -= px;
                    vy -= py;
                }
                return vx === 0 ? vy > 0 ? x - px : px - x
                     : vy === 0 ? vx < 0 ? y - py : py - y
                     : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);
            },
    
            getDistance: function(px, py, vx, vy, x, y, asVector) {
                return Math.abs(
                        Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
            }
        }
    });
    
    var Project = PaperScopeItem.extend({
        _class: 'Project',
        _list: 'projects',
        _reference: 'project',
        _compactSerialize: true,
    
        initialize: function Project(element) {
            PaperScopeItem.call(this, true);
            this._children = [];
            this._namedChildren = {};
            this._activeLayer = null;
            this._currentStyle = new Style(null, null, this);
            this._view = View.create(this,
                    element || CanvasProvider.getCanvas(1, 1));
            this._selectionItems = {};
            this._selectionCount = 0;
            this._updateVersion = 0;
        },
    
        _serialize: function(options, dictionary) {
            return Base.serialize(this._children, options, true, dictionary);
        },
    
        _changed: function(flags, item) {
            if (flags & 1) {
                var view = this._view;
                if (view) {
                    view._needsUpdate = true;
                    if (!view._requested && view._autoUpdate)
                        view.requestUpdate();
                }
            }
            var changes = this._changes;
            if (changes && item) {
                var changesById = this._changesById,
                    id = item._id,
                    entry = changesById[id];
                if (entry) {
                    entry.flags |= flags;
                } else {
                    changes.push(changesById[id] = { item: item, flags: flags });
                }
            }
        },
    
        clear: function() {
            var children = this._children;
            for (var i = children.length - 1; i >= 0; i--)
                children[i].remove();
        },
    
        isEmpty: function() {
            return !this._children.length;
        },
    
        remove: function remove() {
            if (!remove.base.call(this))
                return false;
            if (this._view)
                this._view.remove();
            return true;
        },
    
        getView: function() {
            return this._view;
        },
    
        getCurrentStyle: function() {
            return this._currentStyle;
        },
    
        setCurrentStyle: function(style) {
            this._currentStyle.set(style);
        },
    
        getIndex: function() {
            return this._index;
        },
    
        getOptions: function() {
            return this._scope.settings;
        },
    
        getLayers: function() {
            return this._children;
        },
    
        getActiveLayer: function() {
            return this._activeLayer || new Layer({ project: this, insert: true });
        },
    
        getSymbolDefinitions: function() {
            var definitions = [],
                ids = {};
            this.getItems({
                class: SymbolItem,
                match: function(item) {
                    var definition = item._definition,
                        id = definition._id;
                    if (!ids[id]) {
                        ids[id] = true;
                        definitions.push(definition);
                    }
                    return false;
                }
            });
            return definitions;
        },
    
        getSymbols: 'getSymbolDefinitions',
    
        getSelectedItems: function() {
            var selectionItems = this._selectionItems,
                items = [];
            for (var id in selectionItems) {
                var item = selectionItems[id],
                    selection = item._selection;
                if ((selection & 1) && item.isInserted()) {
                    items.push(item);
                } else if (!selection) {
                    this._updateSelection(item);
                }
            }
            return items;
        },
    
        _updateSelection: function(item) {
            var id = item._id,
                selectionItems = this._selectionItems;
            if (item._selection) {
                if (selectionItems[id] !== item) {
                    this._selectionCount++;
                    selectionItems[id] = item;
                }
            } else if (selectionItems[id] === item) {
                this._selectionCount--;
                delete selectionItems[id];
            }
        },
    
        selectAll: function() {
            var children = this._children;
            for (var i = 0, l = children.length; i < l; i++)
                children[i].setFullySelected(true);
        },
    
        deselectAll: function() {
            var selectionItems = this._selectionItems;
            for (var i in selectionItems)
                selectionItems[i].setFullySelected(false);
        },
    
        addLayer: function(layer) {
            return this.insertLayer(undefined, layer);
        },
    
        insertLayer: function(index, layer) {
            if (layer instanceof Layer) {
                layer._remove(false, true);
                Base.splice(this._children, [layer], index, 0);
                layer._setProject(this, true);
                var name = layer._name;
                if (name)
                    layer.setName(name);
                if (this._changes)
                    layer._changed(5);
                if (!this._activeLayer)
                    this._activeLayer = layer;
            } else {
                layer = null;
            }
            return layer;
        },
    
        _insertItem: function(index, item, _created) {
            item = this.insertLayer(index, item)
                    || (this._activeLayer || this._insertItem(undefined,
                            new Layer(Item.NO_INSERT), true))
                            .insertChild(index, item);
            if (_created && item.activate)
                item.activate();
            return item;
        },
    
        getItems: function(options) {
            return Item._getItems(this, options);
        },
    
        getItem: function(options) {
            return Item._getItems(this, options, null, null, true)[0] || null;
        },
    
        importJSON: function(json) {
            this.activate();
            var layer = this._activeLayer;
            return Base.importJSON(json, layer && layer.isEmpty() && layer);
        },
    
        removeOn: function(type) {
            var sets = this._removeSets;
            if (sets) {
                if (type === 'mouseup')
                    sets.mousedrag = null;
                var set = sets[type];
                if (set) {
                    for (var id in set) {
                        var item = set[id];
                        for (var key in sets) {
                            var other = sets[key];
                            if (other && other != set)
                                delete other[item._id];
                        }
                        item.remove();
                    }
                    sets[type] = null;
                }
            }
        },
    
        draw: function(ctx, matrix, pixelRatio) {
            this._updateVersion++;
            ctx.save();
            matrix.applyToContext(ctx);
            var children = this._children,
                param = new Base({
                    offset: new Point(0, 0),
                    pixelRatio: pixelRatio,
                    viewMatrix: matrix.isIdentity() ? null : matrix,
                    matrices: [new Matrix()],
                    updateMatrix: true
                });
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].draw(ctx, param);
            }
            ctx.restore();
    
            if (this._selectionCount > 0) {
                ctx.save();
                ctx.strokeWidth = 1;
                var items = this._selectionItems,
                    size = this._scope.settings.handleSize,
                    version = this._updateVersion;
                for (var id in items) {
                    items[id]._drawSelection(ctx, matrix, size, items, version);
                }
                ctx.restore();
            }
        }
    });
    
    var Item = Base.extend(Emitter, {
        statics: {
            extend: function extend(src) {
                if (src._serializeFields)
                    src._serializeFields = Base.set({},
                        this.prototype._serializeFields, src._serializeFields);
                return extend.base.apply(this, arguments);
            },
    
            NO_INSERT: { insert: false }
        },
    
        _class: 'Item',
        _name: null,
        _applyMatrix: true,
        _canApplyMatrix: true,
        _canScaleStroke: false,
        _pivot: null,
        _visible: true,
        _blendMode: 'normal',
        _opacity: 1,
        _locked: false,
        _guide: false,
        _clipMask: false,
        _selection: 0,
        _selectBounds: true,
        _selectChildren: false,
        _serializeFields: {
            name: null,
            applyMatrix: null,
            matrix: new Matrix(),
            pivot: null,
            visible: true,
            blendMode: 'normal',
            opacity: 1,
            locked: false,
            guide: false,
            clipMask: false,
            selected: false,
            data: {}
        },
        _prioritize: ['applyMatrix']
    },
    new function() {
        var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
                'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
        return Base.each(handlers,
            function(name) {
                this._events[name] = {
                    install: function(type) {
                        this.getView()._countItemEvent(type, 1);
                    },
    
                    uninstall: function(type) {
                        this.getView()._countItemEvent(type, -1);
                    }
                };
            }, {
                _events: {
                    onFrame: {
                        install: function() {
                            this.getView()._animateItem(this, true);
                        },
    
                        uninstall: function() {
                            this.getView()._animateItem(this, false);
                        }
                    },
    
                    onLoad: {},
                    onError: {}
                },
                statics: {
                    _itemHandlers: handlers
                }
            }
        );
    }, {
        initialize: function Item() {
        },
    
        _initialize: function(props, point) {
            var hasProps = props && Base.isPlainObject(props),
                internal = hasProps && props.internal === true,
                matrix = this._matrix = new Matrix(),
                project = hasProps && props.project || paper.project,
                settings = paper.settings;
            this._id = internal ? null : UID.get();
            this._parent = this._index = null;
            this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
            if (point)
                matrix.translate(point);
            matrix._owner = this;
            this._style = new Style(project._currentStyle, this, project);
            if (internal || hasProps && props.insert == false
                || !settings.insertItems && !(hasProps && props.insert === true)) {
                this._setProject(project);
            } else {
                (hasProps && props.parent || project)
                        ._insertItem(undefined, this, true);
            }
            if (hasProps && props !== Item.NO_INSERT) {
                this.set(props, {
                    internal: true, insert: true, project: true, parent: true
                });
            }
            return hasProps;
        },
    
        _serialize: function(options, dictionary) {
            var props = {},
                that = this;
    
            function serialize(fields) {
                for (var key in fields) {
                    var value = that[key];
                    if (!Base.equals(value, key === 'leading'
                            ? fields.fontSize * 1.2 : fields[key])) {
                        props[key] = Base.serialize(value, options,
                                key !== 'data', dictionary);
                    }
                }
            }
    
            serialize(this._serializeFields);
            if (!(this instanceof Group))
                serialize(this._style._defaults);
            return [ this._class, props ];
        },
    
        _changed: function(flags) {
            var symbol = this._symbol,
                cacheParent = this._parent || symbol,
                project = this._project;
            if (flags & 8) {
                this._bounds = this._position = this._decomposed =
                        this._globalMatrix = undefined;
            }
            if (cacheParent
                    && (flags & 40)) {
                Item._clearBoundsCache(cacheParent);
            }
            if (flags & 2) {
                Item._clearBoundsCache(this);
            }
            if (project)
                project._changed(flags, this);
            if (symbol)
                symbol._changed(flags);
        },
    
        getId: function() {
            return this._id;
        },
    
        getName: function() {
            return this._name;
        },
    
        setName: function(name) {
    
            if (this._name)
                this._removeNamed();
            if (name === (+name) + '')
                throw new Error(
                        'Names consisting only of numbers are not supported.');
            var owner = this._getOwner();
            if (name && owner) {
                var children = owner._children,
                    namedChildren = owner._namedChildren;
                (namedChildren[name] = namedChildren[name] || []).push(this);
                if (!(name in children))
                    children[name] = this;
            }
            this._name = name || undefined;
            this._changed(128);
        },
    
        getStyle: function() {
            return this._style;
        },
    
        setStyle: function(style) {
            this.getStyle().set(style);
        }
    }, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
        function(name) {
            var part = Base.capitalize(name),
                key = '_' + name,
                flags = {
                    locked: 128,
                    visible: 137
                };
            this['get' + part] = function() {
                return this[key];
            };
            this['set' + part] = function(value) {
                if (value != this[key]) {
                    this[key] = value;
                    this._changed(flags[name] || 129);
                }
            };
        },
    {}), {
        beans: true,
    
        getSelection: function() {
            return this._selection;
        },
    
        setSelection: function(selection) {
            if (selection !== this._selection) {
                this._selection = selection;
                var project = this._project;
                if (project) {
                    project._updateSelection(this);
                    this._changed(129);
                }
            }
        },
    
        _changeSelection: function(flag, selected) {
            var selection = this._selection;
            this.setSelection(selected ? selection | flag : selection & ~flag);
        },
    
        isSelected: function() {
            if (this._selectChildren) {
                var children = this._children;
                for (var i = 0, l = children.length; i < l; i++)
                    if (children[i].isSelected())
                        return true;
            }
            return !!(this._selection & 1);
        },
    
        setSelected: function(selected) {
            if (this._selectChildren) {
                var children = this._children;
                for (var i = 0, l = children.length; i < l; i++)
                    children[i].setSelected(selected);
            }
            this._changeSelection(1, selected);
        },
    
        isFullySelected: function() {
            var children = this._children,
                selected = !!(this._selection & 1);
            if (children && selected) {
                for (var i = 0, l = children.length; i < l; i++)
                    if (!children[i].isFullySelected())
                        return false;
                return true;
            }
            return selected;
        },
    
        setFullySelected: function(selected) {
            var children = this._children;
            if (children) {
                for (var i = 0, l = children.length; i < l; i++)
                    children[i].setFullySelected(selected);
            }
            this._changeSelection(1, selected);
        },
    
        isClipMask: function() {
            return this._clipMask;
        },
    
        setClipMask: function(clipMask) {
            if (this._clipMask != (clipMask = !!clipMask)) {
                this._clipMask = clipMask;
                if (clipMask) {
                    this.setFillColor(null);
                    this.setStrokeColor(null);
                }
                this._changed(129);
                if (this._parent)
                    this._parent._changed(1024);
            }
        },
    
        getData: function() {
            if (!this._data)
                this._data = {};
            return this._data;
        },
    
        setData: function(data) {
            this._data = data;
        },
    
        getPosition: function(_dontLink) {
            var position = this._position,
                ctor = _dontLink ? Point : LinkedPoint;
            if (!position) {
                var pivot = this._pivot;
                position = this._position = pivot
                        ? this._matrix._transformPoint(pivot)
                        : this.getBounds().getCenter(true);
            }
            return new ctor(position.x, position.y, this, 'setPosition');
        },
    
        setPosition: function() {
            this.translate(Point.read(arguments).subtract(this.getPosition(true)));
        },
    
        getPivot: function() {
            var pivot = this._pivot;
            return pivot
                    ? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')
                    : null;
        },
    
        setPivot: function() {
            this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
            this._position = undefined;
        }
    }, Base.each({
            getStrokeBounds: { stroke: true },
            getHandleBounds: { handle: true },
            getInternalBounds: { internal: true }
        },
        function(options, key) {
            this[key] = function(matrix) {
                return this.getBounds(matrix, options);
            };
        },
    {
        beans: true,
    
        getBounds: function(matrix, options) {
            var hasMatrix = options || matrix instanceof Matrix,
                opts = Base.set({}, hasMatrix ? options : matrix,
                        this._boundsOptions);
            if (!opts.stroke || this.getStrokeScaling())
                opts.cacheItem = this;
            var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;
            return !arguments.length
                    ? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,
                        this, 'setBounds')
                    : rect;
        },
    
        setBounds: function() {
            var rect = Rectangle.read(arguments),
                bounds = this.getBounds(),
                _matrix = this._matrix,
                matrix = new Matrix(),
                center = rect.getCenter();
            matrix.translate(center);
            if (rect.width != bounds.width || rect.height != bounds.height) {
                if (!_matrix.isInvertible()) {
                    _matrix.set(_matrix._backup
                            || new Matrix().translate(_matrix.getTranslation()));
                    bounds = this.getBounds();
                }
                matrix.scale(
                        bounds.width !== 0 ? rect.width / bounds.width : 0,
                        bounds.height !== 0 ? rect.height / bounds.height : 0);
            }
            center = bounds.getCenter();
            matrix.translate(-center.x, -center.y);
            this.transform(matrix);
        },
    
        _getBounds: function(matrix, options) {
            var children = this._children;
            if (!children || !children.length)
                return new Rectangle();
            Item._updateBoundsCache(this, options.cacheItem);
            return Item._getBounds(children, matrix, options);
        },
    
        _getBoundsCacheKey: function(options, internal) {
            return [
                options.stroke ? 1 : 0,
                options.handle ? 1 : 0,
                internal ? 1 : 0
            ].join('');
        },
    
        _getCachedBounds: function(matrix, options, noInternal) {
            matrix = matrix && matrix._orNullIfIdentity();
            var internal = options.internal && !noInternal,
                cacheItem = options.cacheItem,
                _matrix = internal ? null : this._matrix._orNullIfIdentity(),
                cacheKey = cacheItem && (!matrix || matrix.equals(_matrix))
                    && this._getBoundsCacheKey(options, internal),
                bounds = this._bounds;
            Item._updateBoundsCache(this._parent || this._symbol, cacheItem);
            if (cacheKey && bounds && cacheKey in bounds) {
                var cached = bounds[cacheKey];
                return {
                    rect: cached.rect.clone(),
                    nonscaling: cached.nonscaling
                };
            }
            var res = this._getBounds(matrix || _matrix, options),
                rect = res.rect || res,
                style = this._style,
                nonscaling = res.nonscaling || style.hasStroke()
                    && !style.getStrokeScaling();
            if (cacheKey) {
                if (!bounds) {
                    this._bounds = bounds = {};
                }
                var cached = bounds[cacheKey] = {
                    rect: rect.clone(),
                    nonscaling: nonscaling,
                    internal: internal
                };
            }
            return {
                rect: rect,
                nonscaling: nonscaling
            };
        },
    
        _getStrokeMatrix: function(matrix, options) {
            var parent = this.getStrokeScaling() ? null
                    : options && options.internal ? this
                        : this._parent || this._symbol && this._symbol._item,
                mx = parent ? parent.getViewMatrix().invert() : matrix;
            return mx && mx._shiftless();
        },
    
        statics: {
            _updateBoundsCache: function(parent, item) {
                if (parent && item) {
                    var id = item._id,
                        ref = parent._boundsCache = parent._boundsCache || {
                            ids: {},
                            list: []
                        };
                    if (!ref.ids[id]) {
                        ref.list.push(item);
                        ref.ids[id] = item;
                    }
                }
            },
    
            _clearBoundsCache: function(item) {
                var cache = item._boundsCache;
                if (cache) {
                    item._bounds = item._position = item._boundsCache = undefined;
                    for (var i = 0, list = cache.list, l = list.length; i < l; i++){
                        var other = list[i];
                        if (other !== item) {
                            other._bounds = other._position = undefined;
                            if (other._boundsCache)
                                Item._clearBoundsCache(other);
                        }
                    }
                }
            },
    
            _getBounds: function(items, matrix, options) {
                var x1 = Infinity,
                    x2 = -x1,
                    y1 = x1,
                    y2 = x2,
                    nonscaling = false;
                options = options || {};
                for (var i = 0, l = items.length; i < l; i++) {
                    var item = items[i];
                    if (item._visible && !item.isEmpty()) {
                        var bounds = item._getCachedBounds(
                            matrix && matrix.appended(item._matrix), options, true),
                            rect = bounds.rect;
                        x1 = Math.min(rect.x, x1);
                        y1 = Math.min(rect.y, y1);
                        x2 = Math.max(rect.x + rect.width, x2);
                        y2 = Math.max(rect.y + rect.height, y2);
                        if (bounds.nonscaling)
                            nonscaling = true;
                    }
                }
                return {
                    rect: isFinite(x1)
                        ? new Rectangle(x1, y1, x2 - x1, y2 - y1)
                        : new Rectangle(),
                    nonscaling: nonscaling
                };
            }
        }
    
    }), {
        beans: true,
    
        _decompose: function() {
            return this._applyMatrix
                ? null
                : this._decomposed || (this._decomposed = this._matrix.decompose());
        },
    
        getRotation: function() {
            var decomposed = this._decompose();
            return decomposed ? decomposed.rotation : 0;
        },
    
        setRotation: function(rotation) {
            var current = this.getRotation();
            if (current != null && rotation != null) {
                var decomposed = this._decomposed;
                this.rotate(rotation - current);
                if (decomposed) {
                    decomposed.rotation = rotation;
                    this._decomposed = decomposed;
                }
            }
        },
    
        getScaling: function() {
            var decomposed = this._decompose(),
                s = decomposed && decomposed.scaling;
            return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
        },
    
        setScaling: function() {
            var current = this.getScaling(),
                scaling = Point.read(arguments, 0, { clone: true, readNull: true });
            if (current && scaling && !current.equals(scaling)) {
                var rotation = this.getRotation(),
                    decomposed = this._decomposed,
                    matrix = new Matrix(),
                    center = this.getPosition(true);
                matrix.translate(center);
                if (rotation)
                    matrix.rotate(rotation);
                matrix.scale(scaling.x / current.x, scaling.y / current.y);
                if (rotation)
                    matrix.rotate(-rotation);
                matrix.translate(center.negate());
                this.transform(matrix);
                if (decomposed) {
                    decomposed.scaling = scaling;
                    this._decomposed = decomposed;
                }
            }
        },
    
        getMatrix: function() {
            return this._matrix;
        },
    
        setMatrix: function() {
            var matrix = this._matrix;
            matrix.initialize.apply(matrix, arguments);
        },
    
        getGlobalMatrix: function(_dontClone) {
            var matrix = this._globalMatrix,
                updateVersion = this._project._updateVersion;
            if (matrix && matrix._updateVersion !== updateVersion)
                matrix = null;
            if (!matrix) {
                matrix = this._globalMatrix = this._matrix.clone();
                var parent = this._parent;
                if (parent)
                    matrix.prepend(parent.getGlobalMatrix(true));
                matrix._updateVersion = updateVersion;
            }
            return _dontClone ? matrix : matrix.clone();
        },
    
        getViewMatrix: function() {
            return this.getGlobalMatrix().prepend(this.getView()._matrix);
        },
    
        getApplyMatrix: function() {
            return this._applyMatrix;
        },
    
        setApplyMatrix: function(apply) {
            if (this._applyMatrix = this._canApplyMatrix && !!apply)
                this.transform(null, true);
        },
    
        getTransformContent: '#getApplyMatrix',
        setTransformContent: '#setApplyMatrix',
    }, {
        getProject: function() {
            return this._project;
        },
    
        _setProject: function(project, installEvents) {
            if (this._project !== project) {
                if (this._project)
                    this._installEvents(false);
                this._project = project;
                var children = this._children;
                for (var i = 0, l = children && children.length; i < l; i++)
                    children[i]._setProject(project);
                installEvents = true;
            }
            if (installEvents)
                this._installEvents(true);
        },
    
        getView: function() {
            return this._project._view;
        },
    
        _installEvents: function _installEvents(install) {
            _installEvents.base.call(this, install);
            var children = this._children;
            for (var i = 0, l = children && children.length; i < l; i++)
                children[i]._installEvents(install);
        },
    
        getLayer: function() {
            var parent = this;
            while (parent = parent._parent) {
                if (parent instanceof Layer)
                    return parent;
            }
            return null;
        },
    
        getParent: function() {
            return this._parent;
        },
    
        setParent: function(item) {
            return item.addChild(this);
        },
    
        _getOwner: '#getParent',
    
        getChildren: function() {
            return this._children;
        },
    
        setChildren: function(items) {
            this.removeChildren();
            this.addChildren(items);
        },
    
        getFirstChild: function() {
            return this._children && this._children[0] || null;
        },
    
        getLastChild: function() {
            return this._children && this._children[this._children.length - 1]
                    || null;
        },
    
        getNextSibling: function() {
            var owner = this._getOwner();
            return owner && owner._children[this._index + 1] || null;
        },
    
        getPreviousSibling: function() {
            var owner = this._getOwner();
            return owner && owner._children[this._index - 1] || null;
        },
    
        getIndex: function() {
            return this._index;
        },
    
        equals: function(item) {
            return item === this || item && this._class === item._class
                    && this._style.equals(item._style)
                    && this._matrix.equals(item._matrix)
                    && this._locked === item._locked
                    && this._visible === item._visible
                    && this._blendMode === item._blendMode
                    && this._opacity === item._opacity
                    && this._clipMask === item._clipMask
                    && this._guide === item._guide
                    && this._equals(item)
                    || false;
        },
    
        _equals: function(item) {
            return Base.equals(this._children, item._children);
        },
    
        clone: function(options) {
            var copy = new this.constructor(Item.NO_INSERT),
                children = this._children,
                insert = Base.pick(options ? options.insert : undefined,
                        options === undefined || options === true),
                deep = Base.pick(options ? options.deep : undefined, true);
            if (children)
                copy.copyAttributes(this);
            if (!children || deep)
                copy.copyContent(this);
            if (!children)
                copy.copyAttributes(this);
            if (insert)
                copy.insertAbove(this);
            var name = this._name,
                parent = this._parent;
            if (name && parent) {
                var children = parent._children,
                    orig = name,
                    i = 1;
                while (children[name])
                    name = orig + ' ' + (i++);
                if (name !== orig)
                    copy.setName(name);
            }
            return copy;
        },
    
        copyContent: function(source) {
            var children = source._children;
            for (var i = 0, l = children && children.length; i < l; i++) {
                this.addChild(children[i].clone(false), true);
            }
        },
    
        copyAttributes: function(source, excludeMatrix) {
            this.setStyle(source._style);
            var keys = ['_locked', '_visible', '_blendMode', '_opacity',
                    '_clipMask', '_guide'];
            for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                if (source.hasOwnProperty(key))
                    this[key] = source[key];
            }
            if (!excludeMatrix)
                this._matrix.set(source._matrix, true);
            this.setApplyMatrix(source._applyMatrix);
            this.setPivot(source._pivot);
            this.setSelection(source._selection);
            var data = source._data,
                name = source._name;
            this._data = data ? Base.clone(data) : null;
            if (name)
                this.setName(name);
        },
    
        rasterize: function(resolution, insert) {
            var bounds = this.getStrokeBounds(),
                scale = (resolution || this.getView().getResolution()) / 72,
                topLeft = bounds.getTopLeft().floor(),
                bottomRight = bounds.getBottomRight().ceil(),
                size = new Size(bottomRight.subtract(topLeft)),
                raster = new Raster(Item.NO_INSERT);
            if (!size.isZero()) {
                var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
                    ctx = canvas.getContext('2d'),
                    matrix = new Matrix().scale(scale).translate(topLeft.negate());
                ctx.save();
                matrix.applyToContext(ctx);
                this.draw(ctx, new Base({ matrices: [matrix] }));
                ctx.restore();
                raster.setCanvas(canvas);
            }
            raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
                    .scale(1 / scale));
            if (insert === undefined || insert)
                raster.insertAbove(this);
            return raster;
        },
    
        contains: function() {
            return !!this._contains(
                    this._matrix._inverseTransform(Point.read(arguments)));
        },
    
        _contains: function(point) {
            var children = this._children;
            if (children) {
                for (var i = children.length - 1; i >= 0; i--) {
                    if (children[i].contains(point))
                        return true;
                }
                return false;
            }
            return point.isInside(this.getInternalBounds());
        },
    
        isInside: function() {
            return Rectangle.read(arguments).contains(this.getBounds());
        },
    
        _asPathItem: function() {
            return new Path.Rectangle({
                rectangle: this.getInternalBounds(),
                matrix: this._matrix,
                insert: false,
            });
        },
    
        intersects: function(item, _matrix) {
            if (!(item instanceof Item))
                return false;
            return this._asPathItem().getIntersections(item._asPathItem(), null,
                    _matrix, true).length > 0;
        }
    },
    new function() {
        function hitTest() {
            return this._hitTest(
                    Point.read(arguments),
                    HitResult.getOptions(arguments));
        }
    
        function hitTestAll() {
            var point = Point.read(arguments),
                options = HitResult.getOptions(arguments),
                all = [];
            this._hitTest(point, Base.set({ all: all }, options));
            return all;
        }
    
        function hitTestChildren(point, options, viewMatrix, _exclude) {
            var children = this._children;
            if (children) {
                for (var i = children.length - 1; i >= 0; i--) {
                    var child = children[i];
                    var res = child !== _exclude && child._hitTest(point, options,
                            viewMatrix);
                    if (res && !options.all)
                        return res;
                }
            }
            return null;
        }
    
        Project.inject({
            hitTest: hitTest,
            hitTestAll: hitTestAll,
            _hitTest: hitTestChildren
        });
    
        return {
            hitTest: hitTest,
            hitTestAll: hitTestAll,
            _hitTestChildren: hitTestChildren,
        };
    }, {
    
        _hitTest: function(point, options, parentViewMatrix) {
            if (this._locked || !this._visible || this._guide && !options.guides
                    || this.isEmpty()) {
                return null;
            }
    
            var matrix = this._matrix,
                viewMatrix = parentViewMatrix
                        ? parentViewMatrix.appended(matrix)
                        : this.getGlobalMatrix().prepend(this.getView()._matrix),
                tolerance = Math.max(options.tolerance, 1e-12),
                tolerancePadding = options._tolerancePadding = new Size(
                        Path._getStrokePadding(tolerance,
                            matrix._shiftless().invert()));
            point = matrix._inverseTransform(point);
            if (!point || !this._children &&
                !this.getBounds({ internal: true, stroke: true, handle: true })
                    .expand(tolerancePadding.multiply(2))._containsPoint(point)) {
                return null;
            }
    
            var checkSelf = !(options.guides && !this._guide
                    || options.selected && !this.isSelected()
                    || options.type && options.type !== Base.hyphenate(this._class)
                    || options.class && !(this instanceof options.class)),
                match = options.match,
                that = this,
                bounds,
                res;
    
            function filter(hit) {
                if (hit && match && !match(hit))
                    hit = null;
                if (hit && options.all)
                    options.all.push(hit);
                return hit;
            }
    
            function checkPoint(type, part) {
                var pt = part ? bounds['get' + part]() : that.getPosition();
                if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
                    return new HitResult(type, that, {
                        name: part ? Base.hyphenate(part) : type,
                        point: pt
                    });
                }
            }
    
            var checkPosition = options.position,
                checkCenter = options.center,
                checkBounds = options.bounds;
            if (checkSelf && this._parent
                    && (checkPosition || checkCenter || checkBounds)) {
                if (checkCenter || checkBounds) {
                    bounds = this.getInternalBounds();
                }
                res = checkPosition && checkPoint('position') ||
                        checkCenter && checkPoint('center', 'Center');
                if (!res && checkBounds) {
                    var points = [
                        'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
                        'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
                    ];
                    for (var i = 0; i < 8 && !res; i++) {
                        res = checkPoint('bounds', points[i]);
                    }
                }
                res = filter(res);
            }
    
            if (!res) {
                res = this._hitTestChildren(point, options, viewMatrix)
                    || checkSelf
                        && filter(this._hitTestSelf(point, options, viewMatrix,
                            this.getStrokeScaling() ? null
                                : viewMatrix._shiftless().invert()))
                    || null;
            }
            if (res && res.point) {
                res.point = matrix.transform(res.point);
            }
            return res;
        },
    
        _hitTestSelf: function(point, options) {
            if (options.fill && this.hasFill() && this._contains(point))
                return new HitResult('fill', this);
        },
    
        matches: function(name, compare) {
            function matchObject(obj1, obj2) {
                for (var i in obj1) {
                    if (obj1.hasOwnProperty(i)) {
                        var val1 = obj1[i],
                            val2 = obj2[i];
                        if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
                            if (!matchObject(val1, val2))
                                return false;
                        } else if (!Base.equals(val1, val2)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            var type = typeof name;
            if (type === 'object') {
                for (var key in name) {
                    if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
                        return false;
                }
                return true;
            } else if (type === 'function') {
                return name(this);
            } else if (name === 'match') {
                return compare(this);
            } else {
                var value = /^(empty|editable)$/.test(name)
                        ? this['is' + Base.capitalize(name)]()
                        : name === 'type'
                            ? Base.hyphenate(this._class)
                            : this[name];
                if (name === 'class') {
                    if (typeof compare === 'function')
                        return this instanceof compare;
                    value = this._class;
                }
                if (typeof compare === 'function') {
                    return !!compare(value);
                } else if (compare) {
                    if (compare.test) {
                        return compare.test(value);
                    } else if (Base.isPlainObject(compare)) {
                        return matchObject(compare, value);
                    }
                }
                return Base.equals(value, compare);
            }
        },
    
        getItems: function(options) {
            return Item._getItems(this, options, this._matrix);
        },
    
        getItem: function(options) {
            return Item._getItems(this, options, this._matrix, null, true)[0]
                    || null;
        },
    
        statics: {
            _getItems: function _getItems(item, options, matrix, param, firstOnly) {
                if (!param) {
                    var obj = typeof options === 'object' && options,
                        overlapping = obj && obj.overlapping,
                        inside = obj && obj.inside,
                        bounds = overlapping || inside,
                        rect = bounds && Rectangle.read([bounds]);
                    param = {
                        items: [],
                        recursive: obj && obj.recursive !== false,
                        inside: !!inside,
                        overlapping: !!overlapping,
                        rect: rect,
                        path: overlapping && new Path.Rectangle({
                            rectangle: rect,
                            insert: false
                        })
                    };
                    if (obj) {
                        options = Base.filter({}, options, {
                            recursive: true, inside: true, overlapping: true
                        });
                    }
                }
                var children = item._children,
                    items = param.items,
                    rect = param.rect;
                matrix = rect && (matrix || new Matrix());
                for (var i = 0, l = children && children.length; i < l; i++) {
                    var child = children[i],
                        childMatrix = matrix && matrix.appended(child._matrix),
                        add = true;
                    if (rect) {
                        var bounds = child.getBounds(childMatrix);
                        if (!rect.intersects(bounds))
                            continue;
                        if (!(rect.contains(bounds)
                                || param.overlapping && (bounds.contains(rect)
                                    || param.path.intersects(child, childMatrix))))
                            add = false;
                    }
                    if (add && child.matches(options)) {
                        items.push(child);
                        if (firstOnly)
                            break;
                    }
                    if (param.recursive !== false) {
                        _getItems(child, options, childMatrix, param, firstOnly);
                    }
                    if (firstOnly && items.length > 0)
                        break;
                }
                return items;
            }
        }
    }, {
    
        importJSON: function(json) {
            var res = Base.importJSON(json, this);
            return res !== this ? this.addChild(res) : res;
        },
    
        addChild: function(item) {
            return this.insertChild(undefined, item);
        },
    
        insertChild: function(index, item) {
            var res = item ? this.insertChildren(index, [item]) : null;
            return res && res[0];
        },
    
        addChildren: function(items) {
            return this.insertChildren(this._children.length, items);
        },
    
        insertChildren: function(index, items) {
            var children = this._children;
            if (children && items && items.length > 0) {
                items = Base.slice(items);
                var inserted = {};
                for (var i = items.length - 1; i >= 0; i--) {
                    var item = items[i],
                        id = item && item._id;
                    if (!item || inserted[id]) {
                        items.splice(i, 1);
                    } else {
                        item._remove(false, true);
                        inserted[id] = true;
                    }
                }
                Base.splice(children, items, index, 0);
                var project = this._project,
                    notifySelf = project._changes;
                for (var i = 0, l = items.length; i < l; i++) {
                    var item = items[i],
                        name = item._name;
                    item._parent = this;
                    item._setProject(project, true);
                    if (name)
                        item.setName(name);
                    if (notifySelf)
                        item._changed(5);
                }
                this._changed(11);
            } else {
                items = null;
            }
            return items;
        },
    
        _insertItem: '#insertChild',
    
        _insertAt: function(item, offset) {
            var owner = item && item._getOwner(),
                res = item !== this && owner ? this : null;
            if (res) {
                res._remove(false, true);
                owner._insertItem(item._index + offset, res);
            }
            return res;
        },
    
        insertAbove: function(item) {
            return this._insertAt(item, 1);
        },
    
        insertBelow: function(item) {
            return this._insertAt(item, 0);
        },
    
        sendToBack: function() {
            var owner = this._getOwner();
            return owner ? owner._insertItem(0, this) : null;
        },
    
        bringToFront: function() {
            var owner = this._getOwner();
            return owner ? owner._insertItem(undefined, this) : null;
        },
    
        appendTop: '#addChild',
    
        appendBottom: function(item) {
            return this.insertChild(0, item);
        },
    
        moveAbove: '#insertAbove',
    
        moveBelow: '#insertBelow',
    
        addTo: function(owner) {
            return owner._insertItem(undefined, this);
        },
    
        copyTo: function(owner) {
            return this.clone(false).addTo(owner);
        },
    
        reduce: function(options) {
            var children = this._children;
            if (children && children.length === 1) {
                var child = children[0].reduce(options);
                if (this._parent) {
                    child.insertAbove(this);
                    this.remove();
                } else {
                    child.remove();
                }
                return child;
            }
            return this;
        },
    
        _removeNamed: function() {
            var owner = this._getOwner();
            if (owner) {
                var children = owner._children,
                    namedChildren = owner._namedChildren,
                    name = this._name,
                    namedArray = namedChildren[name],
                    index = namedArray ? namedArray.indexOf(this) : -1;
                if (index !== -1) {
                    if (children[name] == this)
                        delete children[name];
                    namedArray.splice(index, 1);
                    if (namedArray.length) {
                        children[name] = namedArray[0];
                    } else {
                        delete namedChildren[name];
                    }
                }
            }
        },
    
        _remove: function(notifySelf, notifyParent) {
            var owner = this._getOwner(),
                project = this._project,
                index = this._index;
            if (owner) {
                if (this._name)
                    this._removeNamed();
                if (index != null) {
                    if (project._activeLayer === this)
                        project._activeLayer = this.getNextSibling()
                                || this.getPreviousSibling();
                    Base.splice(owner._children, null, index, 1);
                }
                this._installEvents(false);
                if (notifySelf && project._changes)
                    this._changed(5);
                if (notifyParent)
                    owner._changed(11, this);
                this._parent = null;
                return true;
            }
            return false;
        },
    
        remove: function() {
            return this._remove(true, true);
        },
    
        replaceWith: function(item) {
            var ok = item && item.insertBelow(this);
            if (ok)
                this.remove();
            return ok;
        },
    
        removeChildren: function(start, end) {
            if (!this._children)
                return null;
            start = start || 0;
            end = Base.pick(end, this._children.length);
            var removed = Base.splice(this._children, null, start, end - start);
            for (var i = removed.length - 1; i >= 0; i--) {
                removed[i]._remove(true, false);
            }
            if (removed.length > 0)
                this._changed(11);
            return removed;
        },
    
        clear: '#removeChildren',
    
        reverseChildren: function() {
            if (this._children) {
                this._children.reverse();
                for (var i = 0, l = this._children.length; i < l; i++)
                    this._children[i]._index = i;
                this._changed(11);
            }
        },
    
        isEmpty: function() {
            var children = this._children;
            return !children || !children.length;
        },
    
        isEditable: function() {
            var item = this;
            while (item) {
                if (!item._visible || item._locked)
                    return false;
                item = item._parent;
            }
            return true;
        },
    
        hasFill: function() {
            return this.getStyle().hasFill();
        },
    
        hasStroke: function() {
            return this.getStyle().hasStroke();
        },
    
        hasShadow: function() {
            return this.getStyle().hasShadow();
        },
    
        _getOrder: function(item) {
            function getList(item) {
                var list = [];
                do {
                    list.unshift(item);
                } while (item = item._parent);
                return list;
            }
            var list1 = getList(this),
                list2 = getList(item);
            for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
                if (list1[i] != list2[i]) {
                    return list1[i]._index < list2[i]._index ? 1 : -1;
                }
            }
            return 0;
        },
    
        hasChildren: function() {
            return this._children && this._children.length > 0;
        },
    
        isInserted: function() {
            return this._parent ? this._parent.isInserted() : false;
        },
    
        isAbove: function(item) {
            return this._getOrder(item) === -1;
        },
    
        isBelow: function(item) {
            return this._getOrder(item) === 1;
        },
    
        isParent: function(item) {
            return this._parent === item;
        },
    
        isChild: function(item) {
            return item && item._parent === this;
        },
    
        isDescendant: function(item) {
            var parent = this;
            while (parent = parent._parent) {
                if (parent === item)
                    return true;
            }
            return false;
        },
    
        isAncestor: function(item) {
            return item ? item.isDescendant(this) : false;
        },
    
        isSibling: function(item) {
            return this._parent === item._parent;
        },
    
        isGroupedWith: function(item) {
            var parent = this._parent;
            while (parent) {
                if (parent._parent
                    && /^(Group|Layer|CompoundPath)$/.test(parent._class)
                    && item.isDescendant(parent))
                        return true;
                parent = parent._parent;
            }
            return false;
        },
    
    }, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
        var rotate = key === 'rotate';
        this[key] = function() {
            var value = (rotate ? Base : Point).read(arguments),
                center = Point.read(arguments, 0, { readNull: true });
            return this.transform(new Matrix()[key](value,
                    center || this.getPosition(true)));
        };
    }, {
        translate: function() {
            var mx = new Matrix();
            return this.transform(mx.translate.apply(mx, arguments));
        },
    
        transform: function(matrix, _applyMatrix, _applyRecursively,
                _setApplyMatrix) {
            var _matrix = this._matrix,
                transform = matrix && !matrix.isIdentity(),
                applyMatrix = (_applyMatrix || this._applyMatrix)
                        && ((!_matrix.isIdentity() || transform)
                            || _applyMatrix && _applyRecursively && this._children);
            if (!transform && !applyMatrix)
                return this;
            if (transform) {
                if (!matrix.isInvertible() && _matrix.isInvertible())
                    _matrix._backup = _matrix.getValues();
                _matrix.prepend(matrix, true);
                var style = this._style,
                    fillColor = style.getFillColor(true),
                    strokeColor = style.getStrokeColor(true);
                if (fillColor)
                    fillColor.transform(matrix);
                if (strokeColor)
                    strokeColor.transform(matrix);
            }
            if (applyMatrix && (applyMatrix = this._transformContent(_matrix,
                    _applyRecursively, _setApplyMatrix))) {
                var pivot = this._pivot;
                if (pivot)
                    _matrix._transformPoint(pivot, pivot, true);
                _matrix.reset(true);
                if (_setApplyMatrix && this._canApplyMatrix)
                    this._applyMatrix = true;
            }
            var bounds = this._bounds,
                position = this._position;
            if (transform || applyMatrix) {
                this._changed(9);
            }
            var decomp = transform && bounds && matrix.decompose();
            if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
                for (var key in bounds) {
                    var cache = bounds[key];
                    if (cache.nonscaling) {
                        delete bounds[key];
                    } else if (applyMatrix || !cache.internal) {
                        var rect = cache.rect;
                        matrix._transformBounds(rect, rect);
                    }
                }
                this._bounds = bounds;
                var cached = bounds[this._getBoundsCacheKey(
                        this._boundsOptions || {})];
                if (cached) {
                    this._position = cached.rect.getCenter(true);
                }
            } else if (transform && position && this._pivot) {
                this._position = matrix._transformPoint(position, position);
            }
            return this;
        },
    
        _transformContent: function(matrix, applyRecursively, setApplyMatrix) {
            var children = this._children;
            if (children) {
                for (var i = 0, l = children.length; i < l; i++)
                    children[i].transform(matrix, true, applyRecursively,
                            setApplyMatrix);
                return true;
            }
        },
    
        globalToLocal: function() {
            return this.getGlobalMatrix(true)._inverseTransform(
                    Point.read(arguments));
        },
    
        localToGlobal: function() {
            return this.getGlobalMatrix(true)._transformPoint(
                    Point.read(arguments));
        },
    
        parentToLocal: function() {
            return this._matrix._inverseTransform(Point.read(arguments));
        },
    
        localToParent: function() {
            return this._matrix._transformPoint(Point.read(arguments));
        },
    
        fitBounds: function(rectangle, fill) {
            rectangle = Rectangle.read(arguments);
            var bounds = this.getBounds(),
                itemRatio = bounds.height / bounds.width,
                rectRatio = rectangle.height / rectangle.width,
                scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
                        ? rectangle.width / bounds.width
                        : rectangle.height / bounds.height,
                newBounds = new Rectangle(new Point(),
                        new Size(bounds.width * scale, bounds.height * scale));
            newBounds.setCenter(rectangle.getCenter());
            this.setBounds(newBounds);
        }
    }), {
    
        _setStyles: function(ctx, param, viewMatrix) {
            var style = this._style,
                matrix = this._matrix;
            if (style.hasFill()) {
                ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
            }
            if (style.hasStroke()) {
                ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
                ctx.lineWidth = style.getStrokeWidth();
                var strokeJoin = style.getStrokeJoin(),
                    strokeCap = style.getStrokeCap(),
                    miterLimit = style.getMiterLimit();
                if (strokeJoin)
                    ctx.lineJoin = strokeJoin;
                if (strokeCap)
                    ctx.lineCap = strokeCap;
                if (miterLimit)
                    ctx.miterLimit = miterLimit;
                if (paper.support.nativeDash) {
                    var dashArray = style.getDashArray(),
                        dashOffset = style.getDashOffset();
                    if (dashArray && dashArray.length) {
                        if ('setLineDash' in ctx) {
                            ctx.setLineDash(dashArray);
                            ctx.lineDashOffset = dashOffset;
                        } else {
                            ctx.mozDash = dashArray;
                            ctx.mozDashOffset = dashOffset;
                        }
                    }
                }
            }
            if (style.hasShadow()) {
                var pixelRatio = param.pixelRatio || 1,
                    mx = viewMatrix._shiftless().prepend(
                        new Matrix().scale(pixelRatio, pixelRatio)),
                    blur = mx.transform(new Point(style.getShadowBlur(), 0)),
                    offset = mx.transform(this.getShadowOffset());
                ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
                ctx.shadowBlur = blur.getLength();
                ctx.shadowOffsetX = offset.x;
                ctx.shadowOffsetY = offset.y;
            }
        },
    
        draw: function(ctx, param, parentStrokeMatrix) {
            var updateVersion = this._updateVersion = this._project._updateVersion;
            if (!this._visible || this._opacity === 0)
                return;
            var matrices = param.matrices,
                viewMatrix = param.viewMatrix,
                matrix = this._matrix,
                globalMatrix = matrices[matrices.length - 1].appended(matrix);
            if (!globalMatrix.isInvertible())
                return;
    
            viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)
                    : globalMatrix;
    
            matrices.push(globalMatrix);
            if (param.updateMatrix) {
                globalMatrix._updateVersion = updateVersion;
                this._globalMatrix = globalMatrix;
            }
    
            var blendMode = this._blendMode,
                opacity = this._opacity,
                normalBlend = blendMode === 'normal',
                nativeBlend = BlendMode.nativeModes[blendMode],
                direct = normalBlend && opacity === 1
                        || param.dontStart
                        || param.clip
                        || (nativeBlend || normalBlend && opacity < 1)
                            && this._canComposite(),
                pixelRatio = param.pixelRatio || 1,
                mainCtx, itemOffset, prevOffset;
            if (!direct) {
                var bounds = this.getStrokeBounds(viewMatrix);
                if (!bounds.width || !bounds.height)
                    return;
                prevOffset = param.offset;
                itemOffset = param.offset = bounds.getTopLeft().floor();
                mainCtx = ctx;
                ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
                        .multiply(pixelRatio));
                if (pixelRatio !== 1)
                    ctx.scale(pixelRatio, pixelRatio);
            }
            ctx.save();
            var strokeMatrix = parentStrokeMatrix
                    ? parentStrokeMatrix.appended(matrix)
                    : this._canScaleStroke && !this.getStrokeScaling(true)
                        && viewMatrix,
                clip = !direct && param.clipItem,
                transform = !strokeMatrix || clip;
            if (direct) {
                ctx.globalAlpha = opacity;
                if (nativeBlend)
                    ctx.globalCompositeOperation = blendMode;
            } else if (transform) {
                ctx.translate(-itemOffset.x, -itemOffset.y);
            }
            if (transform) {
                (direct ? matrix : viewMatrix).applyToContext(ctx);
            }
            if (clip) {
                param.clipItem.draw(ctx, param.extend({ clip: true }));
            }
            if (strokeMatrix) {
                ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                var offset = param.offset;
                if (offset)
                    ctx.translate(-offset.x, -offset.y);
            }
            this._draw(ctx, param, viewMatrix, strokeMatrix);
            ctx.restore();
            matrices.pop();
            if (param.clip && !param.dontFinish)
                ctx.clip();
            if (!direct) {
                BlendMode.process(blendMode, ctx, mainCtx, opacity,
                        itemOffset.subtract(prevOffset).multiply(pixelRatio));
                CanvasProvider.release(ctx);
                param.offset = prevOffset;
            }
        },
    
        _isUpdated: function(updateVersion) {
            var parent = this._parent;
            if (parent instanceof CompoundPath)
                return parent._isUpdated(updateVersion);
            var updated = this._updateVersion === updateVersion;
            if (!updated && parent && parent._visible
                    && parent._isUpdated(updateVersion)) {
                this._updateVersion = updateVersion;
                updated = true;
            }
            return updated;
        },
    
        _drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {
            var selection = this._selection,
                itemSelected = selection & 1,
                boundsSelected = selection & 2
                        || itemSelected && this._selectBounds,
                positionSelected = selection & 4;
            if (!this._drawSelected)
                itemSelected = false;
            if ((itemSelected || boundsSelected || positionSelected)
                    && this._isUpdated(updateVersion)) {
                var layer,
                    color = this.getSelectedColor(true) || (layer = this.getLayer())
                        && layer.getSelectedColor(true),
                    mx = matrix.appended(this.getGlobalMatrix(true)),
                    half = size / 2;
                ctx.strokeStyle = ctx.fillStyle = color
                        ? color.toCanvasStyle(ctx) : '#009dec';
                if (itemSelected)
                    this._drawSelected(ctx, mx, selectionItems);
                if (positionSelected) {
                    var point = this.getPosition(true),
                        x = point.x,
                        y = point.y;
                    ctx.beginPath();
                    ctx.arc(x, y, half, 0, Math.PI * 2, true);
                    ctx.stroke();
                    var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
                        start = half,
                        end = size + 1;
                    for (var i = 0; i < 4; i++) {
                        var delta = deltas[i],
                            dx = delta[0],
                            dy = delta[1];
                        ctx.moveTo(x + dx * start, y + dy * start);
                        ctx.lineTo(x + dx * end, y + dy * end);
                        ctx.stroke();
                    }
                }
                if (boundsSelected) {
                    var coords = mx._transformCorners(this.getInternalBounds());
                    ctx.beginPath();
                    for (var i = 0; i < 8; i++) {
                        ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    for (var i = 0; i < 8; i++) {
                        ctx.fillRect(coords[i] - half, coords[++i] - half,
                                size, size);
                    }
                }
            }
        },
    
        _canComposite: function() {
            return false;
        }
    }, Base.each(['down', 'drag', 'up', 'move'], function(key) {
        this['removeOn' + Base.capitalize(key)] = function() {
            var hash = {};
            hash[key] = true;
            return this.removeOn(hash);
        };
    }, {
    
        removeOn: function(obj) {
            for (var name in obj) {
                if (obj[name]) {
                    var key = 'mouse' + name,
                        project = this._project,
                        sets = project._removeSets = project._removeSets || {};
                    sets[key] = sets[key] || {};
                    sets[key][this._id] = this;
                }
            }
            return this;
        }
    }));
    
    var Group = Item.extend({
        _class: 'Group',
        _selectBounds: false,
        _selectChildren: true,
        _serializeFields: {
            children: []
        },
    
        initialize: function Group(arg) {
            this._children = [];
            this._namedChildren = {};
            if (!this._initialize(arg))
                this.addChildren(Array.isArray(arg) ? arg : arguments);
        },
    
        _changed: function _changed(flags) {
            _changed.base.call(this, flags);
            if (flags & 1026) {
                this._clipItem = undefined;
            }
        },
    
        _getClipItem: function() {
            var clipItem = this._clipItem;
            if (clipItem === undefined) {
                clipItem = null;
                var children = this._children;
                for (var i = 0, l = children.length; i < l; i++) {
                    if (children[i]._clipMask) {
                        clipItem = children[i];
                        break;
                    }
                }
                this._clipItem = clipItem;
            }
            return clipItem;
        },
    
        isClipped: function() {
            return !!this._getClipItem();
        },
    
        setClipped: function(clipped) {
            var child = this.getFirstChild();
            if (child)
                child.setClipMask(clipped);
        },
    
        _getBounds: function _getBounds(matrix, options) {
            var clipItem = this._getClipItem();
            return clipItem
                ? clipItem._getCachedBounds(
                    matrix && matrix.appended(clipItem._matrix),
                    Base.set({}, options, { stroke: false }))
                : _getBounds.base.call(this, matrix, options);
        },
    
        _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
            var clipItem = this._getClipItem();
            return (!clipItem || clipItem.contains(point))
                    && _hitTestChildren.base.call(this, point, options, viewMatrix,
                        clipItem);
        },
    
        _draw: function(ctx, param) {
            var clip = param.clip,
                clipItem = !clip && this._getClipItem();
            param = param.extend({ clipItem: clipItem, clip: false });
            if (clip) {
                ctx.beginPath();
                param.dontStart = param.dontFinish = true;
            } else if (clipItem) {
                clipItem.draw(ctx, param.extend({ clip: true }));
            }
            var children = this._children;
            for (var i = 0, l = children.length; i < l; i++) {
                var item = children[i];
                if (item !== clipItem)
                    item.draw(ctx, param);
            }
        }
    });
    
    var Layer = Group.extend({
        _class: 'Layer',
    
        initialize: function Layer() {
            Group.apply(this, arguments);
        },
    
        _getOwner: function() {
            return this._parent || this._index != null && this._project;
        },
    
        isInserted: function isInserted() {
            return this._parent ? isInserted.base.call(this) : this._index != null;
        },
    
        activate: function() {
            this._project._activeLayer = this;
        },
    
        _hitTestSelf: function() {
        }
    });
    
    var Shape = Item.extend({
        _class: 'Shape',
        _applyMatrix: false,
        _canApplyMatrix: false,
        _canScaleStroke: true,
        _serializeFields: {
            type: null,
            size: null,
            radius: null
        },
    
        initialize: function Shape(props, point) {
            this._initialize(props, point);
        },
    
        _equals: function(item) {
            return this._type === item._type
                && this._size.equals(item._size)
                && Base.equals(this._radius, item._radius);
        },
    
        copyContent: function(source) {
            this.setType(source._type);
            this.setSize(source._size);
            this.setRadius(source._radius);
        },
    
        getType: function() {
            return this._type;
        },
    
        setType: function(type) {
            this._type = type;
        },
    
        getShape: '#getType',
        setShape: '#setType',
    
        getSize: function() {
            var size = this._size;
            return new LinkedSize(size.width, size.height, this, 'setSize');
        },
    
        setSize: function() {
            var size = Size.read(arguments);
            if (!this._size) {
                this._size = size.clone();
            } else if (!this._size.equals(size)) {
                var type = this._type,
                    width = size.width,
                    height = size.height;
                if (type === 'rectangle') {
                    this._radius.set(Size.min(this._radius, size.divide(2)));
                } else if (type === 'circle') {
                    width = height = (width + height) / 2;
                    this._radius = width / 2;
                } else if (type === 'ellipse') {
                    this._radius._set(width / 2, height / 2);
                }
                this._size._set(width, height);
                this._changed(9);
            }
        },
    
        getRadius: function() {
            var rad = this._radius;
            return this._type === 'circle'
                    ? rad
                    : new LinkedSize(rad.width, rad.height, this, 'setRadius');
        },
    
        setRadius: function(radius) {
            var type = this._type;
            if (type === 'circle') {
                if (radius === this._radius)
                    return;
                var size = radius * 2;
                this._radius = radius;
                this._size._set(size, size);
            } else {
                radius = Size.read(arguments);
                if (!this._radius) {
                    this._radius = radius.clone();
                } else {
                    if (this._radius.equals(radius))
                        return;
                    this._radius.set(radius);
                    if (type === 'rectangle') {
                        var size = Size.max(this._size, radius.multiply(2));
                        this._size.set(size);
                    } else if (type === 'ellipse') {
                        this._size._set(radius.width * 2, radius.height * 2);
                    }
                }
            }
            this._changed(9);
        },
    
        isEmpty: function() {
            return false;
        },
    
        toPath: function(insert) {
            var path = new Path[Base.capitalize(this._type)]({
                center: new Point(),
                size: this._size,
                radius: this._radius,
                insert: false
            });
            path.copyAttributes(this);
            if (paper.settings.applyMatrix)
                path.setApplyMatrix(true);
            if (insert === undefined || insert)
                path.insertAbove(this);
            return path;
        },
    
        toShape: '#clone',
    
        _asPathItem: function() {
            return this.toPath(false);
        },
    
        _draw: function(ctx, param, viewMatrix, strokeMatrix) {
            var style = this._style,
                hasFill = style.hasFill(),
                hasStroke = style.hasStroke(),
                dontPaint = param.dontFinish || param.clip,
                untransformed = !strokeMatrix;
            if (hasFill || hasStroke || dontPaint) {
                var type = this._type,
                    radius = this._radius,
                    isCircle = type === 'circle';
                if (!param.dontStart)
                    ctx.beginPath();
                if (untransformed && isCircle) {
                    ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
                } else {
                    var rx = isCircle ? radius : radius.width,
                        ry = isCircle ? radius : radius.height,
                        size = this._size,
                        width = size.width,
                        height = size.height;
                    if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
                        ctx.rect(-width / 2, -height / 2, width, height);
                    } else {
                        var x = width / 2,
                            y = height / 2,
                            kappa = 1 - 0.5522847498307936,
                            cx = rx * kappa,
                            cy = ry * kappa,
                            c = [
                                -x, -y + ry,
                                -x, -y + cy,
                                -x + cx, -y,
                                -x + rx, -y,
                                x - rx, -y,
                                x - cx, -y,
                                x, -y + cy,
                                x, -y + ry,
                                x, y - ry,
                                x, y - cy,
                                x - cx, y,
                                x - rx, y,
                                -x + rx, y,
                                -x + cx, y,
                                -x, y - cy,
                                -x, y - ry
                            ];
                        if (strokeMatrix)
                            strokeMatrix.transform(c, c, 32);
                        ctx.moveTo(c[0], c[1]);
                        ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
                        if (x !== rx)
                            ctx.lineTo(c[8], c[9]);
                        ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
                        if (y !== ry)
                            ctx.lineTo(c[16], c[17]);
                        ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
                        if (x !== rx)
                            ctx.lineTo(c[24], c[25]);
                        ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
                    }
                }
                ctx.closePath();
            }
            if (!dontPaint && (hasFill || hasStroke)) {
                this._setStyles(ctx, param, viewMatrix);
                if (hasFill) {
                    ctx.fill(style.getFillRule());
                    ctx.shadowColor = 'rgba(0,0,0,0)';
                }
                if (hasStroke)
                    ctx.stroke();
            }
        },
    
        _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
        },
    
        _getBounds: function(matrix, options) {
            var rect = new Rectangle(this._size).setCenter(0, 0),
                style = this._style,
                strokeWidth = options.stroke && style.hasStroke()
                        && style.getStrokeWidth();
            if (matrix)
                rect = matrix._transformBounds(rect);
            return strokeWidth
                    ? rect.expand(Path._getStrokePadding(strokeWidth,
                        this._getStrokeMatrix(matrix, options)))
                    : rect;
        }
    },
    new function() {
        function getCornerCenter(that, point, expand) {
            var radius = that._radius;
            if (!radius.isZero()) {
                var halfSize = that._size.divide(2);
                for (var q = 1; q <= 4; q++) {
                    var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
                        corner = dir.multiply(halfSize),
                        center = corner.subtract(dir.multiply(radius)),
                        rect = new Rectangle(
                                expand ? corner.add(dir.multiply(expand)) : corner,
                                center);
                    if (rect.contains(point))
                        return { point: center, quadrant: q };
                }
            }
        }
    
        function isOnEllipseStroke(point, radius, padding, quadrant) {
            var vector = point.divide(radius);
            return (!quadrant || vector.isInQuadrant(quadrant)) &&
                    vector.subtract(vector.normalize()).multiply(radius)
                        .divide(padding).length <= 1;
        }
    
        return {
            _contains: function _contains(point) {
                if (this._type === 'rectangle') {
                    var center = getCornerCenter(this, point);
                    return center
                            ? point.subtract(center.point).divide(this._radius)
                                .getLength() <= 1
                            : _contains.base.call(this, point);
                } else {
                    return point.divide(this.size).getLength() <= 0.5;
                }
            },
    
            _hitTestSelf: function _hitTestSelf(point, options, viewMatrix,
                    strokeMatrix) {
                var hit = false,
                    style = this._style,
                    hitStroke = options.stroke && style.hasStroke(),
                    hitFill = options.fill && style.hasFill();
                if (hitStroke || hitFill) {
                    var type = this._type,
                        radius = this._radius,
                        strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
                        strokePadding = options._tolerancePadding.add(
                            Path._getStrokePadding(strokeRadius,
                                !style.getStrokeScaling() && strokeMatrix));
                    if (type === 'rectangle') {
                        var padding = strokePadding.multiply(2),
                            center = getCornerCenter(this, point, padding);
                        if (center) {
                            hit = isOnEllipseStroke(point.subtract(center.point),
                                    radius, strokePadding, center.quadrant);
                        } else {
                            var rect = new Rectangle(this._size).setCenter(0, 0),
                                outer = rect.expand(padding),
                                inner = rect.expand(padding.negate());
                            hit = outer._containsPoint(point)
                                    && !inner._containsPoint(point);
                        }
                    } else {
                        hit = isOnEllipseStroke(point, radius, strokePadding);
                    }
                }
                return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)
                        : _hitTestSelf.base.apply(this, arguments);
            }
        };
    }, {
    
    statics: new function() {
        function createShape(type, point, size, radius, args) {
            var item = new Shape(Base.getNamed(args), point);
            item._type = type;
            item._size = size;
            item._radius = radius;
            return item;
        }
    
        return {
            Circle: function() {
                var center = Point.readNamed(arguments, 'center'),
                    radius = Base.readNamed(arguments, 'radius');
                return createShape('circle', center, new Size(radius * 2), radius,
                        arguments);
            },
    
            Rectangle: function() {
                var rect = Rectangle.readNamed(arguments, 'rectangle'),
                    radius = Size.min(Size.readNamed(arguments, 'radius'),
                            rect.getSize(true).divide(2));
                return createShape('rectangle', rect.getCenter(true),
                        rect.getSize(true), radius, arguments);
            },
    
            Ellipse: function() {
                var ellipse = Shape._readEllipse(arguments),
                    radius = ellipse.radius;
                return createShape('ellipse', ellipse.center, radius.multiply(2),
                        radius, arguments);
            },
    
            _readEllipse: function(args) {
                var center,
                    radius;
                if (Base.hasNamed(args, 'radius')) {
                    center = Point.readNamed(args, 'center');
                    radius = Size.readNamed(args, 'radius');
                } else {
                    var rect = Rectangle.readNamed(args, 'rectangle');
                    center = rect.getCenter(true);
                    radius = rect.getSize(true).divide(2);
                }
                return { center: center, radius: radius };
            }
        };
    }});
    
    var Raster = Item.extend({
        _class: 'Raster',
        _applyMatrix: false,
        _canApplyMatrix: false,
        _boundsOptions: { stroke: false, handle: false },
        _serializeFields: {
            crossOrigin: null,
            source: null
        },
        _prioritize: ['crossOrigin'],
    
        initialize: function Raster(object, position) {
            if (!this._initialize(object,
                    position !== undefined && Point.read(arguments, 1))) {
                var image = typeof object === 'string'
                        ? document.getElementById(object) : object;
                if (image) {
                    this.setImage(image);
                } else {
                    this.setSource(object);
                }
            }
            if (!this._size) {
                this._size = new Size();
                this._loaded = false;
            }
        },
    
        _equals: function(item) {
            return this.getSource() === item.getSource();
        },
    
        copyContent: function(source) {
            var image = source._image,
                canvas = source._canvas;
            if (image) {
                this._setImage(image);
            } else if (canvas) {
                var copyCanvas = CanvasProvider.getCanvas(source._size);
                copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
                this._setImage(copyCanvas);
            }
            this._crossOrigin = source._crossOrigin;
        },
    
        getSize: function() {
            var size = this._size;
            return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
                    this, 'setSize');
        },
    
        setSize: function() {
            var size = Size.read(arguments);
            if (!size.equals(this._size)) {
                if (size.width > 0 && size.height > 0) {
                    var element = this.getElement();
                    this._setImage(CanvasProvider.getCanvas(size));
                    if (element)
                        this.getContext(true).drawImage(element, 0, 0,
                                size.width, size.height);
                } else {
                    if (this._canvas)
                        CanvasProvider.release(this._canvas);
                    this._size = size.clone();
                }
            }
        },
    
        getWidth: function() {
            return this._size ? this._size.width : 0;
        },
    
        setWidth: function(width) {
            this.setSize(width, this.getHeight());
        },
    
        getHeight: function() {
            return this._size ? this._size.height : 0;
        },
    
        setHeight: function(height) {
            this.setSize(this.getWidth(), height);
        },
    
        getLoaded: function() {
            return this._loaded;
        },
    
        isEmpty: function() {
            var size = this._size;
            return !size || size.width === 0 && size.height === 0;
        },
    
        getResolution: function() {
            var matrix = this._matrix,
                orig = new Point(0, 0).transform(matrix),
                u = new Point(1, 0).transform(matrix).subtract(orig),
                v = new Point(0, 1).transform(matrix).subtract(orig);
            return new Size(
                72 / u.getLength(),
                72 / v.getLength()
            );
        },
    
        getPpi: '#getResolution',
    
        getImage: function() {
            return this._image;
        },
    
        setImage: function(image) {
            var that = this;
    
            function emit(event) {
                var view = that.getView(),
                    type = event && event.type || 'load';
                if (view && that.responds(type)) {
                    paper = view._scope;
                    that.emit(type, new Event(event));
                }
            }
    
            this._setImage(image);
            if (this._loaded) {
                setTimeout(emit, 0);
            } else if (image) {
                DomEvent.add(image, {
                    load: function(event) {
                        that._setImage(image);
                        emit(event);
                    },
                    error: emit
                });
            }
        },
    
        _setImage: function(image) {
            if (this._canvas)
                CanvasProvider.release(this._canvas);
            if (image && image.getContext) {
                this._image = null;
                this._canvas = image;
                this._loaded = true;
            } else {
                this._image = image;
                this._canvas = null;
                this._loaded = !!(image && image.src && image.complete);
            }
            this._size = new Size(
                    image ? image.naturalWidth || image.width : 0,
                    image ? image.naturalHeight || image.height : 0);
            this._context = null;
            this._changed(521);
        },
    
        getCanvas: function() {
            if (!this._canvas) {
                var ctx = CanvasProvider.getContext(this._size);
                try {
                    if (this._image)
                        ctx.drawImage(this._image, 0, 0);
                    this._canvas = ctx.canvas;
                } catch (e) {
                    CanvasProvider.release(ctx);
                }
            }
            return this._canvas;
        },
    
        setCanvas: '#setImage',
    
        getContext: function(modify) {
            if (!this._context)
                this._context = this.getCanvas().getContext('2d');
            if (modify) {
                this._image = null;
                this._changed(513);
            }
            return this._context;
        },
    
        setContext: function(context) {
            this._context = context;
        },
    
        getSource: function() {
            var image = this._image;
            return image && image.src || this.toDataURL();
        },
    
        setSource: function(src) {
            var image = new self.Image(),
                crossOrigin = this._crossOrigin;
            if (crossOrigin)
                image.crossOrigin = crossOrigin;
            image.src = src;
            this.setImage(image);
        },
    
        getCrossOrigin: function() {
            var image = this._image;
            return image && image.crossOrigin || this._crossOrigin || '';
        },
    
        setCrossOrigin: function(crossOrigin) {
            this._crossOrigin = crossOrigin;
            var image = this._image;
            if (image)
                image.crossOrigin = crossOrigin;
        },
    
        getElement: function() {
            return this._canvas || this._loaded && this._image;
        }
    }, {
        beans: false,
    
        getSubCanvas: function() {
            var rect = Rectangle.read(arguments),
                ctx = CanvasProvider.getContext(rect.getSize());
            ctx.drawImage(this.getCanvas(), rect.x, rect.y,
                    rect.width, rect.height, 0, 0, rect.width, rect.height);
            return ctx.canvas;
        },
    
        getSubRaster: function() {
            var rect = Rectangle.read(arguments),
                raster = new Raster(Item.NO_INSERT);
            raster._setImage(this.getSubCanvas(rect));
            raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
            raster._matrix.prepend(this._matrix);
            raster.insertAbove(this);
            return raster;
        },
    
        toDataURL: function() {
            var image = this._image,
                src = image && image.src;
            if (/^data:/.test(src))
                return src;
            var canvas = this.getCanvas();
            return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
        },
    
        drawImage: function(image ) {
            var point = Point.read(arguments, 1);
            this.getContext(true).drawImage(image, point.x, point.y);
        },
    
        getAverageColor: function(object) {
            var bounds, path;
            if (!object) {
                bounds = this.getBounds();
            } else if (object instanceof PathItem) {
                path = object;
                bounds = object.getBounds();
            } else if (typeof object === 'object') {
                if ('width' in object) {
                    bounds = new Rectangle(object);
                } else if ('x' in object) {
                    bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
                }
            }
            if (!bounds)
                return null;
            var sampleSize = 32,
                width = Math.min(bounds.width, sampleSize),
                height = Math.min(bounds.height, sampleSize);
            var ctx = Raster._sampleContext;
            if (!ctx) {
                ctx = Raster._sampleContext = CanvasProvider.getContext(
                        new Size(sampleSize));
            } else {
                ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
            }
            ctx.save();
            var matrix = new Matrix()
                    .scale(width / bounds.width, height / bounds.height)
                    .translate(-bounds.x, -bounds.y);
            matrix.applyToContext(ctx);
            if (path)
                path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
            this._matrix.applyToContext(ctx);
            var element = this.getElement(),
                size = this._size;
            if (element)
                ctx.drawImage(element, -size.width / 2, -size.height / 2);
            ctx.restore();
            var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
                    Math.ceil(height)).data,
                channels = [0, 0, 0],
                total = 0;
            for (var i = 0, l = pixels.length; i < l; i += 4) {
                var alpha = pixels[i + 3];
                total += alpha;
                alpha /= 255;
                channels[0] += pixels[i] * alpha;
                channels[1] += pixels[i + 1] * alpha;
                channels[2] += pixels[i + 2] * alpha;
            }
            for (var i = 0; i < 3; i++)
                channels[i] /= total;
            return total ? Color.read(channels) : null;
        },
    
        getPixel: function() {
            var point = Point.read(arguments);
            var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
            return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
                    data[3] / 255);
        },
    
        setPixel: function() {
            var point = Point.read(arguments),
                color = Color.read(arguments),
                components = color._convert('rgb'),
                alpha = color._alpha,
                ctx = this.getContext(true),
                imageData = ctx.createImageData(1, 1),
                data = imageData.data;
            data[0] = components[0] * 255;
            data[1] = components[1] * 255;
            data[2] = components[2] * 255;
            data[3] = alpha != null ? alpha * 255 : 255;
            ctx.putImageData(imageData, point.x, point.y);
        },
    
        createImageData: function() {
            var size = Size.read(arguments);
            return this.getContext().createImageData(size.width, size.height);
        },
    
        getImageData: function() {
            var rect = Rectangle.read(arguments);
            if (rect.isEmpty())
                rect = new Rectangle(this._size);
            return this.getContext().getImageData(rect.x, rect.y,
                    rect.width, rect.height);
        },
    
        setImageData: function(data ) {
            var point = Point.read(arguments, 1);
            this.getContext(true).putImageData(data, point.x, point.y);
        },
    
        _getBounds: function(matrix, options) {
            var rect = new Rectangle(this._size).setCenter(0, 0);
            return matrix ? matrix._transformBounds(rect) : rect;
        },
    
        _hitTestSelf: function(point) {
            if (this._contains(point)) {
                var that = this;
                return new HitResult('pixel', that, {
                    offset: point.add(that._size.divide(2)).round(),
                    color: {
                        get: function() {
                            return that.getPixel(this.offset);
                        }
                    }
                });
            }
        },
    
        _draw: function(ctx) {
            var element = this.getElement();
            if (element) {
                ctx.globalAlpha = this._opacity;
                ctx.drawImage(element,
                        -this._size.width / 2, -this._size.height / 2);
            }
        },
    
        _canComposite: function() {
            return true;
        }
    });
    
    var SymbolItem = Item.extend({
        _class: 'SymbolItem',
        _applyMatrix: false,
        _canApplyMatrix: false,
        _boundsOptions: { stroke: true },
        _serializeFields: {
            symbol: null
        },
    
        initialize: function SymbolItem(arg0, arg1) {
            if (!this._initialize(arg0,
                    arg1 !== undefined && Point.read(arguments, 1)))
                this.setDefinition(arg0 instanceof SymbolDefinition ?
                        arg0 : new SymbolDefinition(arg0));
        },
    
        _equals: function(item) {
            return this._definition === item._definition;
        },
    
        copyContent: function(source) {
            this.setDefinition(source._definition);
        },
    
        getDefinition: function() {
            return this._definition;
        },
    
        setDefinition: function(definition) {
            this._definition = definition;
            this._changed(9);
        },
    
        getSymbol: '#getDefinition',
        setSymbol: '#setDefinition',
    
        isEmpty: function() {
            return this._definition._item.isEmpty();
        },
    
        _getBounds: function(matrix, options) {
            var item = this._definition._item;
            return item._getCachedBounds(item._matrix.prepended(matrix), options);
        },
    
        _hitTestSelf: function(point, options, viewMatrix) {
            var res = this._definition._item._hitTest(point, options, viewMatrix);
            if (res)
                res.item = this;
            return res;
        },
    
        _draw: function(ctx, param) {
            this._definition._item.draw(ctx, param);
        }
    
    });
    
    var SymbolDefinition = Base.extend({
        _class: 'SymbolDefinition',
    
        initialize: function SymbolDefinition(item, dontCenter) {
            this._id = UID.get();
            this.project = paper.project;
            if (item)
                this.setItem(item, dontCenter);
        },
    
        _serialize: function(options, dictionary) {
            return dictionary.add(this, function() {
                return Base.serialize([this._class, this._item],
                        options, false, dictionary);
            });
        },
    
        _changed: function(flags) {
            if (flags & 8)
                Item._clearBoundsCache(this);
            if (flags & 1)
                this.project._changed(flags);
        },
    
        getItem: function() {
            return this._item;
        },
    
        setItem: function(item, _dontCenter) {
            if (item._symbol)
                item = item.clone();
            if (this._item)
                this._item._symbol = null;
            this._item = item;
            item.remove();
            item.setSelected(false);
            if (!_dontCenter)
                item.setPosition(new Point());
            item._symbol = this;
            this._changed(9);
        },
    
        getDefinition: '#getItem',
        setDefinition: '#setItem',
    
        place: function(position) {
            return new SymbolItem(this, position);
        },
    
        clone: function() {
            return new SymbolDefinition(this._item.clone(false));
        },
    
        equals: function(symbol) {
            return symbol === this
                    || symbol && this._item.equals(symbol._item)
                    || false;
        }
    });
    
    var HitResult = Base.extend({
        _class: 'HitResult',
    
        initialize: function HitResult(type, item, values) {
            this.type = type;
            this.item = item;
            if (values)
                this.inject(values);
        },
    
        statics: {
            getOptions: function(args) {
                var options = args && Base.read(args);
                return Base.set({
                    type: null,
                    tolerance: paper.settings.hitTolerance,
                    fill: !options,
                    stroke: !options,
                    segments: !options,
                    handles: false,
                    ends: false,
                    position: false,
                    center: false,
                    bounds: false,
                    guides: false,
                    selected: false
                }, options);
            }
        }
    });
    
    var Segment = Base.extend({
        _class: 'Segment',
        beans: true,
        _selection: 0,
    
        initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
            var count = arguments.length,
                point, handleIn, handleOut, selection;
            if (count > 0) {
                if (arg0 == null || typeof arg0 === 'object') {
                    if (count === 1 && arg0 && 'point' in arg0) {
                        point = arg0.point;
                        handleIn = arg0.handleIn;
                        handleOut = arg0.handleOut;
                        selection = arg0.selection;
                    } else {
                        point = arg0;
                        handleIn = arg1;
                        handleOut = arg2;
                        selection = arg3;
                    }
                } else {
                    point = [ arg0, arg1 ];
                    handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
                    handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
                }
            }
            new SegmentPoint(point, this, '_point');
            new SegmentPoint(handleIn, this, '_handleIn');
            new SegmentPoint(handleOut, this, '_handleOut');
            if (selection)
                this.setSelection(selection);
        },
    
        _serialize: function(options, dictionary) {
            var point = this._point,
                selection = this._selection,
                obj = selection || this.hasHandles()
                        ? [point, this._handleIn, this._handleOut]
                        : point;
            if (selection)
                obj.push(selection);
            return Base.serialize(obj, options, true, dictionary);
        },
    
        _changed: function(point) {
            var path = this._path;
            if (!path)
                return;
            var curves = path._curves,
                index = this._index,
                curve;
            if (curves) {
                if ((!point || point === this._point || point === this._handleIn)
                        && (curve = index > 0 ? curves[index - 1] : path._closed
                            ? curves[curves.length - 1] : null))
                    curve._changed();
                if ((!point || point === this._point || point === this._handleOut)
                        && (curve = curves[index]))
                    curve._changed();
            }
            path._changed(25);
        },
    
        getPoint: function() {
            return this._point;
        },
    
        setPoint: function() {
            this._point.set(Point.read(arguments));
        },
    
        getHandleIn: function() {
            return this._handleIn;
        },
    
        setHandleIn: function() {
            this._handleIn.set(Point.read(arguments));
        },
    
        getHandleOut: function() {
            return this._handleOut;
        },
    
        setHandleOut: function() {
            this._handleOut.set(Point.read(arguments));
        },
    
        hasHandles: function() {
            return !this._handleIn.isZero() || !this._handleOut.isZero();
        },
    
        isSmooth: function() {
            var handleIn = this._handleIn,
                handleOut = this._handleOut;
            return !handleIn.isZero() && !handleOut.isZero()
                    && handleIn.isCollinear(handleOut);
        },
    
        clearHandles: function() {
            this._handleIn._set(0, 0);
            this._handleOut._set(0, 0);
        },
    
        getSelection: function() {
            return this._selection;
        },
    
        setSelection: function(selection) {
            var oldSelection = this._selection,
                path = this._path;
            this._selection = selection = selection || 0;
            if (path && selection !== oldSelection) {
                path._updateSelection(this, oldSelection, selection);
                path._changed(129);
            }
        },
    
        _changeSelection: function(flag, selected) {
            var selection = this._selection;
            this.setSelection(selected ? selection | flag : selection & ~flag);
        },
    
        isSelected: function() {
            return !!(this._selection & 7);
        },
    
        setSelected: function(selected) {
            this._changeSelection(7, selected);
        },
    
        getIndex: function() {
            return this._index !== undefined ? this._index : null;
        },
    
        getPath: function() {
            return this._path || null;
        },
    
        getCurve: function() {
            var path = this._path,
                index = this._index;
            if (path) {
                if (index > 0 && !path._closed
                        && index === path._segments.length - 1)
                    index--;
                return path.getCurves()[index] || null;
            }
            return null;
        },
    
        getLocation: function() {
            var curve = this.getCurve();
            return curve
                    ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
                    : null;
        },
    
        getNext: function() {
            var segments = this._path && this._path._segments;
            return segments && (segments[this._index + 1]
                    || this._path._closed && segments[0]) || null;
        },
    
        smooth: function(options, _first, _last) {
            var opts = options || {},
                type = opts.type,
                factor = opts.factor,
                prev = this.getPrevious(),
                next = this.getNext(),
                p0 = (prev || this)._point,
                p1 = this._point,
                p2 = (next || this)._point,
                d1 = p0.getDistance(p1),
                d2 = p1.getDistance(p2);
            if (!type || type === 'catmull-rom') {
                var a = factor === undefined ? 0.5 : factor,
                    d1_a = Math.pow(d1, a),
                    d1_2a = d1_a * d1_a,
                    d2_a = Math.pow(d2, a),
                    d2_2a = d2_a * d2_a;
                if (!_first && prev) {
                    var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
                        N = 3 * d2_a * (d2_a + d1_a);
                    this.setHandleIn(N !== 0
                        ? new Point(
                            (d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,
                            (d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)
                        : new Point());
                }
                if (!_last && next) {
                    var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
                        N = 3 * d1_a * (d1_a + d2_a);
                    this.setHandleOut(N !== 0
                        ? new Point(
                            (d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,
                            (d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)
                        : new Point());
                }
            } else if (type === 'geometric') {
                if (prev && next) {
                    var vector = p0.subtract(p2),
                        t = factor === undefined ? 0.4 : factor,
                        k = t * d1 / (d1 + d2);
                    if (!_first)
                        this.setHandleIn(vector.multiply(k));
                    if (!_last)
                        this.setHandleOut(vector.multiply(k - t));
                }
            } else {
                throw new Error('Smoothing method \'' + type + '\' not supported.');
            }
        },
    
        getPrevious: function() {
            var segments = this._path && this._path._segments;
            return segments && (segments[this._index - 1]
                    || this._path._closed && segments[segments.length - 1]) || null;
        },
    
        isFirst: function() {
            return !this._index;
        },
    
        isLast: function() {
            var path = this._path;
            return path && this._index === path._segments.length - 1 || false;
        },
    
        reverse: function() {
            var handleIn = this._handleIn,
                handleOut = this._handleOut,
                tmp = handleIn.clone();
            handleIn.set(handleOut);
            handleOut.set(tmp);
        },
    
        reversed: function() {
            return new Segment(this._point, this._handleOut, this._handleIn);
        },
    
        remove: function() {
            return this._path ? !!this._path.removeSegment(this._index) : false;
        },
    
        clone: function() {
            return new Segment(this._point, this._handleIn, this._handleOut);
        },
    
        equals: function(segment) {
            return segment === this || segment && this._class === segment._class
                    && this._point.equals(segment._point)
                    && this._handleIn.equals(segment._handleIn)
                    && this._handleOut.equals(segment._handleOut)
                    || false;
        },
    
        toString: function() {
            var parts = [ 'point: ' + this._point ];
            if (!this._handleIn.isZero())
                parts.push('handleIn: ' + this._handleIn);
            if (!this._handleOut.isZero())
                parts.push('handleOut: ' + this._handleOut);
            return '{ ' + parts.join(', ') + ' }';
        },
    
        transform: function(matrix) {
            this._transformCoordinates(matrix, new Array(6), true);
            this._changed();
        },
    
        interpolate: function(from, to, factor) {
            var u = 1 - factor,
                v = factor,
                point1 = from._point,
                point2 = to._point,
                handleIn1 = from._handleIn,
                handleIn2 = to._handleIn,
                handleOut2 = to._handleOut,
                handleOut1 = from._handleOut;
            this._point._set(
                    u * point1._x + v * point2._x,
                    u * point1._y + v * point2._y, true);
            this._handleIn._set(
                    u * handleIn1._x + v * handleIn2._x,
                    u * handleIn1._y + v * handleIn2._y, true);
            this._handleOut._set(
                    u * handleOut1._x + v * handleOut2._x,
                    u * handleOut1._y + v * handleOut2._y, true);
            this._changed();
        },
    
        _transformCoordinates: function(matrix, coords, change) {
            var point = this._point,
                handleIn = !change || !this._handleIn.isZero()
                        ? this._handleIn : null,
                handleOut = !change || !this._handleOut.isZero()
                        ? this._handleOut : null,
                x = point._x,
                y = point._y,
                i = 2;
            coords[0] = x;
            coords[1] = y;
            if (handleIn) {
                coords[i++] = handleIn._x + x;
                coords[i++] = handleIn._y + y;
            }
            if (handleOut) {
                coords[i++] = handleOut._x + x;
                coords[i++] = handleOut._y + y;
            }
            if (matrix) {
                matrix._transformCoordinates(coords, coords, i / 2);
                x = coords[0];
                y = coords[1];
                if (change) {
                    point._x = x;
                    point._y = y;
                    i = 2;
                    if (handleIn) {
                        handleIn._x = coords[i++] - x;
                        handleIn._y = coords[i++] - y;
                    }
                    if (handleOut) {
                        handleOut._x = coords[i++] - x;
                        handleOut._y = coords[i++] - y;
                    }
                } else {
                    if (!handleIn) {
                        coords[i++] = x;
                        coords[i++] = y;
                    }
                    if (!handleOut) {
                        coords[i++] = x;
                        coords[i++] = y;
                    }
                }
            }
            return coords;
        }
    });
    
    var SegmentPoint = Point.extend({
        initialize: function SegmentPoint(point, owner, key) {
            var x, y,
                selected;
            if (!point) {
                x = y = 0;
            } else if ((x = point[0]) !== undefined) {
                y = point[1];
            } else {
                var pt = point;
                if ((x = pt.x) === undefined) {
                    pt = Point.read(arguments);
                    x = pt.x;
                }
                y = pt.y;
                selected = pt.selected;
            }
            this._x = x;
            this._y = y;
            this._owner = owner;
            owner[key] = this;
            if (selected)
                this.setSelected(true);
        },
    
        _set: function(x, y) {
            this._x = x;
            this._y = y;
            this._owner._changed(this);
            return this;
        },
    
        getX: function() {
            return this._x;
        },
    
        setX: function(x) {
            this._x = x;
            this._owner._changed(this);
        },
    
        getY: function() {
            return this._y;
        },
    
        setY: function(y) {
            this._y = y;
            this._owner._changed(this);
        },
    
        isZero: function() {
            var isZero = Numerical.isZero;
            return isZero(this._x) && isZero(this._y);
        },
    
        isSelected: function() {
            return !!(this._owner._selection & this._getSelection());
        },
    
        setSelected: function(selected) {
            this._owner._changeSelection(this._getSelection(), selected);
        },
    
        _getSelection: function() {
            var owner = this._owner;
            return this === owner._point ? 1
                : this === owner._handleIn ? 2
                : this === owner._handleOut ? 4
                : 0;
        }
    });
    
    var Curve = Base.extend({
        _class: 'Curve',
        beans: true,
    
        initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
            var count = arguments.length,
                seg1, seg2,
                point1, point2,
                handle1, handle2;
            if (count === 3) {
                this._path = arg0;
                seg1 = arg1;
                seg2 = arg2;
            } else if (!count) {
                seg1 = new Segment();
                seg2 = new Segment();
            } else if (count === 1) {
                if ('segment1' in arg0) {
                    seg1 = new Segment(arg0.segment1);
                    seg2 = new Segment(arg0.segment2);
                } else if ('point1' in arg0) {
                    point1 = arg0.point1;
                    handle1 = arg0.handle1;
                    handle2 = arg0.handle2;
                    point2 = arg0.point2;
                } else if (Array.isArray(arg0)) {
                    point1 = [arg0[0], arg0[1]];
                    point2 = [arg0[6], arg0[7]];
                    handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
                    handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
                }
            } else if (count === 2) {
                seg1 = new Segment(arg0);
                seg2 = new Segment(arg1);
            } else if (count === 4) {
                point1 = arg0;
                handle1 = arg1;
                handle2 = arg2;
                point2 = arg3;
            } else if (count === 8) {
                point1 = [arg0, arg1];
                point2 = [arg6, arg7];
                handle1 = [arg2 - arg0, arg3 - arg1];
                handle2 = [arg4 - arg6, arg5 - arg7];
            }
            this._segment1 = seg1 || new Segment(point1, null, handle1);
            this._segment2 = seg2 || new Segment(point2, handle2, null);
        },
    
        _serialize: function(options, dictionary) {
            return Base.serialize(this.hasHandles()
                    ? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
                        this.getPoint2()]
                    : [this.getPoint1(), this.getPoint2()],
                    options, true, dictionary);
        },
    
        _changed: function() {
            this._length = this._bounds = undefined;
        },
    
        clone: function() {
            return new Curve(this._segment1, this._segment2);
        },
    
        toString: function() {
            var parts = [ 'point1: ' + this._segment1._point ];
            if (!this._segment1._handleOut.isZero())
                parts.push('handle1: ' + this._segment1._handleOut);
            if (!this._segment2._handleIn.isZero())
                parts.push('handle2: ' + this._segment2._handleIn);
            parts.push('point2: ' + this._segment2._point);
            return '{ ' + parts.join(', ') + ' }';
        },
    
        classify: function() {
            return Curve.classify(this.getValues());
        },
    
        remove: function() {
            var removed = false;
            if (this._path) {
                var segment2 = this._segment2,
                    handleOut = segment2._handleOut;
                removed = segment2.remove();
                if (removed)
                    this._segment1._handleOut.set(handleOut);
            }
            return removed;
        },
    
        getPoint1: function() {
            return this._segment1._point;
        },
    
        setPoint1: function() {
            this._segment1._point.set(Point.read(arguments));
        },
    
        getPoint2: function() {
            return this._segment2._point;
        },
    
        setPoint2: function() {
            this._segment2._point.set(Point.read(arguments));
        },
    
        getHandle1: function() {
            return this._segment1._handleOut;
        },
    
        setHandle1: function() {
            this._segment1._handleOut.set(Point.read(arguments));
        },
    
        getHandle2: function() {
            return this._segment2._handleIn;
        },
    
        setHandle2: function() {
            this._segment2._handleIn.set(Point.read(arguments));
        },
    
        getSegment1: function() {
            return this._segment1;
        },
    
        getSegment2: function() {
            return this._segment2;
        },
    
        getPath: function() {
            return this._path;
        },
    
        getIndex: function() {
            return this._segment1._index;
        },
    
        getNext: function() {
            var curves = this._path && this._path._curves;
            return curves && (curves[this._segment1._index + 1]
                    || this._path._closed && curves[0]) || null;
        },
    
        getPrevious: function() {
            var curves = this._path && this._path._curves;
            return curves && (curves[this._segment1._index - 1]
                    || this._path._closed && curves[curves.length - 1]) || null;
        },
    
        isFirst: function() {
            return !this._segment1._index;
        },
    
        isLast: function() {
            var path = this._path;
            return path && this._segment1._index === path._curves.length - 1
                    || false;
        },
    
        isSelected: function() {
            return this.getPoint1().isSelected()
                    && this.getHandle1().isSelected()
                    && this.getHandle2().isSelected()
                    && this.getPoint2().isSelected();
        },
    
        setSelected: function(selected) {
            this.getPoint1().setSelected(selected);
            this.getHandle1().setSelected(selected);
            this.getHandle2().setSelected(selected);
            this.getPoint2().setSelected(selected);
        },
    
        getValues: function(matrix) {
            return Curve.getValues(this._segment1, this._segment2, matrix);
        },
    
        getPoints: function() {
            var coords = this.getValues(),
                points = [];
            for (var i = 0; i < 8; i += 2)
                points.push(new Point(coords[i], coords[i + 1]));
            return points;
        }
    }, {
        getLength: function() {
            if (this._length == null)
                this._length = Curve.getLength(this.getValues(), 0, 1);
            return this._length;
        },
    
        getArea: function() {
            return Curve.getArea(this.getValues());
        },
    
        getLine: function() {
            return new Line(this._segment1._point, this._segment2._point);
        },
    
        getPart: function(from, to) {
            return new Curve(Curve.getPart(this.getValues(), from, to));
        },
    
        getPartLength: function(from, to) {
            return Curve.getLength(this.getValues(), from, to);
        },
    
        divideAt: function(location) {
            return this.divideAtTime(location && location.curve === this
                    ? location.time : this.getTimeAt(location));
        },
    
        divideAtTime: function(time, _setHandles) {
            var tMin = 1e-8,
                tMax = 1 - tMin,
                res = null;
            if (time >= tMin && time <= tMax) {
                var parts = Curve.subdivide(this.getValues(), time),
                    left = parts[0],
                    right = parts[1],
                    setHandles = _setHandles || this.hasHandles(),
                    seg1 = this._segment1,
                    seg2 = this._segment2,
                    path = this._path;
                if (setHandles) {
                    seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);
                    seg2._handleIn._set(right[4] - right[6],right[5] - right[7]);
                }
                var x = left[6], y = left[7],
                    segment = new Segment(new Point(x, y),
                            setHandles && new Point(left[4] - x, left[5] - y),
                            setHandles && new Point(right[2] - x, right[3] - y));
                if (path) {
                    path.insert(seg1._index + 1, segment);
                    res = this.getNext();
                } else {
                    this._segment2 = segment;
                    this._changed();
                    res = new Curve(segment, seg2);
                }
            }
            return res;
        },
    
        splitAt: function(location) {
            var path = this._path;
            return path ? path.splitAt(location) : null;
        },
    
        splitAtTime: function(time) {
            return this.splitAt(this.getLocationAtTime(time));
        },
    
        divide: function(offset, isTime) {
            return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset
                    : this.getTimeAt(offset));
        },
    
        split: function(offset, isTime) {
            return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset
                    : this.getTimeAt(offset));
        },
    
        reversed: function() {
            return new Curve(this._segment2.reversed(), this._segment1.reversed());
        },
    
        clearHandles: function() {
            this._segment1._handleOut._set(0, 0);
            this._segment2._handleIn._set(0, 0);
        },
    
    statics: {
        getValues: function(segment1, segment2, matrix, straight) {
            var p1 = segment1._point,
                h1 = segment1._handleOut,
                h2 = segment2._handleIn,
                p2 = segment2._point,
                x1 = p1.x, y1 = p1.y,
                x2 = p2.x, y2 = p2.y,
                values = straight
                    ? [ x1, y1, x1, y1, x2, y2, x2, y2 ]
                    : [
                        x1, y1,
                        x1 + h1._x, y1 + h1._y,
                        x2 + h2._x, y2 + h2._y,
                        x2, y2
                    ];
            if (matrix)
                matrix._transformCoordinates(values, values, 4);
            return values;
        },
    
        subdivide: function(v, t) {
            var x0 = v[0], y0 = v[1],
                x1 = v[2], y1 = v[3],
                x2 = v[4], y2 = v[5],
                x3 = v[6], y3 = v[7];
            if (t === undefined)
                t = 0.5;
            var u = 1 - t,
                x4 = u * x0 + t * x1, y4 = u * y0 + t * y1,
                x5 = u * x1 + t * x2, y5 = u * y1 + t * y2,
                x6 = u * x2 + t * x3, y6 = u * y2 + t * y3,
                x7 = u * x4 + t * x5, y7 = u * y4 + t * y5,
                x8 = u * x5 + t * x6, y8 = u * y5 + t * y6,
                x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;
            return [
                [x0, y0, x4, y4, x7, y7, x9, y9],
                [x9, y9, x8, y8, x6, y6, x3, y3]
            ];
        },
    
        getMonoCurves: function(v, dir) {
            var curves = [],
                io = dir ? 0 : 1,
                o0 = v[io + 0],
                o1 = v[io + 2],
                o2 = v[io + 4],
                o3 = v[io + 6];
            if ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)
                    || Curve.isStraight(v)) {
                curves.push(v);
            } else {
                var a = 3 * (o1 - o2) - o0 + o3,
                    b = 2 * (o0 + o2) - 4 * o1,
                    c = o1 - o0,
                    tMin = 1e-8,
                    tMax = 1 - tMin,
                    roots = [],
                    n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
                if (!n) {
                    curves.push(v);
                } else {
                    roots.sort();
                    var t = roots[0],
                        parts = Curve.subdivide(v, t);
                    curves.push(parts[0]);
                    if (n > 1) {
                        t = (roots[1] - t) / (1 - t);
                        parts = Curve.subdivide(parts[1], t);
                        curves.push(parts[0]);
                    }
                    curves.push(parts[1]);
                }
            }
            return curves;
        },
    
        solveCubic: function (v, coord, val, roots, min, max) {
            var v0 = v[coord],
                v1 = v[coord + 2],
                v2 = v[coord + 4],
                v3 = v[coord + 6],
                res = 0;
            if (  !(v0 < val && v3 < val && v1 < val && v2 < val ||
                    v0 > val && v3 > val && v1 > val && v2 > val)) {
                var c = 3 * (v1 - v0),
                    b = 3 * (v2 - v1) - c,
                    a = v3 - v0 - c - b;
                res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
            }
            return res;
        },
    
        getTimeOf: function(v, point) {
            var p0 = new Point(v[0], v[1]),
                p3 = new Point(v[6], v[7]),
                epsilon = 1e-12,
                geomEpsilon = 1e-7,
                t = point.isClose(p0, epsilon) ? 0
                  : point.isClose(p3, epsilon) ? 1
                  : null;
            if (t === null) {
                var coords = [point.x, point.y],
                    roots = [];
                for (var c = 0; c < 2; c++) {
                    var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
                    for (var i = 0; i < count; i++) {
                        var u = roots[i];
                        if (point.isClose(Curve.getPoint(v, u), geomEpsilon))
                            return u;
                    }
                }
            }
            return point.isClose(p0, geomEpsilon) ? 0
                 : point.isClose(p3, geomEpsilon) ? 1
                 : null;
        },
    
        getNearestTime: function(v, point) {
            if (Curve.isStraight(v)) {
                var x0 = v[0], y0 = v[1],
                    x3 = v[6], y3 = v[7],
                    vx = x3 - x0, vy = y3 - y0,
                    det = vx * vx + vy * vy;
                if (det === 0)
                    return 0;
                var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
                return u < 1e-12 ? 0
                     : u > 0.999999999999 ? 1
                     : Curve.getTimeOf(v,
                        new Point(x0 + u * vx, y0 + u * vy));
            }
    
            var count = 100,
                minDist = Infinity,
                minT = 0;
    
            function refine(t) {
                if (t >= 0 && t <= 1) {
                    var dist = point.getDistance(Curve.getPoint(v, t), true);
                    if (dist < minDist) {
                        minDist = dist;
                        minT = t;
                        return true;
                    }
                }
            }
    
            for (var i = 0; i <= count; i++)
                refine(i / count);
    
            var step = 1 / (count * 2);
            while (step > 1e-8) {
                if (!refine(minT - step) && !refine(minT + step))
                    step /= 2;
            }
            return minT;
        },
    
        getPart: function(v, from, to) {
            var flip = from > to;
            if (flip) {
                var tmp = from;
                from = to;
                to = tmp;
            }
            if (from > 0)
                v = Curve.subdivide(v, from)[1];
            if (to < 1)
                v = Curve.subdivide(v, (to - from) / (1 - from))[0];
            return flip
                    ? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
                    : v;
        },
    
        isFlatEnough: function(v, flatness) {
            var x0 = v[0], y0 = v[1],
                x1 = v[2], y1 = v[3],
                x2 = v[4], y2 = v[5],
                x3 = v[6], y3 = v[7],
                ux = 3 * x1 - 2 * x0 - x3,
                uy = 3 * y1 - 2 * y0 - y3,
                vx = 3 * x2 - 2 * x3 - x0,
                vy = 3 * y2 - 2 * y3 - y0;
            return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
                    <= 16 * flatness * flatness;
        },
    
        getArea: function(v) {
            var x0 = v[0], y0 = v[1],
                x1 = v[2], y1 = v[3],
                x2 = v[4], y2 = v[5],
                x3 = v[6], y3 = v[7];
            return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)
                    + y1 * (x0 - x2) - x1 * (y0 - y2)
                    + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
        },
    
        getBounds: function(v) {
            var min = v.slice(0, 2),
                max = min.slice(),
                roots = [0, 0];
            for (var i = 0; i < 2; i++)
                Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
                        i, 0, min, max, roots);
            return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
        },
    
        _addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
            function add(value, padding) {
                var left = value - padding,
                    right = value + padding;
                if (left < min[coord])
                    min[coord] = left;
                if (right > max[coord])
                    max[coord] = right;
            }
    
            padding /= 2;
            var minPad = min[coord] - padding,
                maxPad = max[coord] + padding;
            if (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||
                    v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
                if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
                    add(v0, padding);
                    add(v3, padding);
                } else {
                    var a = 3 * (v1 - v2) - v0 + v3,
                        b = 2 * (v0 + v2) - 4 * v1,
                        c = v1 - v0,
                        count = Numerical.solveQuadratic(a, b, c, roots),
                        tMin = 1e-8,
                        tMax = 1 - tMin;
                    add(v3, 0);
                    for (var i = 0; i < count; i++) {
                        var t = roots[i],
                            u = 1 - t;
                        if (tMin <= t && t <= tMax)
                            add(u * u * u * v0
                                + 3 * u * u * t * v1
                                + 3 * u * t * t * v2
                                + t * t * t * v3,
                                padding);
                    }
                }
            }
        }
    }}, Base.each(
        ['getBounds', 'getStrokeBounds', 'getHandleBounds'],
        function(name) {
            this[name] = function() {
                if (!this._bounds)
                    this._bounds = {};
                var bounds = this._bounds[name];
                if (!bounds) {
                    bounds = this._bounds[name] = Path[name](
                            [this._segment1, this._segment2], false, this._path);
                }
                return bounds.clone();
            };
        },
    {
    
    }), Base.each({
        isStraight: function(p1, h1, h2, p2) {
            if (h1.isZero() && h2.isZero()) {
                return true;
            } else {
                var v = p2.subtract(p1);
                if (v.isZero()) {
                    return false;
                } else if (v.isCollinear(h1) && v.isCollinear(h2)) {
                    var l = new Line(p1, p2),
                        epsilon = 1e-7;
                    if (l.getDistance(p1.add(h1)) < epsilon &&
                        l.getDistance(p2.add(h2)) < epsilon) {
                        var div = v.dot(v),
                            s1 = v.dot(h1) / div,
                            s2 = v.dot(h2) / div;
                        return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
                    }
                }
            }
            return false;
        },
    
        isLinear: function(p1, h1, h2, p2) {
            var third = p2.subtract(p1).divide(3);
            return h1.equals(third) && h2.negate().equals(third);
        }
    }, function(test, name) {
        this[name] = function(epsilon) {
            var seg1 = this._segment1,
                seg2 = this._segment2;
            return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,
                    epsilon);
        };
    
        this.statics[name] = function(v, epsilon) {
            var x0 = v[0], y0 = v[1],
                x3 = v[6], y3 = v[7];
            return test(
                    new Point(x0, y0),
                    new Point(v[2] - x0, v[3] - y0),
                    new Point(v[4] - x3, v[5] - y3),
                    new Point(x3, y3), epsilon);
        };
    }, {
        statics: {},
    
        hasHandles: function() {
            return !this._segment1._handleOut.isZero()
                    || !this._segment2._handleIn.isZero();
        },
    
        hasLength: function(epsilon) {
            return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())
                    && this.getLength() > (epsilon || 0);
        },
    
        isCollinear: function(curve) {
            return curve && this.isStraight() && curve.isStraight()
                    && this.getLine().isCollinear(curve.getLine());
        },
    
        isHorizontal: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)
                    < 1e-8;
        },
    
        isVertical: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)
                    < 1e-8;
        }
    }), {
        beans: false,
    
        getLocationAt: function(offset, _isTime) {
            return this.getLocationAtTime(
                    _isTime ? offset : this.getTimeAt(offset));
        },
    
        getLocationAtTime: function(t) {
            return t != null && t >= 0 && t <= 1
                    ? new CurveLocation(this, t)
                    : null;
        },
    
        getTimeAt: function(offset, start) {
            return Curve.getTimeAt(this.getValues(), offset, start);
        },
    
        getParameterAt: '#getTimeAt',
    
        getOffsetAtTime: function(t) {
            return this.getPartLength(0, t);
        },
    
        getLocationOf: function() {
            return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
        },
    
        getOffsetOf: function() {
            var loc = this.getLocationOf.apply(this, arguments);
            return loc ? loc.getOffset() : null;
        },
    
        getTimeOf: function() {
            return Curve.getTimeOf(this.getValues(), Point.read(arguments));
        },
    
        getParameterOf: '#getTimeOf',
    
        getNearestLocation: function() {
            var point = Point.read(arguments),
                values = this.getValues(),
                t = Curve.getNearestTime(values, point),
                pt = Curve.getPoint(values, t);
            return new CurveLocation(this, t, pt, null, point.getDistance(pt));
        },
    
        getNearestPoint: function() {
            var loc = this.getNearestLocation.apply(this, arguments);
            return loc ? loc.getPoint() : loc;
        }
    
    },
    new function() {
        var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
            'getWeightedNormal', 'getCurvature'];
        return Base.each(methods,
            function(name) {
                this[name + 'At'] = function(location, _isTime) {
                    var values = this.getValues();
                    return Curve[name](values, _isTime ? location
                            : Curve.getTimeAt(values, location));
                };
    
                this[name + 'AtTime'] = function(time) {
                    return Curve[name](this.getValues(), time);
                };
            }, {
                statics: {
                    _evaluateMethods: methods
                }
            }
        );
    },
    new function() {
    
        function getLengthIntegrand(v) {
            var x0 = v[0], y0 = v[1],
                x1 = v[2], y1 = v[3],
                x2 = v[4], y2 = v[5],
                x3 = v[6], y3 = v[7],
    
                ax = 9 * (x1 - x2) + 3 * (x3 - x0),
                bx = 6 * (x0 + x2) - 12 * x1,
                cx = 3 * (x1 - x0),
    
                ay = 9 * (y1 - y2) + 3 * (y3 - y0),
                by = 6 * (y0 + y2) - 12 * y1,
                cy = 3 * (y1 - y0);
    
            return function(t) {
                var dx = (ax * t + bx) * t + cx,
                    dy = (ay * t + by) * t + cy;
                return Math.sqrt(dx * dx + dy * dy);
            };
        }
    
        function getIterations(a, b) {
            return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
        }
    
        function evaluate(v, t, type, normalized) {
            if (t == null || t < 0 || t > 1)
                return null;
            var x0 = v[0], y0 = v[1],
                x1 = v[2], y1 = v[3],
                x2 = v[4], y2 = v[5],
                x3 = v[6], y3 = v[7],
                isZero = Numerical.isZero;
            if (isZero(x1 - x0) && isZero(y1 - y0)) {
                x1 = x0;
                y1 = y0;
            }
            if (isZero(x2 - x3) && isZero(y2 - y3)) {
                x2 = x3;
                y2 = y3;
            }
            var cx = 3 * (x1 - x0),
                bx = 3 * (x2 - x1) - cx,
                ax = x3 - x0 - cx - bx,
                cy = 3 * (y1 - y0),
                by = 3 * (y2 - y1) - cy,
                ay = y3 - y0 - cy - by,
                x, y;
            if (type === 0) {
                x = t === 0 ? x0 : t === 1 ? x3
                        : ((ax * t + bx) * t + cx) * t + x0;
                y = t === 0 ? y0 : t === 1 ? y3
                        : ((ay * t + by) * t + cy) * t + y0;
            } else {
                var tMin = 1e-8,
                    tMax = 1 - tMin;
                if (t < tMin) {
                    x = cx;
                    y = cy;
                } else if (t > tMax) {
                    x = 3 * (x3 - x2);
                    y = 3 * (y3 - y2);
                } else {
                    x = (3 * ax * t + 2 * bx) * t + cx;
                    y = (3 * ay * t + 2 * by) * t + cy;
                }
                if (normalized) {
                    if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
                        x = x2 - x1;
                        y = y2 - y1;
                    }
                    var len = Math.sqrt(x * x + y * y);
                    if (len) {
                        x /= len;
                        y /= len;
                    }
                }
                if (type === 3) {
                    var x2 = 6 * ax * t + 2 * bx,
                        y2 = 6 * ay * t + 2 * by,
                        d = Math.pow(x * x + y * y, 3 / 2);
                    x = d !== 0 ? (x * y2 - y * x2) / d : 0;
                    y = 0;
                }
            }
            return type === 2 ? new Point(y, -x) : new Point(x, y);
        }
    
        return { statics: {
    
            classify: function(v) {
    
                var x0 = v[0], y0 = v[1],
                    x1 = v[2], y1 = v[3],
                    x2 = v[4], y2 = v[5],
                    x3 = v[6], y3 = v[7],
                    a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
                    a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
                    a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
                    d3 = 3 * a3,
                    d2 = d3 - a2,
                    d1 = d2 - a2 + a1,
                    l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
                    s = l !== 0 ? 1 / l : 0,
                    isZero = Numerical.isZero,
                    serpentine = 'serpentine';
                d1 *= s;
                d2 *= s;
                d3 *= s;
    
                function type(type, t1, t2) {
                    var hasRoots = t1 !== undefined,
                        t1Ok = hasRoots && t1 > 0 && t1 < 1,
                        t2Ok = hasRoots && t2 > 0 && t2 < 1;
                    if (hasRoots && (!(t1Ok || t2Ok)
                            || type === 'loop' && !(t1Ok && t2Ok))) {
                        type = 'arch';
                        t1Ok = t2Ok = false;
                    }
                    return {
                        type: type,
                        roots: t1Ok || t2Ok
                                ? t1Ok && t2Ok
                                    ? t1 < t2 ? [t1, t2] : [t2, t1]
                                    : [t1Ok ? t1 : t2]
                                : null
                    };
                }
    
                if (isZero(d1)) {
                    return isZero(d2)
                            ? type(isZero(d3) ? 'line' : 'quadratic')
                            : type(serpentine, d3 / (3 * d2));
                }
                var d = 3 * d2 * d2 - 4 * d1 * d3;
                if (isZero(d)) {
                    return type('cusp', d2 / (2 * d1));
                }
                var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
                    f2 = 2 * d1;
                return type(d > 0 ? serpentine : 'loop',
                        (d2 + f1) / f2,
                        (d2 - f1) / f2);
            },
    
            getLength: function(v, a, b, ds) {
                if (a === undefined)
                    a = 0;
                if (b === undefined)
                    b = 1;
                if (Curve.isStraight(v)) {
                    var c = v;
                    if (b < 1) {
                        c = Curve.subdivide(c, b)[0];
                        a /= b;
                    }
                    if (a > 0) {
                        c = Curve.subdivide(c, a)[1];
                    }
                    var dx = c[6] - c[0],
                        dy = c[7] - c[1];
                    return Math.sqrt(dx * dx + dy * dy);
                }
                return Numerical.integrate(ds || getLengthIntegrand(v), a, b,
                        getIterations(a, b));
            },
    
            getTimeAt: function(v, offset, start) {
                if (start === undefined)
                    start = offset < 0 ? 1 : 0;
                if (offset === 0)
                    return start;
                var abs = Math.abs,
                    epsilon = 1e-12,
                    forward = offset > 0,
                    a = forward ? start : 0,
                    b = forward ? 1 : start,
                    ds = getLengthIntegrand(v),
                    rangeLength = Curve.getLength(v, a, b, ds),
                    diff = abs(offset) - rangeLength;
                if (abs(diff) < epsilon) {
                    return forward ? b : a;
                } else if (diff > epsilon) {
                    return null;
                }
                var guess = offset / rangeLength,
                    length = 0;
                function f(t) {
                    length += Numerical.integrate(ds, start, t,
                            getIterations(start, t));
                    start = t;
                    return length - offset;
                }
                return Numerical.findRoot(f, ds, start + guess, a, b, 32,
                        1e-12);
            },
    
            getPoint: function(v, t) {
                return evaluate(v, t, 0, false);
            },
    
            getTangent: function(v, t) {
                return evaluate(v, t, 1, true);
            },
    
            getWeightedTangent: function(v, t) {
                return evaluate(v, t, 1, false);
            },
    
            getNormal: function(v, t) {
                return evaluate(v, t, 2, true);
            },
    
            getWeightedNormal: function(v, t) {
                return evaluate(v, t, 2, false);
            },
    
            getCurvature: function(v, t) {
                return evaluate(v, t, 3, false).x;
            },
    
            getPeaks: function(v) {
                var x0 = v[0], y0 = v[1],
                    x1 = v[2], y1 = v[3],
                    x2 = v[4], y2 = v[5],
                    x3 = v[6], y3 = v[7],
                    ax =     -x0 + 3 * x1 - 3 * x2 + x3,
                    bx =  3 * x0 - 6 * x1 + 3 * x2,
                    cx = -3 * x0 + 3 * x1,
                    ay =     -y0 + 3 * y1 - 3 * y2 + y3,
                    by =  3 * y0 - 6 * y1 + 3 * y2,
                    cy = -3 * y0 + 3 * y1,
                    tMin = 1e-8,
                    tMax = 1 - tMin,
                    roots = [];
                Numerical.solveCubic(
                        9 * (ax * ax + ay * ay),
                        9 * (ax * bx + by * ay),
                        2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),
                        (cx * bx + by * cy),
                        roots, tMin, tMax);
                return roots.sort();
            }
        }};
    },
    new function() {
    
        function addLocation(locations, include, c1, t1, c2, t2, overlap) {
            var excludeStart = !overlap && c1.getPrevious() === c2,
                excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
                tMin = 1e-8,
                tMax = 1 - tMin;
            if (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&
                t1 <= (excludeEnd ? tMax : 1)) {
                if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&
                    t2 <= (excludeStart ? tMax : 1)) {
                    var loc1 = new CurveLocation(c1, t1, null, overlap),
                        loc2 = new CurveLocation(c2, t2, null, overlap);
                    loc1._intersection = loc2;
                    loc2._intersection = loc1;
                    if (!include || include(loc1)) {
                        CurveLocation.insert(locations, loc1, true);
                    }
                }
            }
        }
    
        function addCurveIntersections(v1, v2, c1, c2, locations, include, flip,
                recursion, calls, tMin, tMax, uMin, uMax) {
            if (++calls >= 4096 || ++recursion >= 40)
                return calls;
            var fatLineEpsilon = 1e-9,
                q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
                getSignedDistance = Line.getSignedDistance,
                d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
                d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
                factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
                dMin = factor * Math.min(0, d1, d2),
                dMax = factor * Math.max(0, d1, d2),
                dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
                dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
                dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
                dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
                hull = getConvexHull(dp0, dp1, dp2, dp3),
                top = hull[0],
                bottom = hull[1],
                tMinClip,
                tMaxClip;
            if (d1 === 0 && d2 === 0
                    && dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0
                || (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null
                || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
                    dMin, dMax)) == null)
                return calls;
            var tMinNew = tMin + (tMax - tMin) * tMinClip,
                tMaxNew = tMin + (tMax - tMin) * tMaxClip;
            if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
                var t = (tMinNew + tMaxNew) / 2,
                    u = (uMin + uMax) / 2;
                addLocation(locations, include,
                        flip ? c2 : c1, flip ? u : t,
                        flip ? c1 : c2, flip ? t : u);
            } else {
                v1 = Curve.getPart(v1, tMinClip, tMaxClip);
                if (tMaxClip - tMinClip > 0.8) {
                    if (tMaxNew - tMinNew > uMax - uMin) {
                        var parts = Curve.subdivide(v1, 0.5),
                            t = (tMinNew + tMaxNew) / 2;
                        calls = addCurveIntersections(
                                v2, parts[0], c2, c1, locations, include, !flip,
                                recursion, calls, uMin, uMax, tMinNew, t);
                        calls = addCurveIntersections(
                                v2, parts[1], c2, c1, locations, include, !flip,
                                recursion, calls, uMin, uMax, t, tMaxNew);
                    } else {
                        var parts = Curve.subdivide(v2, 0.5),
                            u = (uMin + uMax) / 2;
                        calls = addCurveIntersections(
                                parts[0], v1, c2, c1, locations, include, !flip,
                                recursion, calls, uMin, u, tMinNew, tMaxNew);
                        calls = addCurveIntersections(
                                parts[1], v1, c2, c1, locations, include, !flip,
                                recursion, calls, u, uMax, tMinNew, tMaxNew);
                    }
                } else {
                    if (uMax - uMin >= fatLineEpsilon) {
                        calls = addCurveIntersections(
                                v2, v1, c2, c1, locations, include, !flip,
                                recursion, calls, uMin, uMax, tMinNew, tMaxNew);
                    } else {
                        calls = addCurveIntersections(
                                v1, v2, c1, c2, locations, include, flip,
                                recursion, calls, tMinNew, tMaxNew, uMin, uMax);
                    }
                }
            }
            return calls;
        }
    
        function getConvexHull(dq0, dq1, dq2, dq3) {
            var p0 = [ 0, dq0 ],
                p1 = [ 1 / 3, dq1 ],
                p2 = [ 2 / 3, dq2 ],
                p3 = [ 1, dq3 ],
                dist1 = dq1 - (2 * dq0 + dq3) / 3,
                dist2 = dq2 - (dq0 + 2 * dq3) / 3,
                hull;
            if (dist1 * dist2 < 0) {
                hull = [[p0, p1, p3], [p0, p2, p3]];
            } else {
                var distRatio = dist1 / dist2;
                hull = [
                    distRatio >= 2 ? [p0, p1, p3]
                    : distRatio <= 0.5 ? [p0, p2, p3]
                    : [p0, p1, p2, p3],
                    [p0, p3]
                ];
            }
            return (dist1 || dist2) < 0 ? hull.reverse() : hull;
        }
    
        function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
            if (hullTop[0][1] < dMin) {
                return clipConvexHullPart(hullTop, true, dMin);
            } else if (hullBottom[0][1] > dMax) {
                return clipConvexHullPart(hullBottom, false, dMax);
            } else {
                return hullTop[0][0];
            }
        }
    
        function clipConvexHullPart(part, top, threshold) {
            var px = part[0][0],
                py = part[0][1];
            for (var i = 1, l = part.length; i < l; i++) {
                var qx = part[i][0],
                    qy = part[i][1];
                if (top ? qy >= threshold : qy <= threshold) {
                    return qy === threshold ? qx
                            : px + (threshold - py) * (qx - px) / (qy - py);
                }
                px = qx;
                py = qy;
            }
            return null;
        }
    
        function getCurveLineIntersections(v, px, py, vx, vy) {
            var isZero = Numerical.isZero;
            if (isZero(vx) && isZero(vy)) {
                var t = Curve.getTimeOf(v, new Point(px, py));
                return t === null ? [] : [t];
            }
            var angle = Math.atan2(-vy, vx),
                sin = Math.sin(angle),
                cos = Math.cos(angle),
                rv = [],
                roots = [];
            for (var i = 0; i < 8; i += 2) {
                var x = v[i] - px,
                    y = v[i + 1] - py;
                rv.push(
                    x * cos - y * sin,
                    x * sin + y * cos);
            }
            Curve.solveCubic(rv, 1, 0, roots, 0, 1);
            return roots;
        }
    
        function addCurveLineIntersections(v1, v2, c1, c2, locations, include,
                flip) {
            var x1 = v2[0], y1 = v2[1],
                x2 = v2[6], y2 = v2[7],
                roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);
            for (var i = 0, l = roots.length; i < l; i++) {
                var t1 = roots[i],
                    p1 = Curve.getPoint(v1, t1),
                    t2 = Curve.getTimeOf(v2, p1);
                if (t2 !== null) {
                    addLocation(locations, include,
                            flip ? c2 : c1, flip ? t2 : t1,
                            flip ? c1 : c2, flip ? t1 : t2);
                }
            }
        }
    
        function addLineIntersection(v1, v2, c1, c2, locations, include) {
            var pt = Line.intersect(
                    v1[0], v1[1], v1[6], v1[7],
                    v2[0], v2[1], v2[6], v2[7]);
            if (pt) {
                addLocation(locations, include,
                        c1, Curve.getTimeOf(v1, pt),
                        c2, Curve.getTimeOf(v2, pt));
            }
        }
    
        function getCurveIntersections(v1, v2, c1, c2, locations, include) {
            var epsilon = 1e-12,
                min = Math.min,
                max = Math.max;
    
            if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >
                min(v2[0], v2[2], v2[4], v2[6]) &&
                min(v1[0], v1[2], v1[4], v1[6]) - epsilon <
                max(v2[0], v2[2], v2[4], v2[6]) &&
                max(v1[1], v1[3], v1[5], v1[7]) + epsilon >
                min(v2[1], v2[3], v2[5], v2[7]) &&
                min(v1[1], v1[3], v1[5], v1[7]) - epsilon <
                max(v2[1], v2[3], v2[5], v2[7])) {
                var overlaps = getOverlaps(v1, v2);
                if (overlaps) {
                    for (var i = 0; i < 2; i++) {
                        var overlap = overlaps[i];
                        addLocation(locations, include,
                                c1, overlap[0],
                                c2, overlap[1], true);
                    }
                } else {
                    var straight1 = Curve.isStraight(v1),
                        straight2 = Curve.isStraight(v2),
                        straight = straight1 && straight2,
                        flip = straight1 && !straight2,
                        before = locations.length;
                    (straight
                        ? addLineIntersection
                        : straight1 || straight2
                            ? addCurveLineIntersections
                            : addCurveIntersections)(
                                flip ? v2 : v1, flip ? v1 : v2,
                                flip ? c2 : c1, flip ? c1 : c2,
                                locations, include, flip,
                                0, 0, 0, 1, 0, 1);
                    if (!straight || locations.length === before) {
                        for (var i = 0; i < 4; i++) {
                            var t1 = i >> 1,
                                t2 = i & 1,
                                i1 = t1 * 6,
                                i2 = t2 * 6,
                                p1 = new Point(v1[i1], v1[i1 + 1]),
                                p2 = new Point(v2[i2], v2[i2 + 1]);
                            if (p1.isClose(p2, epsilon)) {
                                addLocation(locations, include,
                                        c1, t1,
                                        c2, t2);
                            }
                        }
                    }
                }
            }
            return locations;
        }
    
        function getLoopIntersection(v1, c1, locations, include) {
            var info = Curve.classify(v1);
            if (info.type === 'loop') {
                var roots = info.roots;
                addLocation(locations, include,
                        c1, roots[0],
                        c1, roots[1]);
            }
          return locations;
        }
    
        function getIntersections(curves1, curves2, include, matrix1, matrix2,
                _returnFirst) {
            var self = !curves2;
            if (self)
                curves2 = curves1;
            var length1 = curves1.length,
                length2 = curves2.length,
                values2 = [],
                arrays = [],
                locations,
                current;
            for (var i = 0; i < length2; i++)
                values2[i] = curves2[i].getValues(matrix2);
            for (var i = 0; i < length1; i++) {
                var curve1 = curves1[i],
                    values1 = self ? values2[i] : curve1.getValues(matrix1),
                    path1 = curve1.getPath();
                if (path1 !== current) {
                    current = path1;
                    locations = [];
                    arrays.push(locations);
                }
                if (self) {
                    getLoopIntersection(values1, curve1, locations, include);
                }
                for (var j = self ? i + 1 : 0; j < length2; j++) {
                    if (_returnFirst && locations.length)
                        return locations;
                    getCurveIntersections(values1, values2[j], curve1, curves2[j],
                            locations, include);
                }
            }
            locations = [];
            for (var i = 0, l = arrays.length; i < l; i++) {
                locations.push.apply(locations, arrays[i]);
            }
            return locations;
        }
    
        function getOverlaps(v1, v2) {
    
            function getSquaredLineLength(v) {
                var x = v[6] - v[0],
                    y = v[7] - v[1];
                return x * x + y * y;
            }
    
            var abs = Math.abs,
                getDistance = Line.getDistance,
                timeEpsilon = 1e-8,
                geomEpsilon = 1e-7,
                straight1 = Curve.isStraight(v1),
                straight2 = Curve.isStraight(v2),
                straightBoth = straight1 && straight2,
                flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
                l1 = flip ? v2 : v1,
                l2 = flip ? v1 : v2,
                px = l1[0], py = l1[1],
                vx = l1[6] - px, vy = l1[7] - py;
            if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&
                getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
                if (!straightBoth &&
                    getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&
                    getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&
                    getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&
                    getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
                    straight1 = straight2 = straightBoth = true;
                }
            } else if (straightBoth) {
                return null;
            }
            if (straight1 ^ straight2) {
                return null;
            }
    
            var v = [v1, v2],
                pairs = [];
            for (var i = 0; i < 4 && pairs.length < 2; i++) {
                var i1 = i & 1,
                    i2 = i1 ^ 1,
                    t1 = i >> 1,
                    t2 = Curve.getTimeOf(v[i1], new Point(
                        v[i2][t1 ? 6 : 0],
                        v[i2][t1 ? 7 : 1]));
                if (t2 != null) {
                    var pair = i1 ? [t1, t2] : [t2, t1];
                    if (!pairs.length ||
                        abs(pair[0] - pairs[0][0]) > timeEpsilon &&
                        abs(pair[1] - pairs[0][1]) > timeEpsilon) {
                        pairs.push(pair);
                    }
                }
                if (i > 2 && !pairs.length)
                    break;
            }
            if (pairs.length !== 2) {
                pairs = null;
            } else if (!straightBoth) {
                var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
                    o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
                if (abs(o2[2] - o1[2]) > geomEpsilon ||
                    abs(o2[3] - o1[3]) > geomEpsilon ||
                    abs(o2[4] - o1[4]) > geomEpsilon ||
                    abs(o2[5] - o1[5]) > geomEpsilon)
                    pairs = null;
            }
            return pairs;
        }
    
        return {
            getIntersections: function(curve) {
                var v1 = this.getValues(),
                    v2 = curve && curve !== this && curve.getValues();
                return v2 ? getCurveIntersections(v1, v2, this, curve, [])
                          : getLoopIntersection(v1, this, []);
            },
    
            statics: {
                getOverlaps: getOverlaps,
                getIntersections: getIntersections,
                getCurveLineIntersections: getCurveLineIntersections
            }
        };
    });
    
    var CurveLocation = Base.extend({
        _class: 'CurveLocation',
    
        initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
            if (time >= 0.99999999) {
                var next = curve.getNext();
                if (next) {
                    time = 0;
                    curve = next;
                }
            }
            this._setCurve(curve);
            this._time = time;
            this._point = point || curve.getPointAtTime(time);
            this._overlap = _overlap;
            this._distance = _distance;
            this._intersection = this._next = this._previous = null;
        },
    
        _setCurve: function(curve) {
            var path = curve._path;
            this._path = path;
            this._version = path ? path._version : 0;
            this._curve = curve;
            this._segment = null;
            this._segment1 = curve._segment1;
            this._segment2 = curve._segment2;
        },
    
        _setSegment: function(segment) {
            this._setCurve(segment.getCurve());
            this._segment = segment;
            this._time = segment === this._segment1 ? 0 : 1;
            this._point = segment._point.clone();
        },
    
        getSegment: function() {
            var segment = this._segment;
            if (!segment) {
                var curve = this.getCurve(),
                    time = this.getTime();
                if (time === 0) {
                    segment = curve._segment1;
                } else if (time === 1) {
                    segment = curve._segment2;
                } else if (time != null) {
                    segment = curve.getPartLength(0, time)
                        < curve.getPartLength(time, 1)
                            ? curve._segment1
                            : curve._segment2;
                }
                this._segment = segment;
            }
            return segment;
        },
    
        getCurve: function() {
            var path = this._path,
                that = this;
            if (path && path._version !== this._version) {
                this._time = this._offset = this._curveOffset = this._curve = null;
            }
    
            function trySegment(segment) {
                var curve = segment && segment.getCurve();
                if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
                    that._setCurve(curve);
                    return curve;
                }
            }
    
            return this._curve
                || trySegment(this._segment)
                || trySegment(this._segment1)
                || trySegment(this._segment2.getPrevious());
        },
    
        getPath: function() {
            var curve = this.getCurve();
            return curve && curve._path;
        },
    
        getIndex: function() {
            var curve = this.getCurve();
            return curve && curve.getIndex();
        },
    
        getTime: function() {
            var curve = this.getCurve(),
                time = this._time;
            return curve && time == null
                ? this._time = curve.getTimeOf(this._point)
                : time;
        },
    
        getParameter: '#getTime',
    
        getPoint: function() {
            return this._point;
        },
    
        getOffset: function() {
            var offset = this._offset;
            if (offset == null) {
                offset = 0;
                var path = this.getPath(),
                    index = this.getIndex();
                if (path && index != null) {
                    var curves = path.getCurves();
                    for (var i = 0; i < index; i++)
                        offset += curves[i].getLength();
                }
                this._offset = offset += this.getCurveOffset();
            }
            return offset;
        },
    
        getCurveOffset: function() {
            var offset = this._curveOffset;
            if (offset == null) {
                var curve = this.getCurve(),
                    time = this.getTime();
                this._curveOffset = offset = time != null && curve
                        && curve.getPartLength(0, time);
            }
            return offset;
        },
    
        getIntersection: function() {
            return this._intersection;
        },
    
        getDistance: function() {
            return this._distance;
        },
    
        divide: function() {
            var curve = this.getCurve(),
                res = curve && curve.divideAtTime(this.getTime());
            if (res) {
                this._setSegment(res._segment1);
            }
            return res;
        },
    
        split: function() {
            var curve = this.getCurve(),
                path = curve._path,
                res = curve && curve.splitAtTime(this.getTime());
            if (res) {
                this._setSegment(path.getLastSegment());
            }
            return  res;
        },
    
        equals: function(loc, _ignoreOther) {
            var res = this === loc;
            if (!res && loc instanceof CurveLocation) {
                var c1 = this.getCurve(),
                    c2 = loc.getCurve(),
                    p1 = c1._path,
                    p2 = c2._path;
                if (p1 === p2) {
                    var abs = Math.abs,
                        epsilon = 1e-7,
                        diff = abs(this.getOffset() - loc.getOffset()),
                        i1 = !_ignoreOther && this._intersection,
                        i2 = !_ignoreOther && loc._intersection;
                    res = (diff < epsilon
                            || p1 && abs(p1.getLength() - diff) < epsilon)
                        && (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
                }
            }
            return res;
        },
    
        toString: function() {
            var parts = [],
                point = this.getPoint(),
                f = Formatter.instance;
            if (point)
                parts.push('point: ' + point);
            var index = this.getIndex();
            if (index != null)
                parts.push('index: ' + index);
            var time = this.getTime();
            if (time != null)
                parts.push('time: ' + f.number(time));
            if (this._distance != null)
                parts.push('distance: ' + f.number(this._distance));
            return '{ ' + parts.join(', ') + ' }';
        },
    
        isTouching: function() {
            var inter = this._intersection;
            if (inter && this.getTangent().isCollinear(inter.getTangent())) {
                var curve1 = this.getCurve(),
                    curve2 = inter.getCurve();
                return !(curve1.isStraight() && curve2.isStraight()
                        && curve1.getLine().intersect(curve2.getLine()));
            }
            return false;
        },
    
        isCrossing: function() {
            var inter = this._intersection;
            if (!inter)
                return false;
            var t1 = this.getTime(),
                t2 = inter.getTime(),
                tMin = 1e-8,
                tMax = 1 - tMin,
                t1Inside = t1 >= tMin && t1 <= tMax,
                t2Inside = t2 >= tMin && t2 <= tMax;
            if (t1Inside && t2Inside)
                return !this.isTouching();
            var c2 = this.getCurve(),
                c1 = t1 < tMin ? c2.getPrevious() : c2,
                c4 = inter.getCurve(),
                c3 = t2 < tMin ? c4.getPrevious() : c4;
            if (t1 > tMax)
                c2 = c2.getNext();
            if (t2 > tMax)
                c4 = c4.getNext();
            if (!c1 || !c2 || !c3 || !c4)
                return false;
    
            var offsets = [];
    
            function addOffsets(curve, end) {
                var v = curve.getValues(),
                    roots = Curve.classify(v).roots || Curve.getPeaks(v),
                    count = roots.length,
                    t = end && count > 1 ? roots[count - 1]
                            : count > 0 ? roots[0]
                            : 0.5;
                offsets.push(Curve.getLength(v, end ? t : 0, end ? 1 : t) / 2);
            }
    
            function isInRange(angle, min, max) {
                return min < max
                        ? angle > min && angle < max
                        : angle > min || angle < max;
            }
    
            if (!t1Inside) {
                addOffsets(c1, true);
                addOffsets(c2, false);
            }
            if (!t2Inside) {
                addOffsets(c3, true);
                addOffsets(c4, false);
            }
            var pt = this.getPoint(),
                offset = Math.min.apply(Math, offsets),
                v2 = t1Inside ? c2.getTangentAtTime(t1)
                        : c2.getPointAt(offset).subtract(pt),
                v1 = t1Inside ? v2.negate()
                        : c1.getPointAt(-offset).subtract(pt),
                v4 = t2Inside ? c4.getTangentAtTime(t2)
                        : c4.getPointAt(offset).subtract(pt),
                v3 = t2Inside ? v4.negate()
                        : c3.getPointAt(-offset).subtract(pt),
                a1 = v1.getAngle(),
                a2 = v2.getAngle(),
                a3 = v3.getAngle(),
                a4 = v4.getAngle();
            return !!(t1Inside
                    ? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&
                      (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))
                    : (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&
                      (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));
        },
    
        hasOverlap: function() {
            return !!this._overlap;
        }
    }, Base.each(Curve._evaluateMethods, function(name) {
        var get = name + 'At';
        this[name] = function() {
            var curve = this.getCurve(),
                time = this.getTime();
            return time != null && curve && curve[get](time, true);
        };
    }, {
        preserve: true
    }),
    new function() {
    
        function insert(locations, loc, merge) {
            var length = locations.length,
                l = 0,
                r = length - 1;
    
            function search(index, dir) {
                for (var i = index + dir; i >= -1 && i <= length; i += dir) {
                    var loc2 = locations[((i % length) + length) % length];
                    if (!loc.getPoint().isClose(loc2.getPoint(),
                            1e-7))
                        break;
                    if (loc.equals(loc2))
                        return loc2;
                }
                return null;
            }
    
            while (l <= r) {
                var m = (l + r) >>> 1,
                    loc2 = locations[m],
                    found;
                if (merge && (found = loc.equals(loc2) ? loc2
                        : (search(m, -1) || search(m, 1)))) {
                    if (loc._overlap) {
                        found._overlap = found._intersection._overlap = true;
                    }
                    return found;
                }
            var path1 = loc.getPath(),
                path2 = loc2.getPath(),
                diff = path1 !== path2
                    ? path1._id - path2._id
                    : (loc.getIndex() + loc.getTime())
                    - (loc2.getIndex() + loc2.getTime());
                if (diff < 0) {
                    r = m - 1;
                } else {
                    l = m + 1;
                }
            }
            locations.splice(l, 0, loc);
            return loc;
        }
    
        return { statics: {
            insert: insert,
    
            expand: function(locations) {
                var expanded = locations.slice();
                for (var i = locations.length - 1; i >= 0; i--) {
                    insert(expanded, locations[i]._intersection, false);
                }
                return expanded;
            }
        }};
    });
    
    var PathItem = Item.extend({
        _class: 'PathItem',
        _selectBounds: false,
        _canScaleStroke: true,
        beans: true,
    
        initialize: function PathItem() {
        },
    
        statics: {
            create: function(arg) {
                var data,
                    segments,
                    compound;
                if (Base.isPlainObject(arg)) {
                    segments = arg.segments;
                    data = arg.pathData;
                } else if (Array.isArray(arg)) {
                    segments = arg;
                } else if (typeof arg === 'string') {
                    data = arg;
                }
                if (segments) {
                    var first = segments[0];
                    compound = first && Array.isArray(first[0]);
                } else if (data) {
                    compound = (data.match(/m/gi) || []).length > 1
                            || /z\s*\S+/i.test(data);
                }
                var ctor = compound ? CompoundPath : Path;
                return new ctor(arg);
            }
        },
    
        _asPathItem: function() {
            return this;
        },
    
        isClockwise: function() {
            return this.getArea() >= 0;
        },
    
        setClockwise: function(clockwise) {
            if (this.isClockwise() != (clockwise = !!clockwise))
                this.reverse();
        },
    
        setPathData: function(data) {
    
            var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
                coords,
                relative = false,
                previous,
                control,
                current = new Point(),
                start = new Point();
    
            function getCoord(index, coord) {
                var val = +coords[index];
                if (relative)
                    val += current[coord];
                return val;
            }
    
            function getPoint(index) {
                return new Point(
                    getCoord(index, 'x'),
                    getCoord(index + 1, 'y')
                );
            }
    
            this.clear();
    
            for (var i = 0, l = parts && parts.length; i < l; i++) {
                var part = parts[i],
                    command = part[0],
                    lower = command.toLowerCase();
                coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
                var length = coords && coords.length;
                relative = command === lower;
                if (previous === 'z' && !/[mz]/.test(lower))
                    this.moveTo(current);
                switch (lower) {
                case 'm':
                case 'l':
                    var move = lower === 'm';
                    for (var j = 0; j < length; j += 2) {
                        this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));
                        if (move) {
                            start = current;
                            move = false;
                        }
                    }
                    control = current;
                    break;
                case 'h':
                case 'v':
                    var coord = lower === 'h' ? 'x' : 'y';
                    current = current.clone();
                    for (var j = 0; j < length; j++) {
                        current[coord] = getCoord(j, coord);
                        this.lineTo(current);
                    }
                    control = current;
                    break;
                case 'c':
                    for (var j = 0; j < length; j += 6) {
                        this.cubicCurveTo(
                                getPoint(j),
                                control = getPoint(j + 2),
                                current = getPoint(j + 4));
                    }
                    break;
                case 's':
                    for (var j = 0; j < length; j += 4) {
                        this.cubicCurveTo(
                                /[cs]/.test(previous)
                                        ? current.multiply(2).subtract(control)
                                        : current,
                                control = getPoint(j),
                                current = getPoint(j + 2));
                        previous = lower;
                    }
                    break;
                case 'q':
                    for (var j = 0; j < length; j += 4) {
                        this.quadraticCurveTo(
                                control = getPoint(j),
                                current = getPoint(j + 2));
                    }
                    break;
                case 't':
                    for (var j = 0; j < length; j += 2) {
                        this.quadraticCurveTo(
                                control = (/[qt]/.test(previous)
                                        ? current.multiply(2).subtract(control)
                                        : current),
                                current = getPoint(j));
                        previous = lower;
                    }
                    break;
                case 'a':
                    for (var j = 0; j < length; j += 7) {
                        this.arcTo(current = getPoint(j + 5),
                                new Size(+coords[j], +coords[j + 1]),
                                +coords[j + 2], +coords[j + 4], +coords[j + 3]);
                    }
                    break;
                case 'z':
                    this.closePath(1e-12);
                    current = start;
                    break;
                }
                previous = lower;
            }
        },
    
        _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
        },
    
        _contains: function(point) {
            var winding = point.isInside(
                    this.getBounds({ internal: true, handle: true }))
                        ? this._getWinding(point)
                        : {};
            return winding.onPath || !!(this.getFillRule() === 'evenodd'
                    ? winding.windingL & 1 || winding.windingR & 1
                    : winding.winding);
        },
    
        getIntersections: function(path, include, _matrix, _returnFirst) {
            var self = this === path || !path,
                matrix1 = this._matrix._orNullIfIdentity(),
                matrix2 = self ? matrix1
                    : (_matrix || path._matrix)._orNullIfIdentity();
            return self || this.getBounds(matrix1).intersects(
                    path.getBounds(matrix2), 1e-12)
                    ? Curve.getIntersections(
                            this.getCurves(), !self && path.getCurves(), include,
                            matrix1, matrix2, _returnFirst)
                    : [];
        },
    
        getCrossings: function(path) {
            return this.getIntersections(path, function(inter) {
                return inter.hasOverlap() || inter.isCrossing();
            });
        },
    
        getNearestLocation: function() {
            var point = Point.read(arguments),
                curves = this.getCurves(),
                minDist = Infinity,
                minLoc = null;
            for (var i = 0, l = curves.length; i < l; i++) {
                var loc = curves[i].getNearestLocation(point);
                if (loc._distance < minDist) {
                    minDist = loc._distance;
                    minLoc = loc;
                }
            }
            return minLoc;
        },
    
        getNearestPoint: function() {
            var loc = this.getNearestLocation.apply(this, arguments);
            return loc ? loc.getPoint() : loc;
        },
    
        interpolate: function(from, to, factor) {
            var isPath = !this._children,
                name = isPath ? '_segments' : '_children',
                itemsFrom = from[name],
                itemsTo = to[name],
                items = this[name];
            if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
                throw new Error('Invalid operands in interpolate() call: ' +
                        from + ', ' + to);
            }
            var current = items.length,
                length = itemsTo.length;
            if (current < length) {
                var ctor = isPath ? Segment : Path;
                for (var i = current; i < length; i++) {
                    this.add(new ctor());
                }
            } else if (current > length) {
                this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
            }
            for (var i = 0; i < length; i++) {
                items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
            }
            if (isPath) {
                this.setClosed(from._closed);
                this._changed(9);
            }
        },
    
        compare: function(path) {
            var ok = false;
            if (path) {
                var paths1 = this._children || [this],
                    paths2 = path._children ? path._children.slice() : [path],
                    length1 = paths1.length,
                    length2 = paths2.length,
                    matched = [],
                    count = 0;
                ok = true;
                for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
                    var path1 = paths1[i1];
                    ok = false;
                    for (var i2 = length2 - 1; i2 >= 0 && !ok; i2--) {
                        if (path1.compare(paths2[i2])) {
                            if (!matched[i2]) {
                                matched[i2] = true;
                                count++;
                            }
                            ok = true;
                        }
                    }
                }
                ok = ok && count === length2;
            }
            return ok;
        },
    
    });
    
    var Path = PathItem.extend({
        _class: 'Path',
        _serializeFields: {
            segments: [],
            closed: false
        },
    
        initialize: function Path(arg) {
            this._closed = false;
            this._segments = [];
            this._version = 0;
            var segments = Array.isArray(arg)
                ? typeof arg[0] === 'object'
                    ? arg
                    : arguments
                : arg && (arg.size === undefined && (arg.x !== undefined
                        || arg.point !== undefined))
                    ? arguments
                    : null;
            if (segments && segments.length > 0) {
                this.setSegments(segments);
            } else {
                this._curves = undefined;
                this._segmentSelection = 0;
                if (!segments && typeof arg === 'string') {
                    this.setPathData(arg);
                    arg = null;
                }
            }
            this._initialize(!segments && arg);
        },
    
        _equals: function(item) {
            return this._closed === item._closed
                    && Base.equals(this._segments, item._segments);
        },
    
        copyContent: function(source) {
            this.setSegments(source._segments);
            this._closed = source._closed;
        },
    
        _changed: function _changed(flags) {
            _changed.base.call(this, flags);
            if (flags & 8) {
                this._length = this._area = undefined;
                if (flags & 16) {
                    this._version++;
                } else if (this._curves) {
                   for (var i = 0, l = this._curves.length; i < l; i++)
                        this._curves[i]._changed();
                }
            } else if (flags & 32) {
                this._bounds = undefined;
            }
        },
    
        getStyle: function() {
            var parent = this._parent;
            return (parent instanceof CompoundPath ? parent : this)._style;
        },
    
        getSegments: function() {
            return this._segments;
        },
    
        setSegments: function(segments) {
            var fullySelected = this.isFullySelected(),
                length = segments && segments.length;
            this._segments.length = 0;
            this._segmentSelection = 0;
            this._curves = undefined;
            if (length) {
                var last = segments[length - 1];
                if (typeof last === 'boolean') {
                    this.setClosed(last);
                    length--;
                }
                this._add(Segment.readList(segments, 0, {}, length));
            }
            if (fullySelected)
                this.setFullySelected(true);
        },
    
        getFirstSegment: function() {
            return this._segments[0];
        },
    
        getLastSegment: function() {
            return this._segments[this._segments.length - 1];
        },
    
        getCurves: function() {
            var curves = this._curves,
                segments = this._segments;
            if (!curves) {
                var length = this._countCurves();
                curves = this._curves = new Array(length);
                for (var i = 0; i < length; i++)
                    curves[i] = new Curve(this, segments[i],
                        segments[i + 1] || segments[0]);
            }
            return curves;
        },
    
        getFirstCurve: function() {
            return this.getCurves()[0];
        },
    
        getLastCurve: function() {
            var curves = this.getCurves();
            return curves[curves.length - 1];
        },
    
        isClosed: function() {
            return this._closed;
        },
    
        setClosed: function(closed) {
            if (this._closed != (closed = !!closed)) {
                this._closed = closed;
                if (this._curves) {
                    var length = this._curves.length = this._countCurves();
                    if (closed)
                        this._curves[length - 1] = new Curve(this,
                            this._segments[length - 1], this._segments[0]);
                }
                this._changed(25);
            }
        }
    }, {
        beans: true,
    
        getPathData: function(_matrix, _precision) {
            var segments = this._segments,
                length = segments.length,
                f = new Formatter(_precision),
                coords = new Array(6),
                first = true,
                curX, curY,
                prevX, prevY,
                inX, inY,
                outX, outY,
                parts = [];
    
            function addSegment(segment, skipLine) {
                segment._transformCoordinates(_matrix, coords);
                curX = coords[0];
                curY = coords[1];
                if (first) {
                    parts.push('M' + f.pair(curX, curY));
                    first = false;
                } else {
                    inX = coords[2];
                    inY = coords[3];
                    if (inX === curX && inY === curY
                            && outX === prevX && outY === prevY) {
                        if (!skipLine) {
                            var dx = curX - prevX,
                                dy = curY - prevY;
                            parts.push(
                                  dx === 0 ? 'v' + f.number(dy)
                                : dy === 0 ? 'h' + f.number(dx)
                                : 'l' + f.pair(dx, dy));
                        }
                    } else {
                        parts.push('c' + f.pair(outX - prevX, outY - prevY)
                                 + ' ' + f.pair( inX - prevX,  inY - prevY)
                                 + ' ' + f.pair(curX - prevX, curY - prevY));
                    }
                }
                prevX = curX;
                prevY = curY;
                outX = coords[4];
                outY = coords[5];
            }
    
            if (!length)
                return '';
    
            for (var i = 0; i < length; i++)
                addSegment(segments[i]);
            if (this._closed && length > 0) {
                addSegment(segments[0], true);
                parts.push('z');
            }
            return parts.join('');
        },
    
        isEmpty: function() {
            return !this._segments.length;
        },
    
        _transformContent: function(matrix) {
            var segments = this._segments,
                coords = new Array(6);
            for (var i = 0, l = segments.length; i < l; i++)
                segments[i]._transformCoordinates(matrix, coords, true);
            return true;
        },
    
        _add: function(segs, index) {
            var segments = this._segments,
                curves = this._curves,
                amount = segs.length,
                append = index == null,
                index = append ? segments.length : index;
            for (var i = 0; i < amount; i++) {
                var segment = segs[i];
                if (segment._path)
                    segment = segs[i] = segment.clone();
                segment._path = this;
                segment._index = index + i;
                if (segment._selection)
                    this._updateSelection(segment, 0, segment._selection);
            }
            if (append) {
                segments.push.apply(segments, segs);
            } else {
                segments.splice.apply(segments, [index, 0].concat(segs));
                for (var i = index + amount, l = segments.length; i < l; i++)
                    segments[i]._index = i;
            }
            if (curves) {
                var total = this._countCurves(),
                    start = index > 0 && index + amount - 1 === total ? index - 1
                        : index,
                    insert = start,
                    end = Math.min(start + amount, total);
                if (segs._curves) {
                    curves.splice.apply(curves, [start, 0].concat(segs._curves));
                    insert += segs._curves.length;
                }
                for (var i = insert; i < end; i++)
                    curves.splice(i, 0, new Curve(this, null, null));
                this._adjustCurves(start, end);
            }
            this._changed(25);
            return segs;
        },
    
        _adjustCurves: function(start, end) {
            var segments = this._segments,
                curves = this._curves,
                curve;
            for (var i = start; i < end; i++) {
                curve = curves[i];
                curve._path = this;
                curve._segment1 = segments[i];
                curve._segment2 = segments[i + 1] || segments[0];
                curve._changed();
            }
            if (curve = curves[this._closed && !start ? segments.length - 1
                    : start - 1]) {
                curve._segment2 = segments[start] || segments[0];
                curve._changed();
            }
            if (curve = curves[end]) {
                curve._segment1 = segments[end];
                curve._changed();
            }
        },
    
        _countCurves: function() {
            var length = this._segments.length;
            return !this._closed && length > 0 ? length - 1 : length;
        },
    
        add: function(segment1 ) {
            return arguments.length > 1 && typeof segment1 !== 'number'
                ? this._add(Segment.readList(arguments))
                : this._add([ Segment.read(arguments) ])[0];
        },
    
        insert: function(index, segment1 ) {
            return arguments.length > 2 && typeof segment1 !== 'number'
                ? this._add(Segment.readList(arguments, 1), index)
                : this._add([ Segment.read(arguments, 1) ], index)[0];
        },
    
        addSegment: function() {
            return this._add([ Segment.read(arguments) ])[0];
        },
    
        insertSegment: function(index ) {
            return this._add([ Segment.read(arguments, 1) ], index)[0];
        },
    
        addSegments: function(segments) {
            return this._add(Segment.readList(segments));
        },
    
        insertSegments: function(index, segments) {
            return this._add(Segment.readList(segments), index);
        },
    
        removeSegment: function(index) {
            return this.removeSegments(index, index + 1)[0] || null;
        },
    
        removeSegments: function(start, end, _includeCurves) {
            start = start || 0;
            end = Base.pick(end, this._segments.length);
            var segments = this._segments,
                curves = this._curves,
                count = segments.length,
                removed = segments.splice(start, end - start),
                amount = removed.length;
            if (!amount)
                return removed;
            for (var i = 0; i < amount; i++) {
                var segment = removed[i];
                if (segment._selection)
                    this._updateSelection(segment, segment._selection, 0);
                segment._index = segment._path = null;
            }
            for (var i = start, l = segments.length; i < l; i++)
                segments[i]._index = i;
            if (curves) {
                var index = start > 0 && end === count + (this._closed ? 1 : 0)
                        ? start - 1
                        : start,
                    curves = curves.splice(index, amount);
                for (var i = curves.length - 1; i >= 0; i--)
                    curves[i]._path = null;
                if (_includeCurves)
                    removed._curves = curves.slice(1);
                this._adjustCurves(index, index);
            }
            this._changed(25);
            return removed;
        },
    
        clear: '#removeSegments',
    
        hasHandles: function() {
            var segments = this._segments;
            for (var i = 0, l = segments.length; i < l; i++) {
                if (segments[i].hasHandles())
                    return true;
            }
            return false;
        },
    
        clearHandles: function() {
            var segments = this._segments;
            for (var i = 0, l = segments.length; i < l; i++)
                segments[i].clearHandles();
        },
    
        getLength: function() {
            if (this._length == null) {
                var curves = this.getCurves(),
                    length = 0;
                for (var i = 0, l = curves.length; i < l; i++)
                    length += curves[i].getLength();
                this._length = length;
            }
            return this._length;
        },
    
        getArea: function() {
            var area = this._area;
            if (area == null) {
                var segments = this._segments,
                    closed = this._closed;
                area = 0;
                for (var i = 0, l = segments.length; i < l; i++) {
                    var last = i + 1 === l;
                    area += Curve.getArea(Curve.getValues(
                            segments[i], segments[last ? 0 : i + 1],
                            null, last && !closed));
                }
                this._area = area;
            }
            return area;
        },
    
        isFullySelected: function() {
            var length = this._segments.length;
            return this.isSelected() && length > 0 && this._segmentSelection
                    === length * 7;
        },
    
        setFullySelected: function(selected) {
            if (selected)
                this._selectSegments(true);
            this.setSelected(selected);
        },
    
        setSelection: function setSelection(selection) {
            if (!(selection & 1))
                this._selectSegments(false);
            setSelection.base.call(this, selection);
        },
    
        _selectSegments: function(selected) {
            var segments = this._segments,
                length = segments.length,
                selection = selected ? 7 : 0;
            this._segmentSelection = selection * length;
            for (var i = 0; i < length; i++)
                segments[i]._selection = selection;
        },
    
        _updateSelection: function(segment, oldSelection, newSelection) {
            segment._selection = newSelection;
            var selection = this._segmentSelection += newSelection - oldSelection;
            if (selection > 0)
                this.setSelected(true);
        },
    
        divideAt: function(location) {
            var loc = this.getLocationAt(location),
                curve;
            return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))
                    ? curve._segment1
                    : null;
        },
    
        splitAt: function(location) {
            var loc = this.getLocationAt(location),
                index = loc && loc.index,
                time = loc && loc.time,
                tMin = 1e-8,
                tMax = 1 - tMin;
            if (time > tMax) {
                index++;
                time = 0;
            }
            var curves = this.getCurves();
            if (index >= 0 && index < curves.length) {
                if (time >= tMin) {
                    curves[index++].divideAtTime(time);
                }
                var segs = this.removeSegments(index, this._segments.length, true),
                    path;
                if (this._closed) {
                    this.setClosed(false);
                    path = this;
                } else {
                    path = new Path(Item.NO_INSERT);
                    path.insertAbove(this);
                    path.copyAttributes(this);
                }
                path._add(segs, 0);
                this.addSegment(segs[0]);
                return path;
            }
            return null;
        },
    
        split: function(index, time) {
            var curve,
                location = time === undefined ? index
                    : (curve = this.getCurves()[index])
                        && curve.getLocationAtTime(time);
            return location != null ? this.splitAt(location) : null;
        },
    
        join: function(path, tolerance) {
            var epsilon = tolerance || 0;
            if (path && path !== this) {
                var segments = path._segments,
                    last1 = this.getLastSegment(),
                    last2 = path.getLastSegment();
                if (!last2)
                    return this;
                if (last1 && last1._point.isClose(last2._point, epsilon))
                    path.reverse();
                var first2 = path.getFirstSegment();
                if (last1 && last1._point.isClose(first2._point, epsilon)) {
                    last1.setHandleOut(first2._handleOut);
                    this._add(segments.slice(1));
                } else {
                    var first1 = this.getFirstSegment();
                    if (first1 && first1._point.isClose(first2._point, epsilon))
                        path.reverse();
                    last2 = path.getLastSegment();
                    if (first1 && first1._point.isClose(last2._point, epsilon)) {
                        first1.setHandleIn(last2._handleIn);
                        this._add(segments.slice(0, segments.length - 1), 0);
                    } else {
                        this._add(segments.slice());
                    }
                }
                if (path._closed)
                    this._add([segments[0]]);
                path.remove();
            }
            var first = this.getFirstSegment(),
                last = this.getLastSegment();
            if (first !== last && first._point.isClose(last._point, epsilon)) {
                first.setHandleIn(last._handleIn);
                last.remove();
                this.setClosed(true);
            }
            return this;
        },
    
        reduce: function(options) {
            var curves = this.getCurves(),
                simplify = options && options.simplify,
                tolerance = simplify ? 1e-7 : 0;
            for (var i = curves.length - 1; i >= 0; i--) {
                var curve = curves[i];
                if (!curve.hasHandles() && (!curve.hasLength(tolerance)
                        || simplify && curve.isCollinear(curve.getNext())))
                    curve.remove();
            }
            return this;
        },
    
        reverse: function() {
            this._segments.reverse();
            for (var i = 0, l = this._segments.length; i < l; i++) {
                var segment = this._segments[i];
                var handleIn = segment._handleIn;
                segment._handleIn = segment._handleOut;
                segment._handleOut = handleIn;
                segment._index = i;
            }
            this._curves = null;
            this._changed(9);
        },
    
        flatten: function(flatness) {
            var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
                parts = flattener.parts,
                length = parts.length,
                segments = [];
            for (var i = 0; i < length; i++) {
                segments.push(new Segment(parts[i].curve.slice(0, 2)));
            }
            if (!this._closed && length > 0) {
                segments.push(new Segment(parts[length - 1].curve.slice(6)));
            }
            this.setSegments(segments);
        },
    
        simplify: function(tolerance) {
            var segments = new PathFitter(this).fit(tolerance || 2.5);
            if (segments)
                this.setSegments(segments);
            return !!segments;
        },
    
        smooth: function(options) {
            var that = this,
                opts = options || {},
                type = opts.type || 'asymmetric',
                segments = this._segments,
                length = segments.length,
                closed = this._closed;
    
            function getIndex(value, _default) {
                var index = value && value.index;
                if (index != null) {
                    var path = value.path;
                    if (path && path !== that)
                        throw new Error(value._class + ' ' + index + ' of ' + path
                                + ' is not part of ' + that);
                    if (_default && value instanceof Curve)
                        index++;
                } else {
                    index = typeof value === 'number' ? value : _default;
                }
                return Math.min(index < 0 && closed
                        ? index % length
                        : index < 0 ? index + length : index, length - 1);
            }
    
            var loop = closed && opts.from === undefined && opts.to === undefined,
                from = getIndex(opts.from, 0),
                to = getIndex(opts.to, length - 1);
    
            if (from > to) {
                if (closed) {
                    from -= length;
                } else {
                    var tmp = from;
                    from = to;
                    to = tmp;
                }
            }
            if (/^(?:asymmetric|continuous)$/.test(type)) {
                var asymmetric = type === 'asymmetric',
                    min = Math.min,
                    amount = to - from + 1,
                    n = amount - 1,
                    padding = loop ? min(amount, 4) : 1,
                    paddingLeft = padding,
                    paddingRight = padding,
                    knots = [];
                if (!closed) {
                    paddingLeft = min(1, from);
                    paddingRight = min(1, length - to - 1);
                }
                n += paddingLeft + paddingRight;
                if (n <= 1)
                    return;
                for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
                    knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
                }
    
                var x = knots[0]._x + 2 * knots[1]._x,
                    y = knots[0]._y + 2 * knots[1]._y,
                    f = 2,
                    n_1 = n - 1,
                    rx = [x],
                    ry = [y],
                    rf = [f],
                    px = [],
                    py = [];
                for (var i = 1; i < n; i++) {
                    var internal = i < n_1,
                        a = internal ? 1 : asymmetric ? 1 : 2,
                        b = internal ? 4 : asymmetric ? 2 : 7,
                        u = internal ? 4 : asymmetric ? 3 : 8,
                        v = internal ? 2 : asymmetric ? 0 : 1,
                        m = a / f;
                    f = rf[i] = b - m;
                    x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
                    y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
                }
    
                px[n_1] = rx[n_1] / rf[n_1];
                py[n_1] = ry[n_1] / rf[n_1];
                for (var i = n - 2; i >= 0; i--) {
                    px[i] = (rx[i] - px[i + 1]) / rf[i];
                    py[i] = (ry[i] - py[i + 1]) / rf[i];
                }
                px[n] = (3 * knots[n]._x - px[n_1]) / 2;
                py[n] = (3 * knots[n]._y - py[n_1]) / 2;
    
                for (var i = paddingLeft, max = n - paddingRight, j = from;
                        i <= max; i++, j++) {
                    var segment = segments[j < 0 ? j + length : j],
                        pt = segment._point,
                        hx = px[i] - pt._x,
                        hy = py[i] - pt._y;
                    if (loop || i < max)
                        segment.setHandleOut(hx, hy);
                    if (loop || i > paddingLeft)
                        segment.setHandleIn(-hx, -hy);
                }
            } else {
                for (var i = from; i <= to; i++) {
                    segments[i < 0 ? i + length : i].smooth(opts,
                            !loop && i === from, !loop && i === to);
                }
            }
        },
    
        toShape: function(insert) {
            if (!this._closed)
                return null;
    
            var segments = this._segments,
                type,
                size,
                radius,
                topCenter;
    
            function isCollinear(i, j) {
                var seg1 = segments[i],
                    seg2 = seg1.getNext(),
                    seg3 = segments[j],
                    seg4 = seg3.getNext();
                return seg1._handleOut.isZero() && seg2._handleIn.isZero()
                        && seg3._handleOut.isZero() && seg4._handleIn.isZero()
                        && seg2._point.subtract(seg1._point).isCollinear(
                            seg4._point.subtract(seg3._point));
            }
    
            function isOrthogonal(i) {
                var seg2 = segments[i],
                    seg1 = seg2.getPrevious(),
                    seg3 = seg2.getNext();
                return seg1._handleOut.isZero() && seg2._handleIn.isZero()
                        && seg2._handleOut.isZero() && seg3._handleIn.isZero()
                        && seg2._point.subtract(seg1._point).isOrthogonal(
                            seg3._point.subtract(seg2._point));
            }
    
            function isArc(i) {
                var seg1 = segments[i],
                    seg2 = seg1.getNext(),
                    handle1 = seg1._handleOut,
                    handle2 = seg2._handleIn,
                    kappa = 0.5522847498307936;
                if (handle1.isOrthogonal(handle2)) {
                    var pt1 = seg1._point,
                        pt2 = seg2._point,
                        corner = new Line(pt1, handle1, true).intersect(
                                new Line(pt2, handle2, true), true);
                    return corner && Numerical.isZero(handle1.getLength() /
                            corner.subtract(pt1).getLength() - kappa)
                        && Numerical.isZero(handle2.getLength() /
                            corner.subtract(pt2).getLength() - kappa);
                }
                return false;
            }
    
            function getDistance(i, j) {
                return segments[i]._point.getDistance(segments[j]._point);
            }
    
            if (!this.hasHandles() && segments.length === 4
                    && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
                type = Shape.Rectangle;
                size = new Size(getDistance(0, 3), getDistance(0, 1));
                topCenter = segments[1]._point.add(segments[2]._point).divide(2);
            } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
                    && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
                type = Shape.Rectangle;
                size = new Size(getDistance(1, 6), getDistance(0, 3));
                radius = size.subtract(new Size(getDistance(0, 7),
                        getDistance(1, 2))).divide(2);
                topCenter = segments[3]._point.add(segments[4]._point).divide(2);
            } else if (segments.length === 4
                    && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
                if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
                    type = Shape.Circle;
                    radius = getDistance(0, 2) / 2;
                } else {
                    type = Shape.Ellipse;
                    radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
                }
                topCenter = segments[1]._point;
            }
    
            if (type) {
                var center = this.getPosition(true),
                    shape = new type({
                        center: center,
                        size: size,
                        radius: radius,
                        insert: false
                    });
                shape.copyAttributes(this, true);
                shape._matrix.prepend(this._matrix);
                shape.rotate(topCenter.subtract(center).getAngle() + 90);
                if (insert === undefined || insert)
                    shape.insertAbove(this);
                return shape;
            }
            return null;
        },
    
        toPath: '#clone',
    
        compare: function compare(path) {
            if (!path || path instanceof CompoundPath)
                return compare.base.call(this, path);
            var curves1 = this.getCurves(),
                curves2 = path.getCurves(),
                length1 = curves1.length,
                length2 = curves2.length;
            if (!length1 || !length2) {
                return length1 == length2;
            }
            var v1 = curves1[0].getValues(),
                values2 = [],
                pos1 = 0, pos2,
                end1 = 0, end2;
            for (var i = 0; i < length2; i++) {
                var v2 = curves2[i].getValues();
                values2.push(v2);
                var overlaps = Curve.getOverlaps(v1, v2);
                if (overlaps) {
                    pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
                    end2 = overlaps[0][1];
                    break;
                }
            }
            var abs = Math.abs,
                epsilon = 1e-8,
                v2 = values2[pos2],
                start2;
            while (v1 && v2) {
                var overlaps = Curve.getOverlaps(v1, v2);
                if (overlaps) {
                    var t1 = overlaps[0][0];
                    if (abs(t1 - end1) < epsilon) {
                        end1 = overlaps[1][0];
                        if (end1 === 1) {
                            v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
                            end1 = 0;
                        }
                        var t2 = overlaps[0][1];
                        if (abs(t2 - end2) < epsilon) {
                            if (!start2)
                                start2 = [pos2, t2];
                            end2 = overlaps[1][1];
                            if (end2 === 1) {
                                if (++pos2 >= length2)
                                    pos2 = 0;
                                v2 = values2[pos2] || curves2[pos2].getValues();
                                end2 = 0;
                            }
                            if (!v1) {
                                return start2[0] === pos2 && start2[1] === end2;
                            }
                            continue;
                        }
                    }
                }
                break;
            }
            return false;
        },
    
        _hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {
            var that = this,
                style = this.getStyle(),
                segments = this._segments,
                numSegments = segments.length,
                closed = this._closed,
                tolerancePadding = options._tolerancePadding,
                strokePadding = tolerancePadding,
                join, cap, miterLimit,
                area, loc, res,
                hitStroke = options.stroke && style.hasStroke(),
                hitFill = options.fill && style.hasFill(),
                hitCurves = options.curves,
                strokeRadius = hitStroke
                        ? style.getStrokeWidth() / 2
                        : hitFill && options.tolerance > 0 || hitCurves
                            ? 0 : null;
            if (strokeRadius !== null) {
                if (strokeRadius > 0) {
                    join = style.getStrokeJoin();
                    cap = style.getStrokeCap();
                    miterLimit = style.getMiterLimit();
                    strokePadding = strokePadding.add(
                        Path._getStrokePadding(strokeRadius, strokeMatrix));
                } else {
                    join = cap = 'round';
                }
            }
    
            function isCloseEnough(pt, padding) {
                return point.subtract(pt).divide(padding).length <= 1;
            }
    
            function checkSegmentPoint(seg, pt, name) {
                if (!options.selected || pt.isSelected()) {
                    var anchor = seg._point;
                    if (pt !== anchor)
                        pt = pt.add(anchor);
                    if (isCloseEnough(pt, strokePadding)) {
                        return new HitResult(name, that, {
                            segment: seg,
                            point: pt
                        });
                    }
                }
            }
    
            function checkSegmentPoints(seg, ends) {
                return (ends || options.segments)
                    && checkSegmentPoint(seg, seg._point, 'segment')
                    || (!ends && options.handles) && (
                        checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
                        checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
            }
    
            function addToArea(point) {
                area.add(point);
            }
    
            function checkSegmentStroke(segment) {
                var isJoin = closed || segment._index > 0
                        && segment._index < numSegments - 1;
                if ((isJoin ? join : cap) === 'round') {
                    return isCloseEnough(segment._point, strokePadding);
                } else {
                    area = new Path({ internal: true, closed: true });
                    if (isJoin) {
                        if (!segment.isSmooth()) {
                            Path._addBevelJoin(segment, join, strokeRadius,
                                   miterLimit, null, strokeMatrix, addToArea, true);
                        }
                    } else if (cap === 'square') {
                        Path._addSquareCap(segment, cap, strokeRadius, null,
                                strokeMatrix, addToArea, true);
                    }
                    if (!area.isEmpty()) {
                        var loc;
                        return area.contains(point)
                            || (loc = area.getNearestLocation(point))
                                && isCloseEnough(loc.getPoint(), tolerancePadding);
                    }
                }
            }
    
            if (options.ends && !options.segments && !closed) {
                if (res = checkSegmentPoints(segments[0], true)
                        || checkSegmentPoints(segments[numSegments - 1], true))
                    return res;
            } else if (options.segments || options.handles) {
                for (var i = 0; i < numSegments; i++)
                    if (res = checkSegmentPoints(segments[i]))
                        return res;
            }
            if (strokeRadius !== null) {
                loc = this.getNearestLocation(point);
                if (loc) {
                    var time = loc.getTime();
                    if (time === 0 || time === 1 && numSegments > 1) {
                        if (!checkSegmentStroke(loc.getSegment()))
                            loc = null;
                    } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
                        loc = null;
                    }
                }
                if (!loc && join === 'miter' && numSegments > 1) {
                    for (var i = 0; i < numSegments; i++) {
                        var segment = segments[i];
                        if (point.getDistance(segment._point)
                                <= miterLimit * strokeRadius
                                && checkSegmentStroke(segment)) {
                            loc = segment.getLocation();
                            break;
                        }
                    }
                }
            }
            return !loc && hitFill && this._contains(point)
                    || loc && !hitStroke && !hitCurves
                        ? new HitResult('fill', this)
                        : loc
                            ? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
                                location: loc,
                                point: loc.getPoint()
                            })
                            : null;
        }
    
    }, Base.each(Curve._evaluateMethods,
        function(name) {
            this[name + 'At'] = function(offset) {
                var loc = this.getLocationAt(offset);
                return loc && loc[name]();
            };
        },
    {
        beans: false,
    
        getLocationOf: function() {
            var point = Point.read(arguments),
                curves = this.getCurves();
            for (var i = 0, l = curves.length; i < l; i++) {
                var loc = curves[i].getLocationOf(point);
                if (loc)
                    return loc;
            }
            return null;
        },
    
        getOffsetOf: function() {
            var loc = this.getLocationOf.apply(this, arguments);
            return loc ? loc.getOffset() : null;
        },
    
        getLocationAt: function(offset) {
            if (typeof offset === 'number') {
                var curves = this.getCurves(),
                    length = 0;
                for (var i = 0, l = curves.length; i < l; i++) {
                    var start = length,
                        curve = curves[i];
                    length += curve.getLength();
                    if (length > offset) {
                        return curve.getLocationAt(offset - start);
                    }
                }
                if (curves.length > 0 && offset <= this.getLength()) {
                    return new CurveLocation(curves[curves.length - 1], 1);
                }
            } else if (offset && offset.getPath && offset.getPath() === this) {
                return offset;
            }
            return null;
        }
    
    }),
    new function() {
    
        function drawHandles(ctx, segments, matrix, size) {
            var half = size / 2,
                coords = new Array(6),
                pX, pY;
    
            function drawHandle(index) {
                var hX = coords[index],
                    hY = coords[index + 1];
                if (pX != hX || pY != hY) {
                    ctx.beginPath();
                    ctx.moveTo(pX, pY);
                    ctx.lineTo(hX, hY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
                    ctx.fill();
                }
            }
    
            for (var i = 0, l = segments.length; i < l; i++) {
                var segment = segments[i],
                    selection = segment._selection;
                segment._transformCoordinates(matrix, coords);
                pX = coords[0];
                pY = coords[1];
                if (selection & 2)
                    drawHandle(2);
                if (selection & 4)
                    drawHandle(4);
                ctx.fillRect(pX - half, pY - half, size, size);
                if (!(selection & 1)) {
                    var fillStyle = ctx.fillStyle;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
                    ctx.fillStyle = fillStyle;
                }
            }
        }
    
        function drawSegments(ctx, path, matrix) {
            var segments = path._segments,
                length = segments.length,
                coords = new Array(6),
                first = true,
                curX, curY,
                prevX, prevY,
                inX, inY,
                outX, outY;
    
            function drawSegment(segment) {
                if (matrix) {
                    segment._transformCoordinates(matrix, coords);
                    curX = coords[0];
                    curY = coords[1];
                } else {
                    var point = segment._point;
                    curX = point._x;
                    curY = point._y;
                }
                if (first) {
                    ctx.moveTo(curX, curY);
                    first = false;
                } else {
                    if (matrix) {
                        inX = coords[2];
                        inY = coords[3];
                    } else {
                        var handle = segment._handleIn;
                        inX = curX + handle._x;
                        inY = curY + handle._y;
                    }
                    if (inX === curX && inY === curY
                            && outX === prevX && outY === prevY) {
                        ctx.lineTo(curX, curY);
                    } else {
                        ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
                    }
                }
                prevX = curX;
                prevY = curY;
                if (matrix) {
                    outX = coords[4];
                    outY = coords[5];
                } else {
                    var handle = segment._handleOut;
                    outX = prevX + handle._x;
                    outY = prevY + handle._y;
                }
            }
    
            for (var i = 0; i < length; i++)
                drawSegment(segments[i]);
            if (path._closed && length > 0)
                drawSegment(segments[0]);
        }
    
        return {
            _draw: function(ctx, param, viewMatrix, strokeMatrix) {
                var dontStart = param.dontStart,
                    dontPaint = param.dontFinish || param.clip,
                    style = this.getStyle(),
                    hasFill = style.hasFill(),
                    hasStroke = style.hasStroke(),
                    dashArray = style.getDashArray(),
                    dashLength = !paper.support.nativeDash && hasStroke
                            && dashArray && dashArray.length;
    
                if (!dontStart)
                    ctx.beginPath();
    
                if (hasFill || hasStroke && !dashLength || dontPaint) {
                    drawSegments(ctx, this, strokeMatrix);
                    if (this._closed)
                        ctx.closePath();
                }
    
                function getOffset(i) {
                    return dashArray[((i % dashLength) + dashLength) % dashLength];
                }
    
                if (!dontPaint && (hasFill || hasStroke)) {
                    this._setStyles(ctx, param, viewMatrix);
                    if (hasFill) {
                        ctx.fill(style.getFillRule());
                        ctx.shadowColor = 'rgba(0,0,0,0)';
                    }
                    if (hasStroke) {
                        if (dashLength) {
                            if (!dontStart)
                                ctx.beginPath();
                            var flattener = new PathFlattener(this, 0.25, 32, false,
                                    strokeMatrix),
                                length = flattener.length,
                                from = -style.getDashOffset(), to,
                                i = 0;
                            from = from % length;
                            while (from > 0) {
                                from -= getOffset(i--) + getOffset(i--);
                            }
                            while (from < length) {
                                to = from + getOffset(i++);
                                if (from > 0 || to > 0)
                                    flattener.drawPart(ctx,
                                            Math.max(from, 0), Math.max(to, 0));
                                from = to + getOffset(i++);
                            }
                        }
                        ctx.stroke();
                    }
                }
            },
    
            _drawSelected: function(ctx, matrix) {
                ctx.beginPath();
                drawSegments(ctx, this, matrix);
                ctx.stroke();
                drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
            }
        };
    },
    new function() {
        function getCurrentSegment(that) {
            var segments = that._segments;
            if (!segments.length)
                throw new Error('Use a moveTo() command first');
            return segments[segments.length - 1];
        }
    
        return {
            moveTo: function() {
                var segments = this._segments;
                if (segments.length === 1)
                    this.removeSegment(0);
                if (!segments.length)
                    this._add([ new Segment(Point.read(arguments)) ]);
            },
    
            moveBy: function() {
                throw new Error('moveBy() is unsupported on Path items.');
            },
    
            lineTo: function() {
                this._add([ new Segment(Point.read(arguments)) ]);
            },
    
            cubicCurveTo: function() {
                var handle1 = Point.read(arguments),
                    handle2 = Point.read(arguments),
                    to = Point.read(arguments),
                    current = getCurrentSegment(this);
                current.setHandleOut(handle1.subtract(current._point));
                this._add([ new Segment(to, handle2.subtract(to)) ]);
            },
    
            quadraticCurveTo: function() {
                var handle = Point.read(arguments),
                    to = Point.read(arguments),
                    current = getCurrentSegment(this)._point;
                this.cubicCurveTo(
                    handle.add(current.subtract(handle).multiply(1 / 3)),
                    handle.add(to.subtract(handle).multiply(1 / 3)),
                    to
                );
            },
    
            curveTo: function() {
                var through = Point.read(arguments),
                    to = Point.read(arguments),
                    t = Base.pick(Base.read(arguments), 0.5),
                    t1 = 1 - t,
                    current = getCurrentSegment(this)._point,
                    handle = through.subtract(current.multiply(t1 * t1))
                        .subtract(to.multiply(t * t)).divide(2 * t * t1);
                if (handle.isNaN())
                    throw new Error(
                        'Cannot put a curve through points with parameter = ' + t);
                this.quadraticCurveTo(handle, to);
            },
    
            arcTo: function() {
                var abs = Math.abs,
                    sqrt = Math.sqrt,
                    current = getCurrentSegment(this),
                    from = current._point,
                    to = Point.read(arguments),
                    through,
                    peek = Base.peek(arguments),
                    clockwise = Base.pick(peek, true),
                    center, extent, vector, matrix;
                if (typeof clockwise === 'boolean') {
                    var middle = from.add(to).divide(2),
                    through = middle.add(middle.subtract(from).rotate(
                            clockwise ? -90 : 90));
                } else if (Base.remain(arguments) <= 2) {
                    through = to;
                    to = Point.read(arguments);
                } else {
                    var radius = Size.read(arguments),
                        isZero = Numerical.isZero;
                    if (isZero(radius.width) || isZero(radius.height))
                        return this.lineTo(to);
                    var rotation = Base.read(arguments),
                        clockwise = !!Base.read(arguments),
                        large = !!Base.read(arguments),
                        middle = from.add(to).divide(2),
                        pt = from.subtract(middle).rotate(-rotation),
                        x = pt.x,
                        y = pt.y,
                        rx = abs(radius.width),
                        ry = abs(radius.height),
                        rxSq = rx * rx,
                        rySq = ry * ry,
                        xSq = x * x,
                        ySq = y * y;
                    var factor = sqrt(xSq / rxSq + ySq / rySq);
                    if (factor > 1) {
                        rx *= factor;
                        ry *= factor;
                        rxSq = rx * rx;
                        rySq = ry * ry;
                    }
                    factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
                            (rxSq * ySq + rySq * xSq);
                    if (abs(factor) < 1e-12)
                        factor = 0;
                    if (factor < 0)
                        throw new Error(
                                'Cannot create an arc with the given arguments');
                    center = new Point(rx * y / ry, -ry * x / rx)
                            .multiply((large === clockwise ? -1 : 1) * sqrt(factor))
                            .rotate(rotation).add(middle);
                    matrix = new Matrix().translate(center).rotate(rotation)
                            .scale(rx, ry);
                    vector = matrix._inverseTransform(from);
                    extent = vector.getDirectedAngle(matrix._inverseTransform(to));
                    if (!clockwise && extent > 0)
                        extent -= 360;
                    else if (clockwise && extent < 0)
                        extent += 360;
                }
                if (through) {
                    var l1 = new Line(from.add(through).divide(2),
                                through.subtract(from).rotate(90), true),
                        l2 = new Line(through.add(to).divide(2),
                                to.subtract(through).rotate(90), true),
                        line = new Line(from, to),
                        throughSide = line.getSide(through);
                    center = l1.intersect(l2, true);
                    if (!center) {
                        if (!throughSide)
                            return this.lineTo(to);
                        throw new Error(
                                'Cannot create an arc with the given arguments');
                    }
                    vector = from.subtract(center);
                    extent = vector.getDirectedAngle(to.subtract(center));
                    var centerSide = line.getSide(center);
                    if (centerSide === 0) {
                        extent = throughSide * abs(extent);
                    } else if (throughSide === centerSide) {
                        extent += extent < 0 ? 360 : -360;
                    }
                }
                var epsilon = 1e-7,
                    ext = abs(extent),
                    count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
                    inc = extent / count,
                    half = inc * Math.PI / 360,
                    z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
                    segments = [];
                for (var i = 0; i <= count; i++) {
                    var pt = to,
                        out = null;
                    if (i < count) {
                        out = vector.rotate(90).multiply(z);
                        if (matrix) {
                            pt = matrix._transformPoint(vector);
                            out = matrix._transformPoint(vector.add(out))
                                    .subtract(pt);
                        } else {
                            pt = center.add(vector);
                        }
                    }
                    if (!i) {
                        current.setHandleOut(out);
                    } else {
                        var _in = vector.rotate(-90).multiply(z);
                        if (matrix) {
                            _in = matrix._transformPoint(vector.add(_in))
                                    .subtract(pt);
                        }
                        segments.push(new Segment(pt, _in, out));
                    }
                    vector = vector.rotate(inc);
                }
                this._add(segments);
            },
    
            lineBy: function() {
                var to = Point.read(arguments),
                    current = getCurrentSegment(this)._point;
                this.lineTo(current.add(to));
            },
    
            curveBy: function() {
                var through = Point.read(arguments),
                    to = Point.read(arguments),
                    parameter = Base.read(arguments),
                    current = getCurrentSegment(this)._point;
                this.curveTo(current.add(through), current.add(to), parameter);
            },
    
            cubicCurveBy: function() {
                var handle1 = Point.read(arguments),
                    handle2 = Point.read(arguments),
                    to = Point.read(arguments),
                    current = getCurrentSegment(this)._point;
                this.cubicCurveTo(current.add(handle1), current.add(handle2),
                        current.add(to));
            },
    
            quadraticCurveBy: function() {
                var handle = Point.read(arguments),
                    to = Point.read(arguments),
                    current = getCurrentSegment(this)._point;
                this.quadraticCurveTo(current.add(handle), current.add(to));
            },
    
            arcBy: function() {
                var current = getCurrentSegment(this)._point,
                    point = current.add(Point.read(arguments)),
                    clockwise = Base.pick(Base.peek(arguments), true);
                if (typeof clockwise === 'boolean') {
                    this.arcTo(point, clockwise);
                } else {
                    this.arcTo(point, current.add(Point.read(arguments)));
                }
            },
    
            closePath: function(tolerance) {
                this.setClosed(true);
                this.join(this, tolerance);
            }
        };
    }, {
    
        _getBounds: function(matrix, options) {
            var method = options.handle
                    ? 'getHandleBounds'
                    : options.stroke
                    ? 'getStrokeBounds'
                    : 'getBounds';
            return Path[method](this._segments, this._closed, this, matrix, options);
        },
    
    statics: {
        getBounds: function(segments, closed, path, matrix, options, strokePadding) {
            var first = segments[0];
            if (!first)
                return new Rectangle();
            var coords = new Array(6),
                prevCoords = first._transformCoordinates(matrix, new Array(6)),
                min = prevCoords.slice(0, 2),
                max = min.slice(),
                roots = new Array(2);
    
            function processSegment(segment) {
                segment._transformCoordinates(matrix, coords);
                for (var i = 0; i < 2; i++) {
                    Curve._addBounds(
                        prevCoords[i],
                        prevCoords[i + 4],
                        coords[i + 2],
                        coords[i],
                        i, strokePadding ? strokePadding[i] : 0, min, max, roots);
                }
                var tmp = prevCoords;
                prevCoords = coords;
                coords = tmp;
            }
    
            for (var i = 1, l = segments.length; i < l; i++)
                processSegment(segments[i]);
            if (closed)
                processSegment(first);
            return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
        },
    
        getStrokeBounds: function(segments, closed, path, matrix, options) {
            var style = path.getStyle(),
                stroke = style.hasStroke(),
                strokeWidth = style.getStrokeWidth(),
                strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
                strokePadding = stroke && Path._getStrokePadding(strokeWidth,
                    strokeMatrix),
                bounds = Path.getBounds(segments, closed, path, matrix, options,
                    strokePadding);
            if (!stroke)
                return bounds;
            var strokeRadius = strokeWidth / 2,
                join = style.getStrokeJoin(),
                cap = style.getStrokeCap(),
                miterLimit = style.getMiterLimit(),
                joinBounds = new Rectangle(new Size(strokePadding));
    
            function addPoint(point) {
                bounds = bounds.include(point);
            }
    
            function addRound(segment) {
                bounds = bounds.unite(
                        joinBounds.setCenter(segment._point.transform(matrix)));
            }
    
            function addJoin(segment, join) {
                if (join === 'round' || segment.isSmooth()) {
                    addRound(segment);
                } else {
                    Path._addBevelJoin(segment, join, strokeRadius, miterLimit,
                            matrix, strokeMatrix, addPoint);
                }
            }
    
            function addCap(segment, cap) {
                if (cap === 'round') {
                    addRound(segment);
                } else {
                    Path._addSquareCap(segment, cap, strokeRadius, matrix,
                            strokeMatrix, addPoint);
                }
            }
    
            var length = segments.length - (closed ? 0 : 1);
            for (var i = 1; i < length; i++)
                addJoin(segments[i], join);
            if (closed) {
                addJoin(segments[0], join);
            } else if (length > 0) {
                addCap(segments[0], cap);
                addCap(segments[segments.length - 1], cap);
            }
            return bounds;
        },
    
        _getStrokePadding: function(radius, matrix) {
            if (!matrix)
                return [radius, radius];
            var hor = new Point(radius, 0).transform(matrix),
                ver = new Point(0, radius).transform(matrix),
                phi = hor.getAngleInRadians(),
                a = hor.getLength(),
                b = ver.getLength();
            var sin = Math.sin(phi),
                cos = Math.cos(phi),
                tan = Math.tan(phi),
                tx = Math.atan2(b * tan, a),
                ty = Math.atan2(b, tan * a);
            return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),
                    Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
        },
    
        _addBevelJoin: function(segment, join, radius, miterLimit, matrix,
                strokeMatrix, addPoint, isArea) {
            var curve2 = segment.getCurve(),
                curve1 = curve2.getPrevious(),
                point = curve2.getPoint1().transform(matrix),
                normal1 = curve1.getNormalAtTime(1).multiply(radius)
                    .transform(strokeMatrix),
                normal2 = curve2.getNormalAtTime(0).multiply(radius)
                    .transform(strokeMatrix);
            if (normal1.getDirectedAngle(normal2) < 0) {
                normal1 = normal1.negate();
                normal2 = normal2.negate();
            }
            if (isArea)
                addPoint(point);
            addPoint(point.add(normal1));
            if (join === 'miter') {
                var corner = new Line(point.add(normal1),
                        new Point(-normal1.y, normal1.x), true
                    ).intersect(new Line(point.add(normal2),
                        new Point(-normal2.y, normal2.x), true
                    ), true);
                if (corner && point.getDistance(corner) <= miterLimit * radius) {
                    addPoint(corner);
                }
            }
            addPoint(point.add(normal2));
        },
    
        _addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,
                addPoint, isArea) {
            var point = segment._point.transform(matrix),
                loc = segment.getLocation(),
                normal = loc.getNormal()
                        .multiply(loc.getTime() === 0 ? radius : -radius)
                        .transform(strokeMatrix);
            if (cap === 'square') {
                if (isArea) {
                    addPoint(point.subtract(normal));
                    addPoint(point.add(normal));
                }
                point = point.add(normal.rotate(-90));
            }
            addPoint(point.add(normal));
            addPoint(point.subtract(normal));
        },
    
        getHandleBounds: function(segments, closed, path, matrix, options) {
            var style = path.getStyle(),
                stroke = options.stroke && style.hasStroke(),
                strokePadding,
                joinPadding;
            if (stroke) {
                var strokeMatrix = path._getStrokeMatrix(matrix, options),
                    strokeRadius = style.getStrokeWidth() / 2,
                    joinRadius = strokeRadius;
                if (style.getStrokeJoin() === 'miter')
                    joinRadius = strokeRadius * style.getMiterLimit();
                if (style.getStrokeCap() === 'square')
                    joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
                strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
                joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
            }
            var coords = new Array(6),
                x1 = Infinity,
                x2 = -x1,
                y1 = x1,
                y2 = x2;
            for (var i = 0, l = segments.length; i < l; i++) {
                var segment = segments[i];
                segment._transformCoordinates(matrix, coords);
                for (var j = 0; j < 6; j += 2) {
                    var padding = !j ? joinPadding : strokePadding,
                        paddingX = padding ? padding[0] : 0,
                        paddingY = padding ? padding[1] : 0,
                        x = coords[j],
                        y = coords[j + 1],
                        xn = x - paddingX,
                        xx = x + paddingX,
                        yn = y - paddingY,
                        yx = y + paddingY;
                    if (xn < x1) x1 = xn;
                    if (xx > x2) x2 = xx;
                    if (yn < y1) y1 = yn;
                    if (yx > y2) y2 = yx;
                }
            }
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        }
    }});
    
    Path.inject({ statics: new function() {
    
        var kappa = 0.5522847498307936,
            ellipseSegments = [
                new Segment([-1, 0], [0, kappa ], [0, -kappa]),
                new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
                new Segment([1, 0], [0, -kappa], [0, kappa ]),
                new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
            ];
    
        function createPath(segments, closed, args) {
            var props = Base.getNamed(args),
                path = new Path(props && props.insert == false && Item.NO_INSERT);
            path._add(segments);
            path._closed = closed;
            return path.set(props, { insert: true });
        }
    
        function createEllipse(center, radius, args) {
            var segments = new Array(4);
            for (var i = 0; i < 4; i++) {
                var segment = ellipseSegments[i];
                segments[i] = new Segment(
                    segment._point.multiply(radius).add(center),
                    segment._handleIn.multiply(radius),
                    segment._handleOut.multiply(radius)
                );
            }
            return createPath(segments, true, args);
        }
    
        return {
            Line: function() {
                return createPath([
                    new Segment(Point.readNamed(arguments, 'from')),
                    new Segment(Point.readNamed(arguments, 'to'))
                ], false, arguments);
            },
    
            Circle: function() {
                var center = Point.readNamed(arguments, 'center'),
                    radius = Base.readNamed(arguments, 'radius');
                return createEllipse(center, new Size(radius), arguments);
            },
    
            Rectangle: function() {
                var rect = Rectangle.readNamed(arguments, 'rectangle'),
                    radius = Size.readNamed(arguments, 'radius', 0,
                            { readNull: true }),
                    bl = rect.getBottomLeft(true),
                    tl = rect.getTopLeft(true),
                    tr = rect.getTopRight(true),
                    br = rect.getBottomRight(true),
                    segments;
                if (!radius || radius.isZero()) {
                    segments = [
                        new Segment(bl),
                        new Segment(tl),
                        new Segment(tr),
                        new Segment(br)
                    ];
                } else {
                    radius = Size.min(radius, rect.getSize(true).divide(2));
                    var rx = radius.width,
                        ry = radius.height,
                        hx = rx * kappa,
                        hy = ry * kappa;
                    segments = [
                        new Segment(bl.add(rx, 0), null, [-hx, 0]),
                        new Segment(bl.subtract(0, ry), [0, hy]),
                        new Segment(tl.add(0, ry), null, [0, -hy]),
                        new Segment(tl.add(rx, 0), [-hx, 0], null),
                        new Segment(tr.subtract(rx, 0), null, [hx, 0]),
                        new Segment(tr.add(0, ry), [0, -hy], null),
                        new Segment(br.subtract(0, ry), null, [0, hy]),
                        new Segment(br.subtract(rx, 0), [hx, 0])
                    ];
                }
                return createPath(segments, true, arguments);
            },
    
            RoundRectangle: '#Rectangle',
    
            Ellipse: function() {
                var ellipse = Shape._readEllipse(arguments);
                return createEllipse(ellipse.center, ellipse.radius, arguments);
            },
    
            Oval: '#Ellipse',
    
            Arc: function() {
                var from = Point.readNamed(arguments, 'from'),
                    through = Point.readNamed(arguments, 'through'),
                    to = Point.readNamed(arguments, 'to'),
                    props = Base.getNamed(arguments),
                    path = new Path(props && props.insert == false
                            && Item.NO_INSERT);
                path.moveTo(from);
                path.arcTo(through, to);
                return path.set(props);
            },
    
            RegularPolygon: function() {
                var center = Point.readNamed(arguments, 'center'),
                    sides = Base.readNamed(arguments, 'sides'),
                    radius = Base.readNamed(arguments, 'radius'),
                    step = 360 / sides,
                    three = sides % 3 === 0,
                    vector = new Point(0, three ? -radius : radius),
                    offset = three ? -1 : 0.5,
                    segments = new Array(sides);
                for (var i = 0; i < sides; i++)
                    segments[i] = new Segment(center.add(
                        vector.rotate((i + offset) * step)));
                return createPath(segments, true, arguments);
            },
    
            Star: function() {
                var center = Point.readNamed(arguments, 'center'),
                    points = Base.readNamed(arguments, 'points') * 2,
                    radius1 = Base.readNamed(arguments, 'radius1'),
                    radius2 = Base.readNamed(arguments, 'radius2'),
                    step = 360 / points,
                    vector = new Point(0, -1),
                    segments = new Array(points);
                for (var i = 0; i < points; i++)
                    segments[i] = new Segment(center.add(vector.rotate(step * i)
                            .multiply(i % 2 ? radius2 : radius1)));
                return createPath(segments, true, arguments);
            }
        };
    }});
    
    var CompoundPath = PathItem.extend({
        _class: 'CompoundPath',
        _serializeFields: {
            children: []
        },
        beans: true,
    
        initialize: function CompoundPath(arg) {
            this._children = [];
            this._namedChildren = {};
            if (!this._initialize(arg)) {
                if (typeof arg === 'string') {
                    this.setPathData(arg);
                } else {
                    this.addChildren(Array.isArray(arg) ? arg : arguments);
                }
            }
        },
    
        insertChildren: function insertChildren(index, items) {
            var list = items,
                first = list[0];
            if (first && typeof first[0] === 'number')
                list = [list];
            for (var i = items.length - 1; i >= 0; i--) {
                var item = list[i];
                if (list === items && !(item instanceof Path))
                    list = Base.slice(list);
                if (Array.isArray(item)) {
                    list[i] = new Path({ segments: item, insert: false });
                } else if (item instanceof CompoundPath) {
                    list.splice.apply(list, [i, 1].concat(item.removeChildren()));
                    item.remove();
                }
            }
            return insertChildren.base.call(this, index, list);
        },
    
        reduce: function reduce(options) {
            var children = this._children;
            for (var i = children.length - 1; i >= 0; i--) {
                var path = children[i].reduce(options);
                if (path.isEmpty())
                    path.remove();
            }
            if (!children.length) {
                var path = new Path(Item.NO_INSERT);
                path.copyAttributes(this);
                path.insertAbove(this);
                this.remove();
                return path;
            }
            return reduce.base.call(this);
        },
    
        isClosed: function() {
            var children = this._children;
            for (var i = 0, l = children.length; i < l; i++) {
                if (!children[i]._closed)
                    return false;
            }
            return true;
        },
    
        setClosed: function(closed) {
            var children = this._children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].setClosed(closed);
            }
        },
    
        getFirstSegment: function() {
            var first = this.getFirstChild();
            return first && first.getFirstSegment();
        },
    
        getLastSegment: function() {
            var last = this.getLastChild();
            return last && last.getLastSegment();
        },
    
        getCurves: function() {
            var children = this._children,
                curves = [];
            for (var i = 0, l = children.length; i < l; i++)
                curves.push.apply(curves, children[i].getCurves());
            return curves;
        },
    
        getFirstCurve: function() {
            var first = this.getFirstChild();
            return first && first.getFirstCurve();
        },
    
        getLastCurve: function() {
            var last = this.getLastChild();
            return last && last.getLastCurve();
        },
    
        getArea: function() {
            var children = this._children,
                area = 0;
            for (var i = 0, l = children.length; i < l; i++)
                area += children[i].getArea();
            return area;
        },
    
        getLength: function() {
            var children = this._children,
                length = 0;
            for (var i = 0, l = children.length; i < l; i++)
                length += children[i].getLength();
            return length;
        },
    
        getPathData: function(_matrix, _precision) {
            var children = this._children,
                paths = [];
            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i],
                    mx = child._matrix;
                paths.push(child.getPathData(_matrix && !mx.isIdentity()
                        ? _matrix.appended(mx) : _matrix, _precision));
            }
            return paths.join('');
        },
    
        _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
            return _hitTestChildren.base.call(this, point,
                    options.class === Path || options.type === 'path' ? options
                        : Base.set({}, options, { fill: false }),
                    viewMatrix);
        },
    
        _draw: function(ctx, param, viewMatrix, strokeMatrix) {
            var children = this._children;
            if (!children.length)
                return;
    
            param = param.extend({ dontStart: true, dontFinish: true });
            ctx.beginPath();
            for (var i = 0, l = children.length; i < l; i++)
                children[i].draw(ctx, param, strokeMatrix);
    
            if (!param.clip) {
                this._setStyles(ctx, param, viewMatrix);
                var style = this._style;
                if (style.hasFill()) {
                    ctx.fill(style.getFillRule());
                    ctx.shadowColor = 'rgba(0,0,0,0)';
                }
                if (style.hasStroke())
                    ctx.stroke();
            }
        },
    
        _drawSelected: function(ctx, matrix, selectionItems) {
            var children = this._children;
            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i],
                    mx = child._matrix;
                if (!selectionItems[child._id]) {
                    child._drawSelected(ctx, mx.isIdentity() ? matrix
                            : matrix.appended(mx));
                }
            }
        }
    },
    new function() {
        function getCurrentPath(that, check) {
            var children = that._children;
            if (check && !children.length)
                throw new Error('Use a moveTo() command first');
            return children[children.length - 1];
        }
    
        return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',
                'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',
                'arcBy'],
            function(key) {
                this[key] = function() {
                    var path = getCurrentPath(this, true);
                    path[key].apply(path, arguments);
                };
            }, {
                moveTo: function() {
                    var current = getCurrentPath(this),
                        path = current && current.isEmpty() ? current
                                : new Path(Item.NO_INSERT);
                    if (path !== current)
                        this.addChild(path);
                    path.moveTo.apply(path, arguments);
                },
    
                moveBy: function() {
                    var current = getCurrentPath(this, true),
                        last = current && current.getLastSegment(),
                        point = Point.read(arguments);
                    this.moveTo(last ? point.add(last._point) : point);
                },
    
                closePath: function(tolerance) {
                    getCurrentPath(this, true).closePath(tolerance);
                }
            }
        );
    }, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {
        this[key] = function(param) {
            var children = this._children,
                res;
            for (var i = 0, l = children.length; i < l; i++) {
                res = children[i][key](param) || res;
            }
            return res;
        };
    }, {}));
    
    PathItem.inject(new function() {
        var min = Math.min,
            max = Math.max,
            abs = Math.abs,
            operators = {
                unite:     { '1': true, '2': true },
                intersect: { '2': true },
                subtract:  { '1': true },
                exclude:   { '1': true, '-1': true }
            };
    
        function preparePath(path, resolve) {
            var res = path.clone(false).reduce({ simplify: true })
                    .transform(null, true, true);
            return resolve
                    ? res.resolveCrossings().reorient(
                        res.getFillRule() === 'nonzero', true)
                    : res;
        }
    
        function createResult(paths, simplify, path1, path2, options) {
            var result = new CompoundPath(Item.NO_INSERT);
            result.addChildren(paths, true);
            result = result.reduce({ simplify: simplify });
            if (!(options && options.insert == false)) {
                result.insertAbove(path2 && path1.isSibling(path2)
                        && path1.getIndex() < path2.getIndex() ? path2 : path1);
            }
            result.copyAttributes(path1, true);
            return result;
        }
    
        function traceBoolean(path1, path2, operation, options) {
            if (options && (options.trace == false || options.stroke) &&
                    /^(subtract|intersect)$/.test(operation))
                return splitBoolean(path1, path2, operation);
            var _path1 = preparePath(path1, true),
                _path2 = path2 && path1 !== path2 && preparePath(path2, true),
                operator = operators[operation];
            operator[operation] = true;
            if (_path2 && (operator.subtract || operator.exclude)
                    ^ (_path2.isClockwise() ^ _path1.isClockwise()))
                _path2.reverse();
            var crossings = divideLocations(
                    CurveLocation.expand(_path1.getCrossings(_path2))),
                paths1 = _path1._children || [_path1],
                paths2 = _path2 && (_path2._children || [_path2]),
                segments = [],
                curves = [],
                paths;
    
            function collect(paths) {
                for (var i = 0, l = paths.length; i < l; i++) {
                    var path = paths[i];
                    segments.push.apply(segments, path._segments);
                    curves.push.apply(curves, path.getCurves());
                    path._overlapsOnly = true;
                }
            }
    
            if (crossings.length) {
                collect(paths1);
                if (paths2)
                    collect(paths2);
                for (var i = 0, l = crossings.length; i < l; i++) {
                    propagateWinding(crossings[i]._segment, _path1, _path2, curves,
                            operator);
                }
                for (var i = 0, l = segments.length; i < l; i++) {
                    var segment = segments[i],
                        inter = segment._intersection;
                    if (!segment._winding) {
                        propagateWinding(segment, _path1, _path2, curves, operator);
                    }
                    if (!(inter && inter._overlap))
                        segment._path._overlapsOnly = false;
                }
                paths = tracePaths(segments, operator);
            } else {
                paths = reorientPaths(
                        paths2 ? paths1.concat(paths2) : paths1.slice(),
                        function(w) {
                            return !!operator[w];
                        });
            }
    
            return createResult(paths, true, path1, path2, options);
        }
    
        function splitBoolean(path1, path2, operation) {
            var _path1 = preparePath(path1),
                _path2 = preparePath(path2),
                crossings = _path1.getCrossings(_path2),
                subtract = operation === 'subtract',
                divide = operation === 'divide',
                added = {},
                paths = [];
    
            function addPath(path) {
                if (!added[path._id] && (divide ||
                        _path2.contains(path.getPointAt(path.getLength() / 2))
                            ^ subtract)) {
                    paths.unshift(path);
                    return added[path._id] = true;
                }
            }
    
            for (var i = crossings.length - 1; i >= 0; i--) {
                var path = crossings[i].split();
                if (path) {
                    if (addPath(path))
                        path.getFirstSegment().setHandleIn(0, 0);
                    _path1.getLastSegment().setHandleOut(0, 0);
                }
            }
            addPath(_path1);
            return createResult(paths, false, path1, path2);
        }
    
        function linkIntersections(from, to) {
            var prev = from;
            while (prev) {
                if (prev === to)
                    return;
                prev = prev._previous;
            }
            while (from._next && from._next !== to)
                from = from._next;
            if (!from._next) {
                while (to._previous)
                    to = to._previous;
                from._next = to;
                to._previous = from;
            }
        }
    
        function clearCurveHandles(curves) {
            for (var i = curves.length - 1; i >= 0; i--)
                curves[i].clearHandles();
        }
    
        function reorientPaths(paths, isInside, clockwise) {
            var length = paths && paths.length;
            if (length) {
                var lookup = Base.each(paths, function (path, i) {
                        this[path._id] = {
                            container: null,
                            winding: path.isClockwise() ? 1 : -1,
                            index: i
                        };
                    }, {}),
                    sorted = paths.slice().sort(function (a, b) {
                        return abs(b.getArea()) - abs(a.getArea());
                    }),
                    first = sorted[0];
                if (clockwise == null)
                    clockwise = first.isClockwise();
                for (var i = 0; i < length; i++) {
                    var path1 = sorted[i],
                        entry1 = lookup[path1._id],
                        point = path1.getInteriorPoint(),
                        containerWinding = 0;
                    for (var j = i - 1; j >= 0; j--) {
                        var path2 = sorted[j];
                        if (path2.contains(point)) {
                            var entry2 = lookup[path2._id];
                            containerWinding = entry2.winding;
                            entry1.winding += containerWinding;
                            entry1.container = entry2.exclude ? entry2.container
                                    : path2;
                            break;
                        }
                    }
                    if (isInside(entry1.winding) === isInside(containerWinding)) {
                        entry1.exclude = true;
                        paths[entry1.index] = null;
                    } else {
                        var container = entry1.container;
                        path1.setClockwise(container ? !container.isClockwise()
                                : clockwise);
                    }
                }
            }
            return paths;
        }
    
        function divideLocations(locations, include, clearLater) {
            var results = include && [],
                tMin = 1e-8,
                tMax = 1 - tMin,
                clearHandles = false,
                clearCurves = clearLater || [],
                clearLookup = clearLater && {},
                renormalizeLocs,
                prevCurve,
                prevTime;
    
            function getId(curve) {
                return curve._path._id + '.' + curve._segment1._index;
            }
    
            for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
                var curve = clearLater[i];
                if (curve._path)
                    clearLookup[getId(curve)] = true;
            }
    
            for (var i = locations.length - 1; i >= 0; i--) {
                var loc = locations[i],
                    time = loc._time,
                    origTime = time,
                    exclude = include && !include(loc),
                    curve = loc._curve,
                    segment;
                if (curve) {
                    if (curve !== prevCurve) {
                        clearHandles = !curve.hasHandles()
                                || clearLookup && clearLookup[getId(curve)];
                        renormalizeLocs = [];
                        prevTime = null;
                        prevCurve = curve;
                    } else if (prevTime >= tMin) {
                        time /= prevTime;
                    }
                }
                if (exclude) {
                    if (renormalizeLocs)
                        renormalizeLocs.push(loc);
                    continue;
                } else if (include) {
                    results.unshift(loc);
                }
                prevTime = origTime;
                if (time < tMin) {
                    segment = curve._segment1;
                } else if (time > tMax) {
                    segment = curve._segment2;
                } else {
                    var newCurve = curve.divideAtTime(time, true);
                    if (clearHandles)
                        clearCurves.push(curve, newCurve);
                    segment = newCurve._segment1;
                    for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
                        var l = renormalizeLocs[j];
                        l._time = (l._time - time) / (1 - time);
                    }
                }
                loc._setSegment(segment);
                var inter = segment._intersection,
                    dest = loc._intersection;
                if (inter) {
                    linkIntersections(inter, dest);
                    var other = inter;
                    while (other) {
                        linkIntersections(other._intersection, inter);
                        other = other._next;
                    }
                } else {
                    segment._intersection = dest;
                }
            }
            if (!clearLater)
                clearCurveHandles(clearCurves);
            return results || locations;
        }
    
        function getWinding(point, curves, dir, closed, dontFlip) {
            var ia = dir ? 1 : 0,
                io = ia ^ 1,
                pv = [point.x, point.y],
                pa = pv[ia],
                po = pv[io],
                windingEpsilon = 1e-9,
                qualityEpsilon = 1e-6,
                paL = pa - windingEpsilon,
                paR = pa + windingEpsilon,
                windingL = 0,
                windingR = 0,
                pathWindingL = 0,
                pathWindingR = 0,
                onPath = false,
                onAnyPath = false,
                quality = 1,
                roots = [],
                vPrev,
                vClose;
    
            function addWinding(v) {
                var o0 = v[io + 0],
                    o3 = v[io + 6];
                if (po < min(o0, o3) || po > max(o0, o3)) {
                    return;
                }
                var a0 = v[ia + 0],
                    a1 = v[ia + 2],
                    a2 = v[ia + 4],
                    a3 = v[ia + 6];
                if (o0 === o3) {
                    if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
                        onPath = true;
                    }
                    return;
                }
                var t =   po === o0 ? 0
                        : po === o3 ? 1
                        : paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)
                        ? 1
                        : Curve.solveCubic(v, io, po, roots, 0, 1) > 0
                            ? roots[0]
                            : 1,
                    a =   t === 0 ? a0
                        : t === 1 ? a3
                        : Curve.getPoint(v, t)[dir ? 'y' : 'x'],
                    winding = o0 > o3 ? 1 : -1,
                    windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
                    a3Prev = vPrev[ia + 6];
                if (po !== o0) {
                    if (a < paL) {
                        pathWindingL += winding;
                    } else if (a > paR) {
                        pathWindingR += winding;
                    } else {
                        onPath = true;
                    }
                    if (a > pa - qualityEpsilon && a < pa + qualityEpsilon)
                        quality /= 2;
                } else {
                    if (winding !== windingPrev) {
                        if (a0 < paL) {
                            pathWindingL += winding;
                        } else if (a0 > paR) {
                            pathWindingR += winding;
                        }
                    } else if (a0 != a3Prev) {
                        if (a3Prev < paR && a > paR) {
                            pathWindingR += winding;
                            onPath = true;
                        } else if (a3Prev > paL && a < paL) {
                            pathWindingL += winding;
                            onPath = true;
                        }
                    }
                    quality = 0;
                }
                vPrev = v;
                return !dontFlip && a > paL && a < paR
                        && Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0
                        && getWinding(point, curves, !dir, closed, true);
            }
    
            function handleCurve(v) {
                var o0 = v[io + 0],
                    o1 = v[io + 2],
                    o2 = v[io + 4],
                    o3 = v[io + 6];
                if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
                    var a0 = v[ia + 0],
                        a1 = v[ia + 2],
                        a2 = v[ia + 4],
                        a3 = v[ia + 6],
                        monoCurves = paL > max(a0, a1, a2, a3) ||
                                     paR < min(a0, a1, a2, a3)
                                ? [v] : Curve.getMonoCurves(v, dir),
                        res;
                    for (var i = 0, l = monoCurves.length; i < l; i++) {
                        if (res = addWinding(monoCurves[i]))
                            return res;
                    }
                }
            }
    
            for (var i = 0, l = curves.length; i < l; i++) {
                var curve = curves[i],
                    path = curve._path,
                    v = curve.getValues(),
                    res;
                if (!i || curves[i - 1]._path !== path) {
                    vPrev = null;
                    if (!path._closed) {
                        vClose = Curve.getValues(
                                path.getLastCurve().getSegment2(),
                                curve.getSegment1(),
                                null, !closed);
                        if (vClose[io] !== vClose[io + 6]) {
                            vPrev = vClose;
                        }
                    }
    
                    if (!vPrev) {
                        vPrev = v;
                        var prev = path.getLastCurve();
                        while (prev && prev !== curve) {
                            var v2 = prev.getValues();
                            if (v2[io] !== v2[io + 6]) {
                                vPrev = v2;
                                break;
                            }
                            prev = prev.getPrevious();
                        }
                    }
                }
    
                if (res = handleCurve(v))
                    return res;
    
                if (i + 1 === l || curves[i + 1]._path !== path) {
                    if (vClose && (res = handleCurve(vClose)))
                        return res;
                    if (onPath && !pathWindingL && !pathWindingR) {
                        pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir
                                ? 1 : -1;
                    }
                    windingL += pathWindingL;
                    windingR += pathWindingR;
                    pathWindingL = pathWindingR = 0;
                    if (onPath) {
                        onAnyPath = true;
                        onPath = false;
                    }
                    vClose = null;
                }
            }
            windingL = abs(windingL);
            windingR = abs(windingR);
            return {
                winding: max(windingL, windingR),
                windingL: windingL,
                windingR: windingR,
                quality: quality,
                onPath: onAnyPath
            };
        }
    
        function propagateWinding(segment, path1, path2, curves, operator) {
            var chain = [],
                start = segment,
                totalLength = 0,
                winding;
            do {
                var curve = segment.getCurve(),
                    length = curve.getLength();
                chain.push({ segment: segment, curve: curve, length: length });
                totalLength += length;
                segment = segment.getNext();
            } while (segment && !segment._intersection && segment !== start);
            var offsets = [0.5, 0.25, 0.75],
                winding = { winding: 0, quality: -1 },
                tMin = 1e-8,
                tMax = 1 - tMin;
            for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
                var length = totalLength * offsets[i];
                for (var j = 0, l = chain.length; j < l; j++) {
                    var entry = chain[j],
                        curveLength = entry.length;
                    if (length <= curveLength) {
                        var curve = entry.curve,
                            path = curve._path,
                            parent = path._parent,
                            operand = parent instanceof CompoundPath ? parent : path,
                            t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
                            pt = curve.getPointAtTime(t),
                            dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
                        var wind = !(operator.subtract && path2 && (
                                operand === path1 &&
                                    path2._getWinding(pt, dir, true).winding ||
                                operand === path2 &&
                                    !path1._getWinding(pt, dir, true).winding))
                                ? getWinding(pt, curves, dir, true)
                                : { winding: 0, quality: 1 };
                        if (wind.quality > winding.quality)
                            winding = wind;
                        break;
                    }
                    length -= curveLength;
                }
            }
            for (var j = chain.length - 1; j >= 0; j--) {
                chain[j].segment._winding = winding;
            }
        }
    
        function tracePaths(segments, operator) {
            var paths = [],
                starts;
    
            function isValid(seg) {
                var winding;
                return !!(seg && !seg._visited && (!operator
                        || operator[(winding = seg._winding || {}).winding]
                            && !(operator.unite && winding.winding === 2
                                && winding.windingL && winding.windingR)));
            }
    
            function isStart(seg) {
                if (seg) {
                    for (var i = 0, l = starts.length; i < l; i++) {
                        if (seg === starts[i])
                            return true;
                    }
                }
                return false;
            }
    
            function visitPath(path) {
                var segments = path._segments;
                for (var i = 0, l = segments.length; i < l; i++) {
                    segments[i]._visited = true;
                }
            }
    
            function getCrossingSegments(segment, collectStarts) {
                var inter = segment._intersection,
                    start = inter,
                    crossings = [];
                if (collectStarts)
                    starts = [segment];
    
                function collect(inter, end) {
                    while (inter && inter !== end) {
                        var other = inter._segment,
                            path = other && other._path;
                        if (path) {
                            var next = other.getNext() || path.getFirstSegment(),
                                nextInter = next._intersection;
                            if (other !== segment && (isStart(other)
                                || isStart(next)
                                || next && (isValid(other) && (isValid(next)
                                    || nextInter && isValid(nextInter._segment))))
                            ) {
                                crossings.push(other);
                            }
                            if (collectStarts)
                                starts.push(other);
                        }
                        inter = inter._next;
                    }
                }
    
                if (inter) {
                    collect(inter);
                    while (inter && inter._prev)
                        inter = inter._prev;
                    collect(inter, start);
                }
                return crossings;
            }
    
            segments.sort(function(seg1, seg2) {
                var inter1 = seg1._intersection,
                    inter2 = seg2._intersection,
                    over1 = !!(inter1 && inter1._overlap),
                    over2 = !!(inter2 && inter2._overlap),
                    path1 = seg1._path,
                    path2 = seg2._path;
                return over1 ^ over2
                        ? over1 ? 1 : -1
                        : !inter1 ^ !inter2
                            ? inter1 ? 1 : -1
                            : path1 !== path2
                                ? path1._id - path2._id
                                : seg1._index - seg2._index;
            });
    
            for (var i = 0, l = segments.length; i < l; i++) {
                var seg = segments[i],
                    valid = isValid(seg),
                    path = null,
                    finished = false,
                    closed = true,
                    branches = [],
                    branch,
                    visited,
                    handleIn;
                if (valid && seg._path._overlapsOnly) {
                    var path1 = seg._path,
                        path2 = seg._intersection._segment._path;
                    if (path1.compare(path2)) {
                        if (path1.getArea())
                            paths.push(path1.clone(false));
                        visitPath(path1);
                        visitPath(path2);
                        valid = false;
                    }
                }
                while (valid) {
                    var first = !path,
                        crossings = getCrossingSegments(seg, first),
                        other = crossings.shift(),
                        finished = !first && (isStart(seg) || isStart(other)),
                        cross = !finished && other;
                    if (first) {
                        path = new Path(Item.NO_INSERT);
                        branch = null;
                    }
                    if (finished) {
                        if (seg.isFirst() || seg.isLast())
                            closed = seg._path._closed;
                        seg._visited = true;
                        break;
                    }
                    if (cross && branch) {
                        branches.push(branch);
                        branch = null;
                    }
                    if (!branch) {
                        if (cross)
                            crossings.push(seg);
                        branch = {
                            start: path._segments.length,
                            crossings: crossings,
                            visited: visited = [],
                            handleIn: handleIn
                        };
                    }
                    if (cross)
                        seg = other;
                    if (!isValid(seg)) {
                        path.removeSegments(branch.start);
                        for (var j = 0, k = visited.length; j < k; j++) {
                            visited[j]._visited = false;
                        }
                        visited.length = 0;
                        do {
                            seg = branch && branch.crossings.shift();
                            if (!seg || !seg._path) {
                                seg = null;
                                branch = branches.pop();
                                if (branch) {
                                    visited = branch.visited;
                                    handleIn = branch.handleIn;
                                }
                            }
                        } while (branch && !isValid(seg));
                        if (!seg)
                            break;
                    }
                    var next = seg.getNext();
                    path.add(new Segment(seg._point, handleIn,
                            next && seg._handleOut));
                    seg._visited = true;
                    visited.push(seg);
                    seg = next || seg._path.getFirstSegment();
                    handleIn = next && next._handleIn;
                }
                if (finished) {
                    if (closed) {
                        path.getFirstSegment().setHandleIn(handleIn);
                        path.setClosed(closed);
                    }
                    if (path.getArea() !== 0) {
                        paths.push(path);
                    }
                }
            }
            return paths;
        }
    
        return {
            _getWinding: function(point, dir, closed) {
                return getWinding(point, this.getCurves(), dir, closed);
            },
    
            unite: function(path, options) {
                return traceBoolean(this, path, 'unite', options);
            },
    
            intersect: function(path, options) {
                return traceBoolean(this, path, 'intersect', options);
            },
    
            subtract: function(path, options) {
                return traceBoolean(this, path, 'subtract', options);
            },
    
            exclude: function(path, options) {
                return traceBoolean(this, path, 'exclude', options);
            },
    
            divide: function(path, options) {
                return options && (options.trace == false || options.stroke)
                        ? splitBoolean(this, path, 'divide')
                        : createResult([
                            this.subtract(path, options),
                            this.intersect(path, options)
                        ], true, this, path, options);
            },
    
            resolveCrossings: function() {
                var children = this._children,
                    paths = children || [this];
    
                function hasOverlap(seg, path) {
                    var inter = seg && seg._intersection;
                    return inter && inter._overlap && inter._path === path;
                }
    
                var hasOverlaps = false,
                    hasCrossings = false,
                    intersections = this.getIntersections(null, function(inter) {
                        return inter.hasOverlap() && (hasOverlaps = true) ||
                                inter.isCrossing() && (hasCrossings = true);
                    }),
                    clearCurves = hasOverlaps && hasCrossings && [];
                intersections = CurveLocation.expand(intersections);
                if (hasOverlaps) {
                    var overlaps = divideLocations(intersections, function(inter) {
                        return inter.hasOverlap();
                    }, clearCurves);
                    for (var i = overlaps.length - 1; i >= 0; i--) {
                        var overlap = overlaps[i],
                            path = overlap._path,
                            seg = overlap._segment,
                            prev = seg.getPrevious(),
                            next = seg.getNext();
                        if (hasOverlap(prev, path) && hasOverlap(next, path)) {
                            seg.remove();
                            prev._handleOut._set(0, 0);
                            next._handleIn._set(0, 0);
                            if (prev !== seg && !prev.getCurve().hasLength()) {
                                next._handleIn.set(prev._handleIn);
                                prev.remove();
                            }
                        }
                    }
                }
                if (hasCrossings) {
                    divideLocations(intersections, hasOverlaps && function(inter) {
                        var curve1 = inter.getCurve(),
                            seg1 = inter.getSegment(),
                            other = inter._intersection,
                            curve2 = other._curve,
                            seg2 = other._segment;
                        if (curve1 && curve2 && curve1._path && curve2._path)
                            return true;
                        if (seg1)
                            seg1._intersection = null;
                        if (seg2)
                            seg2._intersection = null;
                    }, clearCurves);
                    if (clearCurves)
                        clearCurveHandles(clearCurves);
                    paths = tracePaths(Base.each(paths, function(path) {
                        this.push.apply(this, path._segments);
                    }, []));
                }
                var length = paths.length,
                    item;
                if (length > 1 && children) {
                    if (paths !== children)
                        this.setChildren(paths);
                    item = this;
                } else if (length === 1 && !children) {
                    if (paths[0] !== this)
                        this.setSegments(paths[0].removeSegments());
                    item = this;
                }
                if (!item) {
                    item = new CompoundPath(Item.NO_INSERT);
                    item.addChildren(paths);
                    item = item.reduce();
                    item.copyAttributes(this);
                    this.replaceWith(item);
                }
                return item;
            },
    
            reorient: function(nonZero, clockwise) {
                var children = this._children;
                if (children && children.length) {
                    this.setChildren(reorientPaths(this.removeChildren(),
                            function(w) {
                                return !!(nonZero ? w : w & 1);
                            },
                            clockwise));
                } else if (clockwise !== undefined) {
                    this.setClockwise(clockwise);
                }
                return this;
            },
    
            getInteriorPoint: function() {
                var bounds = this.getBounds(),
                    point = bounds.getCenter(true);
                if (!this.contains(point)) {
                    var curves = this.getCurves(),
                        y = point.y,
                        intercepts = [],
                        roots = [];
                    for (var i = 0, l = curves.length; i < l; i++) {
                        var v = curves[i].getValues(),
                            o0 = v[1],
                            o1 = v[3],
                            o2 = v[5],
                            o3 = v[7];
                        if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
                            var monoCurves = Curve.getMonoCurves(v);
                            for (var j = 0, m = monoCurves.length; j < m; j++) {
                                var mv = monoCurves[j],
                                    mo0 = mv[1],
                                    mo3 = mv[7];
                                if ((mo0 !== mo3) &&
                                    (y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){
                                    var x = y === mo0 ? mv[0]
                                        : y === mo3 ? mv[6]
                                        : Curve.solveCubic(mv, 1, y, roots, 0, 1)
                                            === 1
                                            ? Curve.getPoint(mv, roots[0]).x
                                            : (mv[0] + mv[6]) / 2;
                                    intercepts.push(x);
                                }
                            }
                        }
                    }
                    if (intercepts.length > 1) {
                        intercepts.sort(function(a, b) { return a - b; });
                        point.x = (intercepts[0] + intercepts[1]) / 2;
                    }
                }
                return point;
            }
        };
    });
    
    var PathFlattener = Base.extend({
        _class: 'PathFlattener',
    
        initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {
            var curves = [],
                parts = [],
                length = 0,
                minSpan = 1 / (maxRecursion || 32),
                segments = path._segments,
                segment1 = segments[0],
                segment2;
    
            function addCurve(segment1, segment2) {
                var curve = Curve.getValues(segment1, segment2, matrix);
                curves.push(curve);
                computeParts(curve, segment1._index, 0, 1);
            }
    
            function computeParts(curve, index, t1, t2) {
                if ((t2 - t1) > minSpan
                        && !(ignoreStraight && Curve.isStraight(curve))
                        && !Curve.isFlatEnough(curve, flatness || 0.25)) {
                    var halves = Curve.subdivide(curve, 0.5),
                        tMid = (t1 + t2) / 2;
                    computeParts(halves[0], index, t1, tMid);
                    computeParts(halves[1], index, tMid, t2);
                } else {
                    var dx = curve[6] - curve[0],
                        dy = curve[7] - curve[1],
                        dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        length += dist;
                        parts.push({
                            offset: length,
                            curve: curve,
                            index: index,
                            time: t2,
                        });
                    }
                }
            }
    
            for (var i = 1, l = segments.length; i < l; i++) {
                segment2 = segments[i];
                addCurve(segment1, segment2);
                segment1 = segment2;
            }
            if (path._closed)
                addCurve(segment2, segments[0]);
            this.curves = curves;
            this.parts = parts;
            this.length = length;
            this.index = 0;
        },
    
        _get: function(offset) {
            var parts = this.parts,
                length = parts.length,
                start,
                i, j = this.index;
            for (;;) {
                i = j;
                if (!j || parts[--j].offset < offset)
                    break;
            }
            for (; i < length; i++) {
                var part = parts[i];
                if (part.offset >= offset) {
                    this.index = i;
                    var prev = parts[i - 1],
                        prevTime = prev && prev.index === part.index ? prev.time : 0,
                        prevOffset = prev ? prev.offset : 0;
                    return {
                        index: part.index,
                        time: prevTime + (part.time - prevTime)
                            * (offset - prevOffset) / (part.offset - prevOffset)
                    };
                }
            }
            return {
                index: parts[length - 1].index,
                time: 1
            };
        },
    
        drawPart: function(ctx, from, to) {
            var start = this._get(from),
                end = this._get(to);
            for (var i = start.index, l = end.index; i <= l; i++) {
                var curve = Curve.getPart(this.curves[i],
                        i === start.index ? start.time : 0,
                        i === end.index ? end.time : 1);
                if (i === start.index)
                    ctx.moveTo(curve[0], curve[1]);
                ctx.bezierCurveTo.apply(ctx, curve.slice(2));
            }
        }
    }, Base.each(Curve._evaluateMethods,
        function(name) {
            this[name + 'At'] = function(offset) {
                var param = this._get(offset);
                return Curve[name](this.curves[param.index], param.time);
            };
        }, {})
    );
    
    var PathFitter = Base.extend({
        initialize: function(path) {
            var points = this.points = [],
                segments = path._segments,
                closed = path._closed;
            for (var i = 0, prev, l = segments.length; i < l; i++) {
                var point = segments[i].point;
                if (!prev || !prev.equals(point)) {
                    points.push(prev = point.clone());
                }
            }
            if (closed) {
                points.unshift(points[points.length - 1]);
                points.push(points[1]);
            }
            this.closed = closed;
        },
    
        fit: function(error) {
            var points = this.points,
                length = points.length,
                segments = null;
            if (length > 0) {
                segments = [new Segment(points[0])];
                if (length > 1) {
                    this.fitCubic(segments, error, 0, length - 1,
                            points[1].subtract(points[0]),
                            points[length - 2].subtract(points[length - 1]));
                    if (this.closed) {
                        segments.shift();
                        segments.pop();
                    }
                }
            }
            return segments;
        },
    
        fitCubic: function(segments, error, first, last, tan1, tan2) {
            var points = this.points;
            if (last - first === 1) {
                var pt1 = points[first],
                    pt2 = points[last],
                    dist = pt1.getDistance(pt2) / 3;
                this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),
                        pt2.add(tan2.normalize(dist)), pt2]);
                return;
            }
            var uPrime = this.chordLengthParameterize(first, last),
                maxError = Math.max(error, error * error),
                split,
                parametersInOrder = true;
            for (var i = 0; i <= 4; i++) {
                var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
                var max = this.findMaxError(first, last, curve, uPrime);
                if (max.error < error && parametersInOrder) {
                    this.addCurve(segments, curve);
                    return;
                }
                split = max.index;
                if (max.error >= maxError)
                    break;
                parametersInOrder = this.reparameterize(first, last, uPrime, curve);
                maxError = max.error;
            }
            var tanCenter = points[split - 1].subtract(points[split + 1]);
            this.fitCubic(segments, error, first, split, tan1, tanCenter);
            this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
        },
    
        addCurve: function(segments, curve) {
            var prev = segments[segments.length - 1];
            prev.setHandleOut(curve[1].subtract(curve[0]));
            segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
        },
    
        generateBezier: function(first, last, uPrime, tan1, tan2) {
            var epsilon = 1e-12,
                abs = Math.abs,
                points = this.points,
                pt1 = points[first],
                pt2 = points[last],
                C = [[0, 0], [0, 0]],
                X = [0, 0];
    
            for (var i = 0, l = last - first + 1; i < l; i++) {
                var u = uPrime[i],
                    t = 1 - u,
                    b = 3 * u * t,
                    b0 = t * t * t,
                    b1 = b * t,
                    b2 = b * u,
                    b3 = u * u * u,
                    a1 = tan1.normalize(b1),
                    a2 = tan2.normalize(b2),
                    tmp = points[first + i]
                        .subtract(pt1.multiply(b0 + b1))
                        .subtract(pt2.multiply(b2 + b3));
                C[0][0] += a1.dot(a1);
                C[0][1] += a1.dot(a2);
                C[1][0] = C[0][1];
                C[1][1] += a2.dot(a2);
                X[0] += a1.dot(tmp);
                X[1] += a2.dot(tmp);
            }
    
            var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
                alpha1,
                alpha2;
            if (abs(detC0C1) > epsilon) {
                var detC0X = C[0][0] * X[1]    - C[1][0] * X[0],
                    detXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];
                alpha1 = detXC1 / detC0C1;
                alpha2 = detC0X / detC0C1;
            } else {
                var c0 = C[0][0] + C[0][1],
                    c1 = C[1][0] + C[1][1];
                alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0
                                : abs(c1) > epsilon ? X[1] / c1
                                : 0;
            }
    
            var segLength = pt2.getDistance(pt1),
                eps = epsilon * segLength,
                handle1,
                handle2;
            if (alpha1 < eps || alpha2 < eps) {
                alpha1 = alpha2 = segLength / 3;
            } else {
                var line = pt2.subtract(pt1);
                handle1 = tan1.normalize(alpha1);
                handle2 = tan2.normalize(alpha2);
                if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
                    alpha1 = alpha2 = segLength / 3;
                    handle1 = handle2 = null;
                }
            }
    
            return [pt1,
                    pt1.add(handle1 || tan1.normalize(alpha1)),
                    pt2.add(handle2 || tan2.normalize(alpha2)),
                    pt2];
        },
    
        reparameterize: function(first, last, u, curve) {
            for (var i = first; i <= last; i++) {
                u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
            }
            for (var i = 1, l = u.length; i < l; i++) {
                if (u[i] <= u[i - 1])
                    return false;
            }
            return true;
        },
    
        findRoot: function(curve, point, u) {
            var curve1 = [],
                curve2 = [];
            for (var i = 0; i <= 2; i++) {
                curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
            }
            for (var i = 0; i <= 1; i++) {
                curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
            }
            var pt = this.evaluate(3, curve, u),
                pt1 = this.evaluate(2, curve1, u),
                pt2 = this.evaluate(1, curve2, u),
                diff = pt.subtract(point),
                df = pt1.dot(pt1) + diff.dot(pt2);
            return Numerical.isZero(df) ? u : u - diff.dot(pt1) / df;
        },
    
        evaluate: function(degree, curve, t) {
            var tmp = curve.slice();
            for (var i = 1; i <= degree; i++) {
                for (var j = 0; j <= degree - i; j++) {
                    tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
                }
            }
            return tmp[0];
        },
    
        chordLengthParameterize: function(first, last) {
            var u = [0];
            for (var i = first + 1; i <= last; i++) {
                u[i - first] = u[i - first - 1]
                        + this.points[i].getDistance(this.points[i - 1]);
            }
            for (var i = 1, m = last - first; i <= m; i++) {
                u[i] /= u[m];
            }
            return u;
        },
    
        findMaxError: function(first, last, curve, u) {
            var index = Math.floor((last - first + 1) / 2),
                maxDist = 0;
            for (var i = first + 1; i < last; i++) {
                var P = this.evaluate(3, curve, u[i - first]);
                var v = P.subtract(this.points[i]);
                var dist = v.x * v.x + v.y * v.y;
                if (dist >= maxDist) {
                    maxDist = dist;
                    index = i;
                }
            }
            return {
                error: maxDist,
                index: index
            };
        }
    });
    
    var TextItem = Item.extend({
        _class: 'TextItem',
        _applyMatrix: false,
        _canApplyMatrix: false,
        _serializeFields: {
            content: null
        },
        _boundsOptions: { stroke: false, handle: false },
    
        initialize: function TextItem(arg) {
            this._content = '';
            this._lines = [];
            var hasProps = arg && Base.isPlainObject(arg)
                    && arg.x === undefined && arg.y === undefined;
            this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
        },
    
        _equals: function(item) {
            return this._content === item._content;
        },
    
        copyContent: function(source) {
            this.setContent(source._content);
        },
    
        getContent: function() {
            return this._content;
        },
    
        setContent: function(content) {
            this._content = '' + content;
            this._lines = this._content.split(/\r\n|\n|\r/mg);
            this._changed(265);
        },
    
        isEmpty: function() {
            return !this._content;
        },
    
        getCharacterStyle: '#getStyle',
        setCharacterStyle: '#setStyle',
    
        getParagraphStyle: '#getStyle',
        setParagraphStyle: '#setStyle'
    });
    
    var PointText = TextItem.extend({
        _class: 'PointText',
    
        initialize: function PointText() {
            TextItem.apply(this, arguments);
        },
    
        getPoint: function() {
            var point = this._matrix.getTranslation();
            return new LinkedPoint(point.x, point.y, this, 'setPoint');
        },
    
        setPoint: function() {
            var point = Point.read(arguments);
            this.translate(point.subtract(this._matrix.getTranslation()));
        },
    
        _draw: function(ctx, param, viewMatrix) {
            if (!this._content)
                return;
            this._setStyles(ctx, param, viewMatrix);
            var lines = this._lines,
                style = this._style,
                hasFill = style.hasFill(),
                hasStroke = style.hasStroke(),
                leading = style.getLeading(),
                shadowColor = ctx.shadowColor;
            ctx.font = style.getFontStyle();
            ctx.textAlign = style.getJustification();
            for (var i = 0, l = lines.length; i < l; i++) {
                ctx.shadowColor = shadowColor;
                var line = lines[i];
                if (hasFill) {
                    ctx.fillText(line, 0, 0);
                    ctx.shadowColor = 'rgba(0,0,0,0)';
                }
                if (hasStroke)
                    ctx.strokeText(line, 0, 0);
                ctx.translate(0, leading);
            }
        },
    
        _getBounds: function(matrix, options) {
            var style = this._style,
                lines = this._lines,
                numLines = lines.length,
                justification = style.getJustification(),
                leading = style.getLeading(),
                width = this.getView().getTextWidth(style.getFontStyle(), lines),
                x = 0;
            if (justification !== 'left')
                x -= width / (justification === 'center' ? 2: 1);
            var rect = new Rectangle(x,
                        numLines ? - 0.75 * leading : 0,
                        width, numLines * leading);
            return matrix ? matrix._transformBounds(rect, rect) : rect;
        }
    });
    
    var Color = Base.extend(new function() {
        var types = {
            gray: ['gray'],
            rgb: ['red', 'green', 'blue'],
            hsb: ['hue', 'saturation', 'brightness'],
            hsl: ['hue', 'saturation', 'lightness'],
            gradient: ['gradient', 'origin', 'destination', 'highlight']
        };
    
        var componentParsers = {},
            colorCache = {},
            colorCtx;
    
        function fromCSS(string) {
            var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
                components;
            if (match) {
                components = [0, 0, 0];
                for (var i = 0; i < 3; i++) {
                    var value = match[i + 1];
                    components[i] = parseInt(value.length == 1
                            ? value + value : value, 16) / 255;
                }
            } else if (match = string.match(/^rgba?\((.*)\)$/)) {
                components = match[1].split(',');
                for (var i = 0, l = components.length; i < l; i++) {
                    var value = +components[i];
                    components[i] = i < 3 ? value / 255 : value;
                }
            } else if (window) {
                var cached = colorCache[string];
                if (!cached) {
                    if (!colorCtx) {
                        colorCtx = CanvasProvider.getContext(1, 1);
                        colorCtx.globalCompositeOperation = 'copy';
                    }
                    colorCtx.fillStyle = 'rgba(0,0,0,0)';
                    colorCtx.fillStyle = string;
                    colorCtx.fillRect(0, 0, 1, 1);
                    var data = colorCtx.getImageData(0, 0, 1, 1).data;
                    cached = colorCache[string] = [
                        data[0] / 255,
                        data[1] / 255,
                        data[2] / 255
                    ];
                }
                components = cached.slice();
            } else {
                components = [0, 0, 0];
            }
            return components;
        }
    
        var hsbIndices = [
            [0, 3, 1],
            [2, 0, 1],
            [1, 0, 3],
            [1, 2, 0],
            [3, 1, 0],
            [0, 1, 2]
        ];
    
        var converters = {
            'rgb-hsb': function(r, g, b) {
                var max = Math.max(r, g, b),
                    min = Math.min(r, g, b),
                    delta = max - min,
                    h = delta === 0 ? 0
                        :   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
                            : max == g ? (b - r) / delta + 2
                            :            (r - g) / delta + 4) * 60;
                return [h, max === 0 ? 0 : delta / max, max];
            },
    
            'hsb-rgb': function(h, s, b) {
                h = (((h / 60) % 6) + 6) % 6;
                var i = Math.floor(h),
                    f = h - i,
                    i = hsbIndices[i],
                    v = [
                        b,
                        b * (1 - s),
                        b * (1 - s * f),
                        b * (1 - s * (1 - f))
                    ];
                return [v[i[0]], v[i[1]], v[i[2]]];
            },
    
            'rgb-hsl': function(r, g, b) {
                var max = Math.max(r, g, b),
                    min = Math.min(r, g, b),
                    delta = max - min,
                    achromatic = delta === 0,
                    h = achromatic ? 0
                        :   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
                            : max == g ? (b - r) / delta + 2
                            :            (r - g) / delta + 4) * 60,
                    l = (max + min) / 2,
                    s = achromatic ? 0 : l < 0.5
                            ? delta / (max + min)
                            : delta / (2 - max - min);
                return [h, s, l];
            },
    
            'hsl-rgb': function(h, s, l) {
                h = (((h / 360) % 1) + 1) % 1;
                if (s === 0)
                    return [l, l, l];
                var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
                    t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
                    t1 = 2 * l - t2,
                    c = [];
                for (var i = 0; i < 3; i++) {
                    var t3 = t3s[i];
                    if (t3 < 0) t3 += 1;
                    if (t3 > 1) t3 -= 1;
                    c[i] = 6 * t3 < 1
                        ? t1 + (t2 - t1) * 6 * t3
                        : 2 * t3 < 1
                            ? t2
                            : 3 * t3 < 2
                                ? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
                                : t1;
                }
                return c;
            },
    
            'rgb-gray': function(r, g, b) {
                return [r * 0.2989 + g * 0.587 + b * 0.114];
            },
    
            'gray-rgb': function(g) {
                return [g, g, g];
            },
    
            'gray-hsb': function(g) {
                return [0, 0, g];
            },
    
            'gray-hsl': function(g) {
                return [0, 0, g];
            },
    
            'gradient-rgb': function() {
                return [];
            },
    
            'rgb-gradient': function() {
                return [];
            }
    
        };
    
        return Base.each(types, function(properties, type) {
            componentParsers[type] = [];
            Base.each(properties, function(name, index) {
                var part = Base.capitalize(name),
                    hasOverlap = /^(hue|saturation)$/.test(name),
                    parser = componentParsers[type][index] = name === 'gradient'
                        ? function(value) {
                            var current = this._components[0];
                            value = Gradient.read(Array.isArray(value) ? value
                                    : arguments, 0, { readNull: true });
                            if (current !== value) {
                                if (current)
                                    current._removeOwner(this);
                                if (value)
                                    value._addOwner(this);
                            }
                            return value;
                        }
                        : type === 'gradient'
                            ? function() {
                                return Point.read(arguments, 0, {
                                        readNull: name === 'highlight',
                                        clone: true
                                });
                            }
                            : function(value) {
                                return value == null || isNaN(value) ? 0 : value;
                            };
    
                this['get' + part] = function() {
                    return this._type === type
                        || hasOverlap && /^hs[bl]$/.test(this._type)
                            ? this._components[index]
                            : this._convert(type)[index];
                };
    
                this['set' + part] = function(value) {
                    if (this._type !== type
                            && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
                        this._components = this._convert(type);
                        this._properties = types[type];
                        this._type = type;
                    }
                    this._components[index] = parser.call(this, value);
                    this._changed();
                };
            }, this);
        }, {
            _class: 'Color',
            _readIndex: true,
    
            initialize: function Color(arg) {
                var args = arguments,
                    reading = this.__read,
                    read = 0,
                    type,
                    components,
                    alpha,
                    values;
                if (Array.isArray(arg)) {
                    args = arg;
                    arg = args[0];
                }
                var argType = arg != null && typeof arg;
                if (argType === 'string' && arg in types) {
                    type = arg;
                    arg = args[1];
                    if (Array.isArray(arg)) {
                        components = arg;
                        alpha = args[2];
                    } else {
                        if (reading)
                            read = 1;
                        args = Base.slice(args, 1);
                        argType = typeof arg;
                    }
                }
                if (!components) {
                    values = argType === 'number'
                            ? args
                            : argType === 'object' && arg.length != null
                                ? arg
                                : null;
                    if (values) {
                        if (!type)
                            type = values.length >= 3
                                    ? 'rgb'
                                    : 'gray';
                        var length = types[type].length;
                        alpha = values[length];
                        if (reading) {
                            read += values === arguments
                                ? length + (alpha != null ? 1 : 0)
                                : 1;
                        }
                        if (values.length > length)
                            values = Base.slice(values, 0, length);
                    } else if (argType === 'string') {
                        type = 'rgb';
                        components = fromCSS(arg);
                        if (components.length === 4) {
                            alpha = components[3];
                            components.length--;
                        }
                    } else if (argType === 'object') {
                        if (arg.constructor === Color) {
                            type = arg._type;
                            components = arg._components.slice();
                            alpha = arg._alpha;
                            if (type === 'gradient') {
                                for (var i = 1, l = components.length; i < l; i++) {
                                    var point = components[i];
                                    if (point)
                                        components[i] = point.clone();
                                }
                            }
                        } else if (arg.constructor === Gradient) {
                            type = 'gradient';
                            values = args;
                        } else {
                            type = 'hue' in arg
                                ? 'lightness' in arg
                                    ? 'hsl'
                                    : 'hsb'
                                : 'gradient' in arg || 'stops' in arg
                                        || 'radial' in arg
                                    ? 'gradient'
                                    : 'gray' in arg
                                        ? 'gray'
                                        : 'rgb';
                            var properties = types[type],
                                parsers = componentParsers[type];
                            this._components = components = [];
                            for (var i = 0, l = properties.length; i < l; i++) {
                                var value = arg[properties[i]];
                                if (value == null && !i && type === 'gradient'
                                        && 'stops' in arg) {
                                    value = {
                                        stops: arg.stops,
                                        radial: arg.radial
                                    };
                                }
                                value = parsers[i].call(this, value);
                                if (value != null)
                                    components[i] = value;
                            }
                            alpha = arg.alpha;
                        }
                    }
                    if (reading && type)
                        read = 1;
                }
                this._type = type || 'rgb';
                if (!components) {
                    this._components = components = [];
                    var parsers = componentParsers[this._type];
                    for (var i = 0, l = parsers.length; i < l; i++) {
                        var value = parsers[i].call(this, values && values[i]);
                        if (value != null)
                            components[i] = value;
                    }
                }
                this._components = components;
                this._properties = types[this._type];
                this._alpha = alpha;
                if (reading)
                    this.__read = read;
                return this;
            },
    
            set: '#initialize',
    
            _serialize: function(options, dictionary) {
                var components = this.getComponents();
                return Base.serialize(
                        /^(gray|rgb)$/.test(this._type)
                            ? components
                            : [this._type].concat(components),
                        options, true, dictionary);
            },
    
            _changed: function() {
                this._canvasStyle = null;
                if (this._owner)
                    this._owner._changed(65);
            },
    
            _convert: function(type) {
                var converter;
                return this._type === type
                        ? this._components.slice()
                        : (converter = converters[this._type + '-' + type])
                            ? converter.apply(this, this._components)
                            : converters['rgb-' + type].apply(this,
                                converters[this._type + '-rgb'].apply(this,
                                    this._components));
            },
    
            convert: function(type) {
                return new Color(type, this._convert(type), this._alpha);
            },
    
            getType: function() {
                return this._type;
            },
    
            setType: function(type) {
                this._components = this._convert(type);
                this._properties = types[type];
                this._type = type;
            },
    
            getComponents: function() {
                var components = this._components.slice();
                if (this._alpha != null)
                    components.push(this._alpha);
                return components;
            },
    
            getAlpha: function() {
                return this._alpha != null ? this._alpha : 1;
            },
    
            setAlpha: function(alpha) {
                this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
                this._changed();
            },
    
            hasAlpha: function() {
                return this._alpha != null;
            },
    
            equals: function(color) {
                var col = Base.isPlainValue(color, true)
                        ? Color.read(arguments)
                        : color;
                return col === this || col && this._class === col._class
                        && this._type === col._type
                        && this.getAlpha() === col.getAlpha()
                        && Base.equals(this._components, col._components)
                        || false;
            },
    
            toString: function() {
                var properties = this._properties,
                    parts = [],
                    isGradient = this._type === 'gradient',
                    f = Formatter.instance;
                for (var i = 0, l = properties.length; i < l; i++) {
                    var value = this._components[i];
                    if (value != null)
                        parts.push(properties[i] + ': '
                                + (isGradient ? value : f.number(value)));
                }
                if (this._alpha != null)
                    parts.push('alpha: ' + f.number(this._alpha));
                return '{ ' + parts.join(', ') + ' }';
            },
    
            toCSS: function(hex) {
                var components = this._convert('rgb'),
                    alpha = hex || this._alpha == null ? 1 : this._alpha;
                function convert(val) {
                    return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
                }
                components = [
                    convert(components[0]),
                    convert(components[1]),
                    convert(components[2])
                ];
                if (alpha < 1)
                    components.push(alpha < 0 ? 0 : alpha);
                return hex
                        ? '#' + ((1 << 24) + (components[0] << 16)
                            + (components[1] << 8)
                            + components[2]).toString(16).slice(1)
                        : (components.length == 4 ? 'rgba(' : 'rgb(')
                            + components.join(',') + ')';
            },
    
            toCanvasStyle: function(ctx, matrix) {
                if (this._canvasStyle)
                    return this._canvasStyle;
                if (this._type !== 'gradient')
                    return this._canvasStyle = this.toCSS();
                var components = this._components,
                    gradient = components[0],
                    stops = gradient._stops,
                    origin = components[1],
                    destination = components[2],
                    highlight = components[3],
                    inverse = matrix && matrix.inverted(),
                    canvasGradient;
                if (inverse) {
                    origin = inverse._transformPoint(origin);
                    destination = inverse._transformPoint(destination);
                    if (highlight)
                        highlight = inverse._transformPoint(highlight);
                }
                if (gradient._radial) {
                    var radius = destination.getDistance(origin);
                    if (highlight) {
                        var vector = highlight.subtract(origin);
                        if (vector.getLength() > radius)
                            highlight = origin.add(vector.normalize(radius - 0.1));
                    }
                    var start = highlight || origin;
                    canvasGradient = ctx.createRadialGradient(start.x, start.y,
                            0, origin.x, origin.y, radius);
                } else {
                    canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
                            destination.x, destination.y);
                }
                for (var i = 0, l = stops.length; i < l; i++) {
                    var stop = stops[i],
                        offset = stop._offset;
                    canvasGradient.addColorStop(
                            offset == null ? i / (l - 1) : offset,
                            stop._color.toCanvasStyle());
                }
                return this._canvasStyle = canvasGradient;
            },
    
            transform: function(matrix) {
                if (this._type === 'gradient') {
                    var components = this._components;
                    for (var i = 1, l = components.length; i < l; i++) {
                        var point = components[i];
                        matrix._transformPoint(point, point, true);
                    }
                    this._changed();
                }
            },
    
            statics: {
                _types: types,
    
                random: function() {
                    var random = Math.random;
                    return new Color(random(), random(), random());
                }
            }
        });
    },
    new function() {
        var operators = {
            add: function(a, b) {
                return a + b;
            },
    
            subtract: function(a, b) {
                return a - b;
            },
    
            multiply: function(a, b) {
                return a * b;
            },
    
            divide: function(a, b) {
                return a / b;
            }
        };
    
        return Base.each(operators, function(operator, name) {
            this[name] = function(color) {
                color = Color.read(arguments);
                var type = this._type,
                    components1 = this._components,
                    components2 = color._convert(type);
                for (var i = 0, l = components1.length; i < l; i++)
                    components2[i] = operator(components1[i], components2[i]);
                return new Color(type, components2,
                        this._alpha != null
                                ? operator(this._alpha, color.getAlpha())
                                : null);
            };
        }, {
        });
    });
    
    var Gradient = Base.extend({
        _class: 'Gradient',
    
        initialize: function Gradient(stops, radial) {
            this._id = UID.get();
            if (stops && Base.isPlainObject(stops)) {
                this.set(stops);
                stops = radial = null;
            }
            if (this._stops == null) {
                this.setStops(stops || ['white', 'black']);
            }
            if (this._radial == null) {
                this.setRadial(typeof radial === 'string' && radial === 'radial'
                        || radial || false);
            }
        },
    
        _serialize: function(options, dictionary) {
            return dictionary.add(this, function() {
                return Base.serialize([this._stops, this._radial],
                        options, true, dictionary);
            });
        },
    
        _changed: function() {
            for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
                this._owners[i]._changed();
            }
        },
    
        _addOwner: function(color) {
            if (!this._owners)
                this._owners = [];
            this._owners.push(color);
        },
    
        _removeOwner: function(color) {
            var index = this._owners ? this._owners.indexOf(color) : -1;
            if (index != -1) {
                this._owners.splice(index, 1);
                if (!this._owners.length)
                    this._owners = undefined;
            }
        },
    
        clone: function() {
            var stops = [];
            for (var i = 0, l = this._stops.length; i < l; i++) {
                stops[i] = this._stops[i].clone();
            }
            return new Gradient(stops, this._radial);
        },
    
        getStops: function() {
            return this._stops;
        },
    
        setStops: function(stops) {
            if (stops.length < 2) {
                throw new Error(
                        'Gradient stop list needs to contain at least two stops.');
            }
            var _stops = this._stops;
            if (_stops) {
                for (var i = 0, l = _stops.length; i < l; i++)
                    _stops[i]._owner = undefined;
            }
            _stops = this._stops = GradientStop.readList(stops, 0, { clone: true });
            for (var i = 0, l = _stops.length; i < l; i++)
                _stops[i]._owner = this;
            this._changed();
        },
    
        getRadial: function() {
            return this._radial;
        },
    
        setRadial: function(radial) {
            this._radial = radial;
            this._changed();
        },
    
        equals: function(gradient) {
            if (gradient === this)
                return true;
            if (gradient && this._class === gradient._class) {
                var stops1 = this._stops,
                    stops2 = gradient._stops,
                    length = stops1.length;
                if (length === stops2.length) {
                    for (var i = 0; i < length; i++) {
                        if (!stops1[i].equals(stops2[i]))
                            return false;
                    }
                    return true;
                }
            }
            return false;
        }
    });
    
    var GradientStop = Base.extend({
        _class: 'GradientStop',
    
        initialize: function GradientStop(arg0, arg1) {
            var color = arg0,
                offset = arg1;
            if (typeof arg0 === 'object' && arg1 === undefined) {
                if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
                    color = arg0[0];
                    offset = arg0[1];
                } else if ('color' in arg0 || 'offset' in arg0
                        || 'rampPoint' in arg0) {
                    color = arg0.color;
                    offset = arg0.offset || arg0.rampPoint || 0;
                }
            }
            this.setColor(color);
            this.setOffset(offset);
        },
    
        clone: function() {
            return new GradientStop(this._color.clone(), this._offset);
        },
    
        _serialize: function(options, dictionary) {
            var color = this._color,
                offset = this._offset;
            return Base.serialize(offset == null ? [color] : [color, offset],
                    options, true, dictionary);
        },
    
        _changed: function() {
            if (this._owner)
                this._owner._changed(65);
        },
    
        getOffset: function() {
            return this._offset;
        },
    
        setOffset: function(offset) {
            this._offset = offset;
            this._changed();
        },
    
        getRampPoint: '#getOffset',
        setRampPoint: '#setOffset',
    
        getColor: function() {
            return this._color;
        },
    
        setColor: function() {
            var color = Color.read(arguments, 0, { clone: true });
            if (color)
                color._owner = this;
            this._color = color;
            this._changed();
        },
    
        equals: function(stop) {
            return stop === this || stop && this._class === stop._class
                    && this._color.equals(stop._color)
                    && this._offset == stop._offset
                    || false;
        }
    });
    
    var Style = Base.extend(new function() {
        var itemDefaults = {
            fillColor: null,
            fillRule: 'nonzero',
            strokeColor: null,
            strokeWidth: 1,
            strokeCap: 'butt',
            strokeJoin: 'miter',
            strokeScaling: true,
            miterLimit: 10,
            dashOffset: 0,
            dashArray: [],
            shadowColor: null,
            shadowBlur: 0,
            shadowOffset: new Point(),
            selectedColor: null
        },
        groupDefaults = Base.set({}, itemDefaults, {
            fontFamily: 'sans-serif',
            fontWeight: 'normal',
            fontSize: 12,
            leading: null,
            justification: 'left'
        }),
        textDefaults = Base.set({}, groupDefaults, {
            fillColor: new Color()
        }),
        flags = {
            strokeWidth: 97,
            strokeCap: 97,
            strokeJoin: 97,
            strokeScaling: 105,
            miterLimit: 97,
            fontFamily: 9,
            fontWeight: 9,
            fontSize: 9,
            font: 9,
            leading: 9,
            justification: 9
        },
        item = {
            beans: true
        },
        fields = {
            _class: 'Style',
            beans: true,
    
            initialize: function Style(style, _owner, _project) {
                this._values = {};
                this._owner = _owner;
                this._project = _owner && _owner._project || _project
                        || paper.project;
                this._defaults = !_owner || _owner instanceof Group ? groupDefaults
                        : _owner instanceof TextItem ? textDefaults
                        : itemDefaults;
                if (style)
                    this.set(style);
            }
        };
    
        Base.each(groupDefaults, function(value, key) {
            var isColor = /Color$/.test(key),
                isPoint = key === 'shadowOffset',
                part = Base.capitalize(key),
                flag = flags[key],
                set = 'set' + part,
                get = 'get' + part;
    
            fields[set] = function(value) {
                var owner = this._owner,
                    children = owner && owner._children;
                if (children && children.length > 0
                        && !(owner instanceof CompoundPath)) {
                    for (var i = 0, l = children.length; i < l; i++)
                        children[i]._style[set](value);
                } else if (key in this._defaults) {
                    var old = this._values[key];
                    if (old !== value) {
                        if (isColor) {
                            if (old && old._owner !== undefined)
                                old._owner = undefined;
                            if (value && value.constructor === Color) {
                                if (value._owner)
                                    value = value.clone();
                                value._owner = owner;
                            }
                        }
                        this._values[key] = value;
                        if (owner)
                            owner._changed(flag || 65);
                    }
                }
            };
    
            fields[get] = function(_dontMerge) {
                var owner = this._owner,
                    children = owner && owner._children,
                    value;
                if (key in this._defaults && (!children || !children.length
                        || _dontMerge || owner instanceof CompoundPath)) {
                    var value = this._values[key];
                    if (value === undefined) {
                        value = this._defaults[key];
                        if (value && value.clone)
                            value = value.clone();
                    } else {
                        var ctor = isColor ? Color : isPoint ? Point : null;
                        if (ctor && !(value && value.constructor === ctor)) {
                            this._values[key] = value = ctor.read([value], 0,
                                    { readNull: true, clone: true });
                            if (value && isColor)
                                value._owner = owner;
                        }
                    }
                } else if (children) {
                    for (var i = 0, l = children.length; i < l; i++) {
                        var childValue = children[i]._style[get]();
                        if (!i) {
                            value = childValue;
                        } else if (!Base.equals(value, childValue)) {
                            return undefined;
                        }
                    }
                }
                return value;
            };
    
            item[get] = function(_dontMerge) {
                return this._style[get](_dontMerge);
            };
    
            item[set] = function(value) {
                this._style[set](value);
            };
        });
    
        Base.each({
            Font: 'FontFamily',
            WindingRule: 'FillRule'
        }, function(value, key) {
            var get = 'get' + key,
                set = 'set' + key;
            fields[get] = item[get] = '#get' + value;
            fields[set] = item[set] = '#set' + value;
        });
    
        Item.inject(item);
        return fields;
    }, {
        set: function(style) {
            var isStyle = style instanceof Style,
                values = isStyle ? style._values : style;
            if (values) {
                for (var key in values) {
                    if (key in this._defaults) {
                        var value = values[key];
                        this[key] = value && isStyle && value.clone
                                ? value.clone() : value;
                    }
                }
            }
        },
    
        equals: function(style) {
            function compare(style1, style2, secondary) {
                var values1 = style1._values,
                    values2 = style2._values,
                    defaults2 = style2._defaults;
                for (var key in values1) {
                    var value1 = values1[key],
                        value2 = values2[key];
                    if (!(secondary && key in values2) && !Base.equals(value1,
                            value2 === undefined ? defaults2[key] : value2))
                        return false;
                }
                return true;
            }
    
            return style === this || style && this._class === style._class
                    && compare(this, style)
                    && compare(style, this, true)
                    || false;
        },
    
        hasFill: function() {
            var color = this.getFillColor();
            return !!color && color.alpha > 0;
        },
    
        hasStroke: function() {
            var color = this.getStrokeColor();
            return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
        },
    
        hasShadow: function() {
            var color = this.getShadowColor();
            return !!color && color.alpha > 0 && (this.getShadowBlur() > 0
                    || !this.getShadowOffset().isZero());
        },
    
        getView: function() {
            return this._project._view;
        },
    
        getFontStyle: function() {
            var fontSize = this.getFontSize();
            return this.getFontWeight()
                    + ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
                    + this.getFontFamily();
        },
    
        getFont: '#getFontFamily',
        setFont: '#setFontFamily',
    
        getLeading: function getLeading() {
            var leading = getLeading.base.call(this),
                fontSize = this.getFontSize();
            if (/pt|em|%|px/.test(fontSize))
                fontSize = this.getView().getPixelSize(fontSize);
            return leading != null ? leading : fontSize * 1.2;
        }
    
    });
    
    var DomElement = new function() {
        function handlePrefix(el, name, set, value) {
            var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
                suffix = name[0].toUpperCase() + name.substring(1);
            for (var i = 0; i < 6; i++) {
                var prefix = prefixes[i],
                    key = prefix ? prefix + suffix : name;
                if (key in el) {
                    if (set) {
                        el[key] = value;
                    } else {
                        return el[key];
                    }
                    break;
                }
            }
        }
    
        return {
            getStyles: function(el) {
                var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
                    view = doc && doc.defaultView;
                return view && view.getComputedStyle(el, '');
            },
    
            getBounds: function(el, viewport) {
                var doc = el.ownerDocument,
                    body = doc.body,
                    html = doc.documentElement,
                    rect;
                try {
                    rect = el.getBoundingClientRect();
                } catch (e) {
                    rect = { left: 0, top: 0, width: 0, height: 0 };
                }
                var x = rect.left - (html.clientLeft || body.clientLeft || 0),
                    y = rect.top - (html.clientTop || body.clientTop || 0);
                if (!viewport) {
                    var view = doc.defaultView;
                    x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
                    y += view.pageYOffset || html.scrollTop || body.scrollTop;
                }
                return new Rectangle(x, y, rect.width, rect.height);
            },
    
            getViewportBounds: function(el) {
                var doc = el.ownerDocument,
                    view = doc.defaultView,
                    html = doc.documentElement;
                return new Rectangle(0, 0,
                    view.innerWidth || html.clientWidth,
                    view.innerHeight || html.clientHeight
                );
            },
    
            getOffset: function(el, viewport) {
                return DomElement.getBounds(el, viewport).getPoint();
            },
    
            getSize: function(el) {
                return DomElement.getBounds(el, true).getSize();
            },
    
            isInvisible: function(el) {
                return DomElement.getSize(el).equals(new Size(0, 0));
            },
    
            isInView: function(el) {
                return !DomElement.isInvisible(el)
                        && DomElement.getViewportBounds(el).intersects(
                            DomElement.getBounds(el, true));
            },
    
            isInserted: function(el) {
                return document.body.contains(el);
            },
    
            getPrefixed: function(el, name) {
                return el && handlePrefix(el, name);
            },
    
            setPrefixed: function(el, name, value) {
                if (typeof name === 'object') {
                    for (var key in name)
                        handlePrefix(el, key, true, name[key]);
                } else {
                    handlePrefix(el, name, true, value);
                }
            }
        };
    };
    
    var DomEvent = {
        add: function(el, events) {
            if (el) {
                for (var type in events) {
                    var func = events[type],
                        parts = type.split(/[\s,]+/g);
                    for (var i = 0, l = parts.length; i < l; i++)
                        el.addEventListener(parts[i], func, false);
                }
            }
        },
    
        remove: function(el, events) {
            if (el) {
                for (var type in events) {
                    var func = events[type],
                        parts = type.split(/[\s,]+/g);
                    for (var i = 0, l = parts.length; i < l; i++)
                        el.removeEventListener(parts[i], func, false);
                }
            }
        },
    
        getPoint: function(event) {
            var pos = event.targetTouches
                    ? event.targetTouches.length
                        ? event.targetTouches[0]
                        : event.changedTouches[0]
                    : event;
            return new Point(
                pos.pageX || pos.clientX + document.documentElement.scrollLeft,
                pos.pageY || pos.clientY + document.documentElement.scrollTop
            );
        },
    
        getTarget: function(event) {
            return event.target || event.srcElement;
        },
    
        getRelatedTarget: function(event) {
            return event.relatedTarget || event.toElement;
        },
    
        getOffset: function(event, target) {
            return DomEvent.getPoint(event).subtract(DomElement.getOffset(
                    target || DomEvent.getTarget(event)));
        }
    };
    
    DomEvent.requestAnimationFrame = new function() {
        var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
            requested = false,
            callbacks = [],
            timer;
    
        function handleCallbacks() {
            var functions = callbacks;
            callbacks = [];
            for (var i = 0, l = functions.length; i < l; i++)
                functions[i]();
            requested = nativeRequest && callbacks.length;
            if (requested)
                nativeRequest(handleCallbacks);
        }
    
        return function(callback) {
            callbacks.push(callback);
            if (nativeRequest) {
                if (!requested) {
                    nativeRequest(handleCallbacks);
                    requested = true;
                }
            } else if (!timer) {
                timer = setInterval(handleCallbacks, 1000 / 60);
            }
        };
    };
    
    var View = Base.extend(Emitter, {
        _class: 'View',
    
        initialize: function View(project, element) {
    
            function getSize(name) {
                return element[name] || parseInt(element.getAttribute(name), 10);
            }
    
            function getCanvasSize() {
                var size = DomElement.getSize(element);
                return size.isNaN() || size.isZero()
                        ? new Size(getSize('width'), getSize('height'))
                        : size;
            }
    
            var size;
            if (window && element) {
                this._id = element.getAttribute('id');
                if (this._id == null)
                    element.setAttribute('id', this._id = 'view-' + View._id++);
                DomEvent.add(element, this._viewEvents);
                var none = 'none';
                DomElement.setPrefixed(element.style, {
                    userDrag: none,
                    userSelect: none,
                    touchCallout: none,
                    contentZooming: none,
                    tapHighlightColor: 'rgba(0,0,0,0)'
                });
    
                if (PaperScope.hasAttribute(element, 'resize')) {
                    var that = this;
                    DomEvent.add(window, this._windowEvents = {
                        resize: function() {
                            that.setViewSize(getCanvasSize());
                        }
                    });
                }
    
                size = getCanvasSize();
    
                if (PaperScope.hasAttribute(element, 'stats')
                        && typeof Stats !== 'undefined') {
                    this._stats = new Stats();
                    var stats = this._stats.domElement,
                        style = stats.style,
                        offset = DomElement.getOffset(element);
                    style.position = 'absolute';
                    style.left = offset.x + 'px';
                    style.top = offset.y + 'px';
                    document.body.appendChild(stats);
                }
            } else {
                size = new Size(element);
                element = null;
            }
            this._project = project;
            this._scope = project._scope;
            this._element = element;
            if (!this._pixelRatio)
                this._pixelRatio = window && window.devicePixelRatio || 1;
            this._setElementSize(size.width, size.height);
            this._viewSize = size;
            View._views.push(this);
            View._viewsById[this._id] = this;
            (this._matrix = new Matrix())._owner = this;
            if (!View._focused)
                View._focused = this;
            this._frameItems = {};
            this._frameItemCount = 0;
            this._itemEvents = { native: {}, virtual: {} };
            this._autoUpdate = !paper.agent.node;
            this._needsUpdate = false;
        },
    
        remove: function() {
            if (!this._project)
                return false;
            if (View._focused === this)
                View._focused = null;
            View._views.splice(View._views.indexOf(this), 1);
            delete View._viewsById[this._id];
            var project = this._project;
            if (project._view === this)
                project._view = null;
            DomEvent.remove(this._element, this._viewEvents);
            DomEvent.remove(window, this._windowEvents);
            this._element = this._project = null;
            this.off('frame');
            this._animate = false;
            this._frameItems = {};
            return true;
        },
    
        _events: Base.each(
            Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),
            function(name) {
                this[name] = {};
            }, {
                onFrame: {
                    install: function() {
                        this.play();
                    },
    
                    uninstall: function() {
                        this.pause();
                    }
                }
            }
        ),
    
        _animate: false,
        _time: 0,
        _count: 0,
    
        getAutoUpdate: function() {
            return this._autoUpdate;
        },
    
        setAutoUpdate: function(autoUpdate) {
            this._autoUpdate = autoUpdate;
            if (autoUpdate)
                this.requestUpdate();
        },
    
        update: function() {
        },
    
        draw: function() {
            this.update();
        },
    
        requestUpdate: function() {
            if (!this._requested) {
                var that = this;
                DomEvent.requestAnimationFrame(function() {
                    that._requested = false;
                    if (that._animate) {
                        that.requestUpdate();
                        var element = that._element;
                        if ((!DomElement.getPrefixed(document, 'hidden')
                                || PaperScope.getAttribute(element, 'keepalive')
                                    === 'true') && DomElement.isInView(element)) {
                            that._handleFrame();
                        }
                    }
                    if (that._autoUpdate)
                        that.update();
                });
                this._requested = true;
            }
        },
    
        play: function() {
            this._animate = true;
            this.requestUpdate();
        },
    
        pause: function() {
            this._animate = false;
        },
    
        _handleFrame: function() {
            paper = this._scope;
            var now = Date.now() / 1000,
                delta = this._last ? now - this._last : 0;
            this._last = now;
            this.emit('frame', new Base({
                delta: delta,
                time: this._time += delta,
                count: this._count++
            }));
            if (this._stats)
                this._stats.update();
        },
    
        _animateItem: function(item, animate) {
            var items = this._frameItems;
            if (animate) {
                items[item._id] = {
                    item: item,
                    time: 0,
                    count: 0
                };
                if (++this._frameItemCount === 1)
                    this.on('frame', this._handleFrameItems);
            } else {
                delete items[item._id];
                if (--this._frameItemCount === 0) {
                    this.off('frame', this._handleFrameItems);
                }
            }
        },
    
        _handleFrameItems: function(event) {
            for (var i in this._frameItems) {
                var entry = this._frameItems[i];
                entry.item.emit('frame', new Base(event, {
                    time: entry.time += event.delta,
                    count: entry.count++
                }));
            }
        },
    
        _changed: function() {
            this._project._changed(2049);
            this._bounds = this._decomposed = undefined;
        },
    
        getElement: function() {
            return this._element;
        },
    
        getPixelRatio: function() {
            return this._pixelRatio;
        },
    
        getResolution: function() {
            return this._pixelRatio * 72;
        },
    
        getViewSize: function() {
            var size = this._viewSize;
            return new LinkedSize(size.width, size.height, this, 'setViewSize');
        },
    
        setViewSize: function() {
            var size = Size.read(arguments),
                delta = size.subtract(this._viewSize);
            if (delta.isZero())
                return;
            this._setElementSize(size.width, size.height);
            this._viewSize.set(size);
            this._changed();
            this.emit('resize', { size: size, delta: delta });
            if (this._autoUpdate) {
                this.update();
            }
        },
    
        _setElementSize: function(width, height) {
            var element = this._element;
            if (element) {
                if (element.width !== width)
                    element.width = width;
                if (element.height !== height)
                    element.height = height;
            }
        },
    
        getBounds: function() {
            if (!this._bounds)
                this._bounds = this._matrix.inverted()._transformBounds(
                        new Rectangle(new Point(), this._viewSize));
            return this._bounds;
        },
    
        getSize: function() {
            return this.getBounds().getSize();
        },
    
        isVisible: function() {
            return DomElement.isInView(this._element);
        },
    
        isInserted: function() {
            return DomElement.isInserted(this._element);
        },
    
        getPixelSize: function(size) {
            var element = this._element,
                pixels;
            if (element) {
                var parent = element.parentNode,
                    temp = document.createElement('div');
                temp.style.fontSize = size;
                parent.appendChild(temp);
                pixels = parseFloat(DomElement.getStyles(temp).fontSize);
                parent.removeChild(temp);
            } else {
                pixels = parseFloat(pixels);
            }
            return pixels;
        },
    
        getTextWidth: function(font, lines) {
            return 0;
        }
    }, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
        var rotate = key === 'rotate';
        this[key] = function() {
            var value = (rotate ? Base : Point).read(arguments),
                center = Point.read(arguments, 0, { readNull: true });
            return this.transform(new Matrix()[key](value,
                    center || this.getCenter(true)));
        };
    }, {
        _decompose: function() {
            return this._decomposed || (this._decomposed = this._matrix.decompose());
        },
    
        translate: function() {
            var mx = new Matrix();
            return this.transform(mx.translate.apply(mx, arguments));
        },
    
        getCenter: function() {
            return this.getBounds().getCenter();
        },
    
        setCenter: function() {
            var center = Point.read(arguments);
            this.translate(this.getCenter().subtract(center));
        },
    
        getZoom: function() {
            var decomposed = this._decompose(),
                scaling = decomposed && decomposed.scaling;
            return scaling ? (scaling.x + scaling.y) / 2 : 0;
        },
    
        setZoom: function(zoom) {
            this.transform(new Matrix().scale(zoom / this.getZoom(),
                this.getCenter()));
        },
    
        getRotation: function() {
            var decomposed = this._decompose();
            return decomposed && decomposed.rotation;
        },
    
        setRotation: function(rotation) {
            var current = this.getRotation();
            if (current != null && rotation != null) {
                this.rotate(rotation - current);
            }
        },
    
        getScaling: function() {
            var decomposed = this._decompose(),
                scaling = decomposed && decomposed.scaling;
            return scaling
                    ? new LinkedPoint(scaling.x, scaling.y, this, 'setScaling')
                    : undefined;
        },
    
        setScaling: function() {
            var current = this.getScaling(),
                scaling = Point.read(arguments, 0, { clone: true, readNull: true });
            if (current && scaling) {
                this.scale(scaling.x / current.x, scaling.y / current.y);
            }
        },
    
        getMatrix: function() {
            return this._matrix;
        },
    
        setMatrix: function() {
            var matrix = this._matrix;
            matrix.initialize.apply(matrix, arguments);
        },
    
        transform: function(matrix) {
            this._matrix.append(matrix);
        },
    
        scrollBy: function() {
            this.translate(Point.read(arguments).negate());
        }
    }), {
    
        projectToView: function() {
            return this._matrix._transformPoint(Point.read(arguments));
        },
    
        viewToProject: function() {
            return this._matrix._inverseTransform(Point.read(arguments));
        },
    
        getEventPoint: function(event) {
            return this.viewToProject(DomEvent.getOffset(event, this._element));
        },
    
    }, {
        statics: {
            _views: [],
            _viewsById: {},
            _id: 0,
    
            create: function(project, element) {
                if (document && typeof element === 'string')
                    element = document.getElementById(element);
                var ctor = window ? CanvasView : View;
                return new ctor(project, element);
            }
        }
    },
    new function() {
        if (!window)
            return;
        var prevFocus,
            tempFocus,
            dragging = false,
            mouseDown = false;
    
        function getView(event) {
            var target = DomEvent.getTarget(event);
            return target.getAttribute && View._viewsById[
                    target.getAttribute('id')];
        }
    
        function updateFocus() {
            var view = View._focused;
            if (!view || !view.isVisible()) {
                for (var i = 0, l = View._views.length; i < l; i++) {
                    if ((view = View._views[i]).isVisible()) {
                        View._focused = tempFocus = view;
                        break;
                    }
                }
            }
        }
    
        function handleMouseMove(view, event, point) {
            view._handleMouseEvent('mousemove', event, point);
        }
    
        var navigator = window.navigator,
            mousedown, mousemove, mouseup;
        if (navigator.pointerEnabled || navigator.msPointerEnabled) {
            mousedown = 'pointerdown MSPointerDown';
            mousemove = 'pointermove MSPointerMove';
            mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
        } else {
            mousedown = 'touchstart';
            mousemove = 'touchmove';
            mouseup = 'touchend touchcancel';
            if (!('ontouchstart' in window && navigator.userAgent.match(
                    /mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
                mousedown += ' mousedown';
                mousemove += ' mousemove';
                mouseup += ' mouseup';
            }
        }
    
        var viewEvents = {},
            docEvents = {
                mouseout: function(event) {
                    var view = View._focused,
                        target = DomEvent.getRelatedTarget(event);
                    if (view && (!target || target.nodeName === 'HTML')) {
                        var offset = DomEvent.getOffset(event, view._element),
                            x = offset.x,
                            abs = Math.abs,
                            ax = abs(x),
                            max = 1 << 25,
                            diff = ax - max;
                        offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
                        handleMouseMove(view, event, view.viewToProject(offset));
                    }
                },
    
                scroll: updateFocus
            };
    
        viewEvents[mousedown] = function(event) {
            var view = View._focused = getView(event);
            if (!dragging) {
                dragging = true;
                view._handleMouseEvent('mousedown', event);
            }
        };
    
        docEvents[mousemove] = function(event) {
            var view = View._focused;
            if (!mouseDown) {
                var target = getView(event);
                if (target) {
                    if (view !== target) {
                        if (view)
                            handleMouseMove(view, event);
                        if (!prevFocus)
                            prevFocus = view;
                        view = View._focused = tempFocus = target;
                    }
                } else if (tempFocus && tempFocus === view) {
                    if (prevFocus && !prevFocus.isInserted())
                        prevFocus = null;
                    view = View._focused = prevFocus;
                    prevFocus = null;
                    updateFocus();
                }
            }
            if (view)
                handleMouseMove(view, event);
        };
    
        docEvents[mousedown] = function() {
            mouseDown = true;
        };
    
        docEvents[mouseup] = function(event) {
            var view = View._focused;
            if (view && dragging)
                view._handleMouseEvent('mouseup', event);
            mouseDown = dragging = false;
        };
    
        DomEvent.add(document, docEvents);
    
        DomEvent.add(window, {
            load: updateFocus
        });
    
        var called = false,
            prevented = false,
            fallbacks = {
                doubleclick: 'click',
                mousedrag: 'mousemove'
            },
            wasInView = false,
            overView,
            downPoint,
            lastPoint,
            downItem,
            overItem,
            dragItem,
            clickItem,
            clickTime,
            dblClick;
    
        function emitMouseEvent(obj, target, type, event, point, prevPoint,
                stopItem) {
            var stopped = false,
                mouseEvent;
    
            function emit(obj, type) {
                if (obj.responds(type)) {
                    if (!mouseEvent) {
                        mouseEvent = new MouseEvent(type, event, point,
                                target || obj,
                                prevPoint ? point.subtract(prevPoint) : null);
                    }
                    if (obj.emit(type, mouseEvent)) {
                        called = true;
                        if (mouseEvent.prevented)
                            prevented = true;
                        if (mouseEvent.stopped)
                            return stopped = true;
                    }
                } else {
                    var fallback = fallbacks[type];
                    if (fallback)
                        return emit(obj, fallback);
                }
            }
    
            while (obj && obj !== stopItem) {
                if (emit(obj, type))
                    break;
                obj = obj._parent;
            }
            return stopped;
        }
    
        function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
            view._project.removeOn(type);
            prevented = called = false;
            return (dragItem && emitMouseEvent(dragItem, null, type, event,
                        point, prevPoint)
                || hitItem && hitItem !== dragItem
                    && !hitItem.isDescendant(dragItem)
                    && emitMouseEvent(hitItem, null, type, event, point, prevPoint,
                        dragItem)
                || emitMouseEvent(view, dragItem || hitItem || view, type, event,
                        point, prevPoint));
        }
    
        var itemEventsMap = {
            mousedown: {
                mousedown: 1,
                mousedrag: 1,
                click: 1,
                doubleclick: 1
            },
            mouseup: {
                mouseup: 1,
                mousedrag: 1,
                click: 1,
                doubleclick: 1
            },
            mousemove: {
                mousedrag: 1,
                mousemove: 1,
                mouseenter: 1,
                mouseleave: 1
            }
        };
    
        return {
            _viewEvents: viewEvents,
    
            _handleMouseEvent: function(type, event, point) {
                var itemEvents = this._itemEvents,
                    hitItems = itemEvents.native[type],
                    nativeMove = type === 'mousemove',
                    tool = this._scope.tool,
                    view = this;
    
                function responds(type) {
                    return itemEvents.virtual[type] || view.responds(type)
                            || tool && tool.responds(type);
                }
    
                if (nativeMove && dragging && responds('mousedrag'))
                    type = 'mousedrag';
                if (!point)
                    point = this.getEventPoint(event);
    
                var inView = this.getBounds().contains(point),
                    hit = hitItems && inView && view._project.hitTest(point, {
                        tolerance: 0,
                        fill: true,
                        stroke: true
                    }),
                    hitItem = hit && hit.item || null,
                    handle = false,
                    mouse = {};
                mouse[type.substr(5)] = true;
    
                if (hitItems && hitItem !== overItem) {
                    if (overItem) {
                        emitMouseEvent(overItem, null, 'mouseleave', event, point);
                    }
                    if (hitItem) {
                        emitMouseEvent(hitItem, null, 'mouseenter', event, point);
                    }
                    overItem = hitItem;
                }
                if (wasInView ^ inView) {
                    emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',
                            event, point);
                    overView = inView ? this : null;
                    handle = true;
                }
                if ((inView || mouse.drag) && !point.equals(lastPoint)) {
                    emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',
                            event, point, lastPoint);
                    handle = true;
                }
                wasInView = inView;
                if (mouse.down && inView || mouse.up && downPoint) {
                    emitMouseEvents(this, hitItem, type, event, point, downPoint);
                    if (mouse.down) {
                        dblClick = hitItem === clickItem
                            && (Date.now() - clickTime < 300);
                        downItem = clickItem = hitItem;
                        if (!prevented && hitItem) {
                            var item = hitItem;
                            while (item && !item.responds('mousedrag'))
                                item = item._parent;
                            if (item)
                                dragItem = hitItem;
                        }
                        downPoint = point;
                    } else if (mouse.up) {
                        if (!prevented && hitItem === downItem) {
                            clickTime = Date.now();
                            emitMouseEvents(this, hitItem, dblClick ? 'doubleclick'
                                    : 'click', event, point, downPoint);
                            dblClick = false;
                        }
                        downItem = dragItem = null;
                    }
                    wasInView = false;
                    handle = true;
                }
                lastPoint = point;
                if (handle && tool) {
                    called = tool._handleMouseEvent(type, event, point, mouse)
                        || called;
                }
    
                if (called && !mouse.move || mouse.down && responds('mouseup'))
                    event.preventDefault();
            },
    
            _handleKeyEvent: function(type, event, key, character) {
                var scope = this._scope,
                    tool = scope.tool,
                    keyEvent;
    
                function emit(obj) {
                    if (obj.responds(type)) {
                        paper = scope;
                        obj.emit(type, keyEvent = keyEvent
                                || new KeyEvent(type, event, key, character));
                    }
                }
    
                if (this.isVisible()) {
                    emit(this);
                    if (tool && tool.responds(type))
                        emit(tool);
                }
            },
    
            _countItemEvent: function(type, sign) {
                var itemEvents = this._itemEvents,
                    native = itemEvents.native,
                    virtual = itemEvents.virtual;
                for (var key in itemEventsMap) {
                    native[key] = (native[key] || 0)
                            + (itemEventsMap[key][type] || 0) * sign;
                }
                virtual[type] = (virtual[type] || 0) + sign;
            },
    
            statics: {
                updateFocus: updateFocus
            }
        };
    });
    
    var CanvasView = View.extend({
        _class: 'CanvasView',
    
        initialize: function CanvasView(project, canvas) {
            if (!(canvas instanceof window.HTMLCanvasElement)) {
                var size = Size.read(arguments, 1);
                if (size.isZero())
                    throw new Error(
                            'Cannot create CanvasView with the provided argument: '
                            + Base.slice(arguments, 1));
                canvas = CanvasProvider.getCanvas(size);
            }
            var ctx = this._context = canvas.getContext('2d');
            ctx.save();
            this._pixelRatio = 1;
            if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
                var deviceRatio = window.devicePixelRatio || 1,
                    backingStoreRatio = DomElement.getPrefixed(ctx,
                            'backingStorePixelRatio') || 1;
                this._pixelRatio = deviceRatio / backingStoreRatio;
            }
            View.call(this, project, canvas);
            this._needsUpdate = true;
        },
    
        remove: function remove() {
            this._context.restore();
            return remove.base.call(this);
        },
    
        _setElementSize: function _setElementSize(width, height) {
            var pixelRatio = this._pixelRatio;
            _setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);
            if (pixelRatio !== 1) {
                var element = this._element,
                    ctx = this._context;
                if (!PaperScope.hasAttribute(element, 'resize')) {
                    var style = element.style;
                    style.width = width + 'px';
                    style.height = height + 'px';
                }
                ctx.restore();
                ctx.save();
                ctx.scale(pixelRatio, pixelRatio);
            }
        },
    
        getPixelSize: function getPixelSize(size) {
            var agent = paper.agent,
                pixels;
            if (agent && agent.firefox) {
                pixels = getPixelSize.base.call(this, size);
            } else {
                var ctx = this._context,
                    prevFont = ctx.font;
                ctx.font = size + ' serif';
                pixels = parseFloat(ctx.font);
                ctx.font = prevFont;
            }
            return pixels;
        },
    
        getTextWidth: function(font, lines) {
            var ctx = this._context,
                prevFont = ctx.font,
                width = 0;
            ctx.font = font;
            for (var i = 0, l = lines.length; i < l; i++)
                width = Math.max(width, ctx.measureText(lines[i]).width);
            ctx.font = prevFont;
            return width;
        },
    
        update: function() {
            if (!this._needsUpdate)
                return false;
            var project = this._project,
                ctx = this._context,
                size = this._viewSize;
            ctx.clearRect(0, 0, size.width + 1, size.height + 1);
            if (project)
                project.draw(ctx, this._matrix, this._pixelRatio);
            this._needsUpdate = false;
            return true;
        }
    });
    
    var Event = Base.extend({
        _class: 'Event',
    
        initialize: function Event(event) {
            this.event = event;
            this.type = event && event.type;
        },
    
        prevented: false,
        stopped: false,
    
        preventDefault: function() {
            this.prevented = true;
            this.event.preventDefault();
        },
    
        stopPropagation: function() {
            this.stopped = true;
            this.event.stopPropagation();
        },
    
        stop: function() {
            this.stopPropagation();
            this.preventDefault();
        },
    
        getTimeStamp: function() {
            return this.event.timeStamp;
        },
    
        getModifiers: function() {
            return Key.modifiers;
        }
    });
    
    var KeyEvent = Event.extend({
        _class: 'KeyEvent',
    
        initialize: function KeyEvent(type, event, key, character) {
            this.type = type;
            this.event = event;
            this.key = key;
            this.character = character;
        },
    
        toString: function() {
            return "{ type: '" + this.type
                    + "', key: '" + this.key
                    + "', character: '" + this.character
                    + "', modifiers: " + this.getModifiers()
                    + " }";
        }
    });
    
    var Key = new function() {
        var keyLookup = {
                '\t': 'tab',
                ' ': 'space',
                '\b': 'backspace',
                '\x7f': 'delete',
                'Spacebar': 'space',
                'Del': 'delete',
                'Win': 'meta',
                'Esc': 'escape'
            },
    
            charLookup = {
                'tab': '\t',
                'space': ' ',
                'enter': '\r'
            },
    
            keyMap = {},
            charMap = {},
            metaFixMap,
            downKey,
    
            modifiers = new Base({
                shift: false,
                control: false,
                alt: false,
                meta: false,
                capsLock: false,
                space: false
            }).inject({
                option: {
                    get: function() {
                        return this.alt;
                    }
                },
    
                command: {
                    get: function() {
                        var agent = paper && paper.agent;
                        return agent && agent.mac ? this.meta : this.control;
                    }
                }
            });
    
        function getKey(event) {
            var key = event.key || event.keyIdentifier;
            key = /^U\+/.test(key)
                    ? String.fromCharCode(parseInt(key.substr(2), 16))
                    : /^Arrow[A-Z]/.test(key) ? key.substr(5)
                    : key === 'Unidentified'  || key === undefined
                        ? String.fromCharCode(event.keyCode)
                        : key;
            return keyLookup[key] ||
                    (key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
        }
    
        function handleKey(down, key, character, event) {
            var type = down ? 'keydown' : 'keyup',
                view = View._focused,
                name;
            keyMap[key] = down;
            if (down) {
                charMap[key] = character;
            } else {
                delete charMap[key];
            }
            if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
                modifiers[name] = down;
                var agent = paper && paper.agent;
                if (name === 'meta' && agent && agent.mac) {
                    if (down) {
                        metaFixMap = {};
                    } else {
                        for (var k in metaFixMap) {
                            if (k in charMap)
                                handleKey(false, k, metaFixMap[k], event);
                        }
                        metaFixMap = null;
                    }
                }
            } else if (down && metaFixMap) {
                metaFixMap[key] = character;
            }
            if (view) {
                view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,
                        character);
            }
        }
    
        DomEvent.add(document, {
            keydown: function(event) {
                var key = getKey(event),
                    agent = paper && paper.agent;
                if (key.length > 1 || agent && (agent.chrome && (event.altKey
                            || agent.mac && event.metaKey
                            || !agent.mac && event.ctrlKey))) {
                    handleKey(true, key,
                            charLookup[key] || (key.length > 1 ? '' : key), event);
                } else {
                    downKey = key;
                }
            },
    
            keypress: function(event) {
                if (downKey) {
                    var key = getKey(event),
                        code = event.charCode,
                        character = code >= 32 ? String.fromCharCode(code)
                            : key.length > 1 ? '' : key;
                    if (key !== downKey) {
                        key = character.toLowerCase();
                    }
                    handleKey(true, key, character, event);
                    downKey = null;
                }
            },
    
            keyup: function(event) {
                var key = getKey(event);
                if (key in charMap)
                    handleKey(false, key, charMap[key], event);
            }
        });
    
        DomEvent.add(window, {
            blur: function(event) {
                for (var key in charMap)
                    handleKey(false, key, charMap[key], event);
            }
        });
    
        return {
            modifiers: modifiers,
    
            isDown: function(key) {
                return !!keyMap[key];
            }
        };
    };
    
    var MouseEvent = Event.extend({
        _class: 'MouseEvent',
    
        initialize: function MouseEvent(type, event, point, target, delta) {
            this.type = type;
            this.event = event;
            this.point = point;
            this.target = target;
            this.delta = delta;
        },
    
        toString: function() {
            return "{ type: '" + this.type
                    + "', point: " + this.point
                    + ', target: ' + this.target
                    + (this.delta ? ', delta: ' + this.delta : '')
                    + ', modifiers: ' + this.getModifiers()
                    + ' }';
        }
    });
    
    var ToolEvent = Event.extend({
        _class: 'ToolEvent',
        _item: null,
    
        initialize: function ToolEvent(tool, type, event) {
            this.tool = tool;
            this.type = type;
            this.event = event;
        },
    
        _choosePoint: function(point, toolPoint) {
            return point ? point : toolPoint ? toolPoint.clone() : null;
        },
    
        getPoint: function() {
            return this._choosePoint(this._point, this.tool._point);
        },
    
        setPoint: function(point) {
            this._point = point;
        },
    
        getLastPoint: function() {
            return this._choosePoint(this._lastPoint, this.tool._lastPoint);
        },
    
        setLastPoint: function(lastPoint) {
            this._lastPoint = lastPoint;
        },
    
        getDownPoint: function() {
            return this._choosePoint(this._downPoint, this.tool._downPoint);
        },
    
        setDownPoint: function(downPoint) {
            this._downPoint = downPoint;
        },
    
        getMiddlePoint: function() {
            if (!this._middlePoint && this.tool._lastPoint) {
                return this.tool._point.add(this.tool._lastPoint).divide(2);
            }
            return this._middlePoint;
        },
    
        setMiddlePoint: function(middlePoint) {
            this._middlePoint = middlePoint;
        },
    
        getDelta: function() {
            return !this._delta && this.tool._lastPoint
                    ? this.tool._point.subtract(this.tool._lastPoint)
                    : this._delta;
        },
    
        setDelta: function(delta) {
            this._delta = delta;
        },
    
        getCount: function() {
            return this.tool[/^mouse(down|up)$/.test(this.type)
                    ? '_downCount' : '_moveCount'];
        },
    
        setCount: function(count) {
            this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
                = count;
        },
    
        getItem: function() {
            if (!this._item) {
                var result = this.tool._scope.project.hitTest(this.getPoint());
                if (result) {
                    var item = result.item,
                        parent = item._parent;
                    while (/^(Group|CompoundPath)$/.test(parent._class)) {
                        item = parent;
                        parent = parent._parent;
                    }
                    this._item = item;
                }
            }
            return this._item;
        },
    
        setItem: function(item) {
            this._item = item;
        },
    
        toString: function() {
            return '{ type: ' + this.type
                    + ', point: ' + this.getPoint()
                    + ', count: ' + this.getCount()
                    + ', modifiers: ' + this.getModifiers()
                    + ' }';
        }
    });
    
    var Tool = PaperScopeItem.extend({
        _class: 'Tool',
        _list: 'tools',
        _reference: 'tool',
        _events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
                'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',
                'onKeyUp'],
    
        initialize: function Tool(props) {
            PaperScopeItem.call(this);
            this._moveCount = -1;
            this._downCount = -1;
            this.set(props);
        },
    
        getMinDistance: function() {
            return this._minDistance;
        },
    
        setMinDistance: function(minDistance) {
            this._minDistance = minDistance;
            if (minDistance != null && this._maxDistance != null
                    && minDistance > this._maxDistance) {
                this._maxDistance = minDistance;
            }
        },
    
        getMaxDistance: function() {
            return this._maxDistance;
        },
    
        setMaxDistance: function(maxDistance) {
            this._maxDistance = maxDistance;
            if (this._minDistance != null && maxDistance != null
                    && maxDistance < this._minDistance) {
                this._minDistance = maxDistance;
            }
        },
    
        getFixedDistance: function() {
            return this._minDistance == this._maxDistance
                ? this._minDistance : null;
        },
    
        setFixedDistance: function(distance) {
            this._minDistance = this._maxDistance = distance;
        },
    
        _handleMouseEvent: function(type, event, point, mouse) {
            paper = this._scope;
            if (mouse.drag && !this.responds(type))
                type = 'mousemove';
            var move = mouse.move || mouse.drag,
                responds = this.responds(type),
                minDistance = this.minDistance,
                maxDistance = this.maxDistance,
                called = false,
                tool = this;
            function update(minDistance, maxDistance) {
                var pt = point,
                    toolPoint = move ? tool._point : (tool._downPoint || pt);
                if (move) {
                    if (tool._moveCount && pt.equals(toolPoint)) {
                        return false;
                    }
                    if (toolPoint && (minDistance != null || maxDistance != null)) {
                        var vector = pt.subtract(toolPoint),
                            distance = vector.getLength();
                        if (distance < (minDistance || 0))
                            return false;
                        if (maxDistance) {
                            pt = toolPoint.add(vector.normalize(
                                    Math.min(distance, maxDistance)));
                        }
                    }
                    tool._moveCount++;
                }
                tool._point = pt;
                tool._lastPoint = toolPoint || pt;
                if (mouse.down) {
                    tool._moveCount = -1;
                    tool._downPoint = pt;
                    tool._downCount++;
                }
                return true;
            }
    
            function emit() {
                if (responds) {
                    called = tool.emit(type, new ToolEvent(tool, type, event))
                            || called;
                }
            }
    
            if (mouse.down) {
                update();
                emit();
            } else if (mouse.up) {
                update(null, maxDistance);
                emit();
            } else if (responds) {
                while (update(minDistance, maxDistance))
                    emit();
            }
            return called;
        }
    
    });
    
    var Http = {
        request: function(options) {
            var xhr = new self.XMLHttpRequest();
            xhr.open((options.method || 'get').toUpperCase(), options.url,
                    Base.pick(options.async, true));
            if (options.mimeType)
                xhr.overrideMimeType(options.mimeType);
            xhr.onload = function() {
                var status = xhr.status;
                if (status === 0 || status === 200) {
                    if (options.onLoad) {
                        options.onLoad.call(xhr, xhr.responseText);
                    }
                } else {
                    xhr.onerror();
                }
            };
            xhr.onerror = function() {
                var status = xhr.status,
                    message = 'Could not load "' + options.url + '" (Status: '
                            + status + ')';
                if (options.onError) {
                    options.onError(message, status);
                } else {
                    throw new Error(message);
                }
            };
            return xhr.send(null);
        }
    };
    
    var CanvasProvider = {
        canvases: [],
    
        getCanvas: function(width, height) {
            if (!window)
                return null;
            var canvas,
                clear = true;
            if (typeof width === 'object') {
                height = width.height;
                width = width.width;
            }
            if (this.canvases.length) {
                canvas = this.canvases.pop();
            } else {
                canvas = document.createElement('canvas');
                clear = false;
            }
            var ctx = canvas.getContext('2d');
            if (!ctx) {
                throw new Error('Canvas ' + canvas +
                        ' is unable to provide a 2D context.');
            }
            if (canvas.width === width && canvas.height === height) {
                if (clear)
                    ctx.clearRect(0, 0, width + 1, height + 1);
            } else {
                canvas.width = width;
                canvas.height = height;
            }
            ctx.save();
            return canvas;
        },
    
        getContext: function(width, height) {
            var canvas = this.getCanvas(width, height);
            return canvas ? canvas.getContext('2d') : null;
        },
    
        release: function(obj) {
            var canvas = obj && obj.canvas ? obj.canvas : obj;
            if (canvas && canvas.getContext) {
                canvas.getContext('2d').restore();
                this.canvases.push(canvas);
            }
        }
    };
    
    var BlendMode = new function() {
        var min = Math.min,
            max = Math.max,
            abs = Math.abs,
            sr, sg, sb, sa,
            br, bg, bb, ba,
            dr, dg, db;
    
        function getLum(r, g, b) {
            return 0.2989 * r + 0.587 * g + 0.114 * b;
        }
    
        function setLum(r, g, b, l) {
            var d = l - getLum(r, g, b);
            dr = r + d;
            dg = g + d;
            db = b + d;
            var l = getLum(dr, dg, db),
                mn = min(dr, dg, db),
                mx = max(dr, dg, db);
            if (mn < 0) {
                var lmn = l - mn;
                dr = l + (dr - l) * l / lmn;
                dg = l + (dg - l) * l / lmn;
                db = l + (db - l) * l / lmn;
            }
            if (mx > 255) {
                var ln = 255 - l,
                    mxl = mx - l;
                dr = l + (dr - l) * ln / mxl;
                dg = l + (dg - l) * ln / mxl;
                db = l + (db - l) * ln / mxl;
            }
        }
    
        function getSat(r, g, b) {
            return max(r, g, b) - min(r, g, b);
        }
    
        function setSat(r, g, b, s) {
            var col = [r, g, b],
                mx = max(r, g, b),
                mn = min(r, g, b),
                md;
            mn = mn === r ? 0 : mn === g ? 1 : 2;
            mx = mx === r ? 0 : mx === g ? 1 : 2;
            md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
            if (col[mx] > col[mn]) {
                col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
                col[mx] = s;
            } else {
                col[md] = col[mx] = 0;
            }
            col[mn] = 0;
            dr = col[0];
            dg = col[1];
            db = col[2];
        }
    
        var modes = {
            multiply: function() {
                dr = br * sr / 255;
                dg = bg * sg / 255;
                db = bb * sb / 255;
            },
    
            screen: function() {
                dr = br + sr - (br * sr / 255);
                dg = bg + sg - (bg * sg / 255);
                db = bb + sb - (bb * sb / 255);
            },
    
            overlay: function() {
                dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
                dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
                db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
            },
    
            'soft-light': function() {
                var t = sr * br / 255;
                dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
                t = sg * bg / 255;
                dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
                t = sb * bb / 255;
                db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
            },
    
            'hard-light': function() {
                dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
                dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
                db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
            },
    
            'color-dodge': function() {
                dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
                dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
                db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
            },
    
            'color-burn': function() {
                dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
                dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
                db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
            },
    
            darken: function() {
                dr = br < sr ? br : sr;
                dg = bg < sg ? bg : sg;
                db = bb < sb ? bb : sb;
            },
    
            lighten: function() {
                dr = br > sr ? br : sr;
                dg = bg > sg ? bg : sg;
                db = bb > sb ? bb : sb;
            },
    
            difference: function() {
                dr = br - sr;
                if (dr < 0)
                    dr = -dr;
                dg = bg - sg;
                if (dg < 0)
                    dg = -dg;
                db = bb - sb;
                if (db < 0)
                    db = -db;
            },
    
            exclusion: function() {
                dr = br + sr * (255 - br - br) / 255;
                dg = bg + sg * (255 - bg - bg) / 255;
                db = bb + sb * (255 - bb - bb) / 255;
            },
    
            hue: function() {
                setSat(sr, sg, sb, getSat(br, bg, bb));
                setLum(dr, dg, db, getLum(br, bg, bb));
            },
    
            saturation: function() {
                setSat(br, bg, bb, getSat(sr, sg, sb));
                setLum(dr, dg, db, getLum(br, bg, bb));
            },
    
            luminosity: function() {
                setLum(br, bg, bb, getLum(sr, sg, sb));
            },
    
            color: function() {
                setLum(sr, sg, sb, getLum(br, bg, bb));
            },
    
            add: function() {
                dr = min(br + sr, 255);
                dg = min(bg + sg, 255);
                db = min(bb + sb, 255);
            },
    
            subtract: function() {
                dr = max(br - sr, 0);
                dg = max(bg - sg, 0);
                db = max(bb - sb, 0);
            },
    
            average: function() {
                dr = (br + sr) / 2;
                dg = (bg + sg) / 2;
                db = (bb + sb) / 2;
            },
    
            negation: function() {
                dr = 255 - abs(255 - sr - br);
                dg = 255 - abs(255 - sg - bg);
                db = 255 - abs(255 - sb - bb);
            }
        };
    
        var nativeModes = this.nativeModes = Base.each([
            'source-over', 'source-in', 'source-out', 'source-atop',
            'destination-over', 'destination-in', 'destination-out',
            'destination-atop', 'lighter', 'darker', 'copy', 'xor'
        ], function(mode) {
            this[mode] = true;
        }, {});
    
        var ctx = CanvasProvider.getContext(1, 1);
        if (ctx) {
            Base.each(modes, function(func, mode) {
                var darken = mode === 'darken',
                    ok = false;
                ctx.save();
                try {
                    ctx.fillStyle = darken ? '#300' : '#a00';
                    ctx.fillRect(0, 0, 1, 1);
                    ctx.globalCompositeOperation = mode;
                    if (ctx.globalCompositeOperation === mode) {
                        ctx.fillStyle = darken ? '#a00' : '#300';
                        ctx.fillRect(0, 0, 1, 1);
                        ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken
                                ? 170 : 51;
                    }
                } catch (e) {}
                ctx.restore();
                nativeModes[mode] = ok;
            });
            CanvasProvider.release(ctx);
        }
    
        this.process = function(mode, srcContext, dstContext, alpha, offset) {
            var srcCanvas = srcContext.canvas,
                normal = mode === 'normal';
            if (normal || nativeModes[mode]) {
                dstContext.save();
                dstContext.setTransform(1, 0, 0, 1, 0, 0);
                dstContext.globalAlpha = alpha;
                if (!normal)
                    dstContext.globalCompositeOperation = mode;
                dstContext.drawImage(srcCanvas, offset.x, offset.y);
                dstContext.restore();
            } else {
                var process = modes[mode];
                if (!process)
                    return;
                var dstData = dstContext.getImageData(offset.x, offset.y,
                        srcCanvas.width, srcCanvas.height),
                    dst = dstData.data,
                    src = srcContext.getImageData(0, 0,
                        srcCanvas.width, srcCanvas.height).data;
                for (var i = 0, l = dst.length; i < l; i += 4) {
                    sr = src[i];
                    br = dst[i];
                    sg = src[i + 1];
                    bg = dst[i + 1];
                    sb = src[i + 2];
                    bb = dst[i + 2];
                    sa = src[i + 3];
                    ba = dst[i + 3];
                    process();
                    var a1 = sa * alpha / 255,
                        a2 = 1 - a1;
                    dst[i] = a1 * dr + a2 * br;
                    dst[i + 1] = a1 * dg + a2 * bg;
                    dst[i + 2] = a1 * db + a2 * bb;
                    dst[i + 3] = sa * alpha + a2 * ba;
                }
                dstContext.putImageData(dstData, offset.x, offset.y);
            }
        };
    };
    
    var SvgElement = new function() {
        var svg = 'http://www.w3.org/2000/svg',
            xmlns = 'http://www.w3.org/2000/xmlns',
            xlink = 'http://www.w3.org/1999/xlink',
            attributeNamespace = {
                href: xlink,
                xlink: xmlns,
                xmlns: xmlns + '/',
                'xmlns:xlink': xmlns + '/'
            };
    
        function create(tag, attributes, formatter) {
            return set(document.createElementNS(svg, tag), attributes, formatter);
        }
    
        function get(node, name) {
            var namespace = attributeNamespace[name],
                value = namespace
                    ? node.getAttributeNS(namespace, name)
                    : node.getAttribute(name);
            return value === 'null' ? null : value;
        }
    
        function set(node, attributes, formatter) {
            for (var name in attributes) {
                var value = attributes[name],
                    namespace = attributeNamespace[name];
                if (typeof value === 'number' && formatter)
                    value = formatter.number(value);
                if (namespace) {
                    node.setAttributeNS(namespace, name, value);
                } else {
                    node.setAttribute(name, value);
                }
            }
            return node;
        }
    
        return {
            svg: svg,
            xmlns: xmlns,
            xlink: xlink,
    
            create: create,
            get: get,
            set: set
        };
    };
    
    var SvgStyles = Base.each({
        fillColor: ['fill', 'color'],
        fillRule: ['fill-rule', 'string'],
        strokeColor: ['stroke', 'color'],
        strokeWidth: ['stroke-width', 'number'],
        strokeCap: ['stroke-linecap', 'string'],
        strokeJoin: ['stroke-linejoin', 'string'],
        strokeScaling: ['vector-effect', 'lookup', {
            true: 'none',
            false: 'non-scaling-stroke'
        }, function(item, value) {
            return !value
                    && (item instanceof PathItem
                        || item instanceof Shape
                        || item instanceof TextItem);
        }],
        miterLimit: ['stroke-miterlimit', 'number'],
        dashArray: ['stroke-dasharray', 'array'],
        dashOffset: ['stroke-dashoffset', 'number'],
        fontFamily: ['font-family', 'string'],
        fontWeight: ['font-weight', 'string'],
        fontSize: ['font-size', 'number'],
        justification: ['text-anchor', 'lookup', {
            left: 'start',
            center: 'middle',
            right: 'end'
        }],
        opacity: ['opacity', 'number'],
        blendMode: ['mix-blend-mode', 'style']
    }, function(entry, key) {
        var part = Base.capitalize(key),
            lookup = entry[2];
        this[key] = {
            type: entry[1],
            property: key,
            attribute: entry[0],
            toSVG: lookup,
            fromSVG: lookup && Base.each(lookup, function(value, name) {
                this[value] = name;
            }, {}),
            exportFilter: entry[3],
            get: 'get' + part,
            set: 'set' + part
        };
    }, {});
    
    new function() {
        var formatter;
    
        function getTransform(matrix, coordinates, center) {
            var attrs = new Base(),
                trans = matrix.getTranslation();
            if (coordinates) {
                matrix = matrix._shiftless();
                var point = matrix._inverseTransform(trans);
                attrs[center ? 'cx' : 'x'] = point.x;
                attrs[center ? 'cy' : 'y'] = point.y;
                trans = null;
            }
            if (!matrix.isIdentity()) {
                var decomposed = matrix.decompose();
                if (decomposed) {
                    var parts = [],
                        angle = decomposed.rotation,
                        scale = decomposed.scaling,
                        skew = decomposed.skewing;
                    if (trans && !trans.isZero())
                        parts.push('translate(' + formatter.point(trans) + ')');
                    if (angle)
                        parts.push('rotate(' + formatter.number(angle) + ')');
                    if (!Numerical.isZero(scale.x - 1)
                            || !Numerical.isZero(scale.y - 1))
                        parts.push('scale(' + formatter.point(scale) +')');
                    if (skew.x)
                        parts.push('skewX(' + formatter.number(skew.x) + ')');
                    if (skew.y)
                        parts.push('skewY(' + formatter.number(skew.y) + ')');
                    attrs.transform = parts.join(' ');
                } else {
                    attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
                }
            }
            return attrs;
        }
    
        function exportGroup(item, options) {
            var attrs = getTransform(item._matrix),
                children = item._children;
            var node = SvgElement.create('g', attrs, formatter);
            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                var childNode = exportSVG(child, options);
                if (childNode) {
                    if (child.isClipMask()) {
                        var clip = SvgElement.create('clipPath');
                        clip.appendChild(childNode);
                        setDefinition(child, clip, 'clip');
                        SvgElement.set(node, {
                            'clip-path': 'url(#' + clip.id + ')'
                        });
                    } else {
                        node.appendChild(childNode);
                    }
                }
            }
            return node;
        }
    
        function exportRaster(item, options) {
            var attrs = getTransform(item._matrix, true),
                size = item.getSize(),
                image = item.getImage();
            attrs.x -= size.width / 2;
            attrs.y -= size.height / 2;
            attrs.width = size.width;
            attrs.height = size.height;
            attrs.href = options.embedImages == false && image && image.src
                    || item.toDataURL();
            return SvgElement.create('image', attrs, formatter);
        }
    
        function exportPath(item, options) {
            var matchShapes = options.matchShapes;
            if (matchShapes) {
                var shape = item.toShape(false);
                if (shape)
                    return exportShape(shape, options);
            }
            var segments = item._segments,
                length = segments.length,
                type,
                attrs = getTransform(item._matrix);
            if (matchShapes && length >= 2 && !item.hasHandles()) {
                if (length > 2) {
                    type = item._closed ? 'polygon' : 'polyline';
                    var parts = [];
                    for (var i = 0; i < length; i++) {
                        parts.push(formatter.point(segments[i]._point));
                    }
                    attrs.points = parts.join(' ');
                } else {
                    type = 'line';
                    var start = segments[0]._point,
                        end = segments[1]._point;
                    attrs.set({
                        x1: start.x,
                        y1: start.y,
                        x2: end.x,
                        y2: end.y
                    });
                }
            } else {
                type = 'path';
                attrs.d = item.getPathData(null, options.precision);
            }
            return SvgElement.create(type, attrs, formatter);
        }
    
        function exportShape(item) {
            var type = item._type,
                radius = item._radius,
                attrs = getTransform(item._matrix, true, type !== 'rectangle');
            if (type === 'rectangle') {
                type = 'rect';
                var size = item._size,
                    width = size.width,
                    height = size.height;
                attrs.x -= width / 2;
                attrs.y -= height / 2;
                attrs.width = width;
                attrs.height = height;
                if (radius.isZero())
                    radius = null;
            }
            if (radius) {
                if (type === 'circle') {
                    attrs.r = radius;
                } else {
                    attrs.rx = radius.width;
                    attrs.ry = radius.height;
                }
            }
            return SvgElement.create(type, attrs, formatter);
        }
    
        function exportCompoundPath(item, options) {
            var attrs = getTransform(item._matrix);
            var data = item.getPathData(null, options.precision);
            if (data)
                attrs.d = data;
            return SvgElement.create('path', attrs, formatter);
        }
    
        function exportSymbolItem(item, options) {
            var attrs = getTransform(item._matrix, true),
                definition = item._definition,
                node = getDefinition(definition, 'symbol'),
                definitionItem = definition._item,
                bounds = definitionItem.getBounds();
            if (!node) {
                node = SvgElement.create('symbol', {
                    viewBox: formatter.rectangle(bounds)
                });
                node.appendChild(exportSVG(definitionItem, options));
                setDefinition(definition, node, 'symbol');
            }
            attrs.href = '#' + node.id;
            attrs.x += bounds.x;
            attrs.y += bounds.y;
            attrs.width = bounds.width;
            attrs.height = bounds.height;
            attrs.overflow = 'visible';
            return SvgElement.create('use', attrs, formatter);
        }
    
        function exportGradient(color) {
            var gradientNode = getDefinition(color, 'color');
            if (!gradientNode) {
                var gradient = color.getGradient(),
                    radial = gradient._radial,
                    origin = color.getOrigin(),
                    destination = color.getDestination(),
                    attrs;
                if (radial) {
                    attrs = {
                        cx: origin.x,
                        cy: origin.y,
                        r: origin.getDistance(destination)
                    };
                    var highlight = color.getHighlight();
                    if (highlight) {
                        attrs.fx = highlight.x;
                        attrs.fy = highlight.y;
                    }
                } else {
                    attrs = {
                        x1: origin.x,
                        y1: origin.y,
                        x2: destination.x,
                        y2: destination.y
                    };
                }
                attrs.gradientUnits = 'userSpaceOnUse';
                gradientNode = SvgElement.create((radial ? 'radial' : 'linear')
                        + 'Gradient', attrs, formatter);
                var stops = gradient._stops;
                for (var i = 0, l = stops.length; i < l; i++) {
                    var stop = stops[i],
                        stopColor = stop._color,
                        alpha = stopColor.getAlpha(),
                        offset = stop._offset;
                    attrs = {
                        offset: offset == null ? i / (l - 1) : offset
                    };
                    if (stopColor)
                        attrs['stop-color'] = stopColor.toCSS(true);
                    if (alpha < 1)
                        attrs['stop-opacity'] = alpha;
                    gradientNode.appendChild(
                            SvgElement.create('stop', attrs, formatter));
                }
                setDefinition(color, gradientNode, 'color');
            }
            return 'url(#' + gradientNode.id + ')';
        }
    
        function exportText(item) {
            var node = SvgElement.create('text', getTransform(item._matrix, true),
                    formatter);
            node.textContent = item._content;
            return node;
        }
    
        var exporters = {
            Group: exportGroup,
            Layer: exportGroup,
            Raster: exportRaster,
            Path: exportPath,
            Shape: exportShape,
            CompoundPath: exportCompoundPath,
            SymbolItem: exportSymbolItem,
            PointText: exportText
        };
    
        function applyStyle(item, node, isRoot) {
            var attrs = {},
                parent = !isRoot && item.getParent(),
                style = [];
    
            if (item._name != null)
                attrs.id = item._name;
    
            Base.each(SvgStyles, function(entry) {
                var get = entry.get,
                    type = entry.type,
                    value = item[get]();
                if (entry.exportFilter
                        ? entry.exportFilter(item, value)
                        : !parent || !Base.equals(parent[get](), value)) {
                    if (type === 'color' && value != null) {
                        var alpha = value.getAlpha();
                        if (alpha < 1)
                            attrs[entry.attribute + '-opacity'] = alpha;
                    }
                    if (type === 'style') {
                        style.push(entry.attribute + ': ' + value);
                    } else {
                        attrs[entry.attribute] = value == null ? 'none'
                                : type === 'color' ? value.gradient
                                    ? exportGradient(value, item)
                                    : value.toCSS(true)
                                : type === 'array' ? value.join(',')
                                : type === 'lookup' ? entry.toSVG[value]
                                : value;
                    }
                }
            });
    
            if (style.length)
                attrs.style = style.join(';');
    
            if (attrs.opacity === 1)
                delete attrs.opacity;
    
            if (!item._visible)
                attrs.visibility = 'hidden';
    
            return SvgElement.set(node, attrs, formatter);
        }
    
        var definitions;
        function getDefinition(item, type) {
            if (!definitions)
                definitions = { ids: {}, svgs: {} };
            return item && definitions.svgs[type + '-'
                    + (item._id || item.__id || (item.__id = UID.get('svg')))];
        }
    
        function setDefinition(item, node, type) {
            if (!definitions)
                getDefinition();
            var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
            node.id = type + '-' + typeId;
            definitions.svgs[type + '-' + (item._id || item.__id)] = node;
        }
    
        function exportDefinitions(node, options) {
            var svg = node,
                defs = null;
            if (definitions) {
                svg = node.nodeName.toLowerCase() === 'svg' && node;
                for (var i in definitions.svgs) {
                    if (!defs) {
                        if (!svg) {
                            svg = SvgElement.create('svg');
                            svg.appendChild(node);
                        }
                        defs = svg.insertBefore(SvgElement.create('defs'),
                                svg.firstChild);
                    }
                    defs.appendChild(definitions.svgs[i]);
                }
                definitions = null;
            }
            return options.asString
                    ? new self.XMLSerializer().serializeToString(svg)
                    : svg;
        }
    
        function exportSVG(item, options, isRoot) {
            var exporter = exporters[item._class],
                node = exporter && exporter(item, options);
            if (node) {
                var onExport = options.onExport;
                if (onExport)
                    node = onExport(item, node, options) || node;
                var data = JSON.stringify(item._data);
                if (data && data !== '{}' && data !== 'null')
                    node.setAttribute('data-paper-data', data);
            }
            return node && applyStyle(item, node, isRoot);
        }
    
        function setOptions(options) {
            if (!options)
                options = {};
            formatter = new Formatter(options.precision);
            return options;
        }
    
        Item.inject({
            exportSVG: function(options) {
                options = setOptions(options);
                return exportDefinitions(exportSVG(this, options, true), options);
            }
        });
    
        Project.inject({
            exportSVG: function(options) {
                options = setOptions(options);
                var children = this._children,
                    view = this.getView(),
                    bounds = Base.pick(options.bounds, 'view'),
                    mx = options.matrix || bounds === 'view' && view._matrix,
                    matrix = mx && Matrix.read([mx]),
                    rect = bounds === 'view'
                        ? new Rectangle([0, 0], view.getViewSize())
                        : bounds === 'content'
                            ? Item._getBounds(children, matrix, { stroke: true })
                                .rect
                            : Rectangle.read([bounds], 0, { readNull: true }),
                    attrs = {
                        version: '1.1',
                        xmlns: SvgElement.svg,
                        'xmlns:xlink': SvgElement.xlink,
                    };
                if (rect) {
                    attrs.width = rect.width;
                    attrs.height = rect.height;
                    if (rect.x || rect.y)
                        attrs.viewBox = formatter.rectangle(rect);
                }
                var node = SvgElement.create('svg', attrs, formatter),
                    parent = node;
                if (matrix && !matrix.isIdentity()) {
                    parent = node.appendChild(SvgElement.create('g',
                            getTransform(matrix), formatter));
                }
                for (var i = 0, l = children.length; i < l; i++) {
                    parent.appendChild(exportSVG(children[i], options, true));
                }
                return exportDefinitions(node, options);
            }
        });
    };
    
    new function() {
    
        var definitions = {},
            rootSize;
    
        function getValue(node, name, isString, allowNull, allowPercent) {
            var value = SvgElement.get(node, name),
                res = value == null
                    ? allowNull
                        ? null
                        : isString ? '' : 0
                    : isString
                        ? value
                        : parseFloat(value);
            return /%\s*$/.test(value)
                ? (res / 100) * (allowPercent ? 1
                    : rootSize[/x|^width/.test(name) ? 'width' : 'height'])
                : res;
        }
    
        function getPoint(node, x, y, allowNull, allowPercent) {
            x = getValue(node, x || 'x', false, allowNull, allowPercent);
            y = getValue(node, y || 'y', false, allowNull, allowPercent);
            return allowNull && (x == null || y == null) ? null
                    : new Point(x, y);
        }
    
        function getSize(node, w, h, allowNull, allowPercent) {
            w = getValue(node, w || 'width', false, allowNull, allowPercent);
            h = getValue(node, h || 'height', false, allowNull, allowPercent);
            return allowNull && (w == null || h == null) ? null
                    : new Size(w, h);
        }
    
        function convertValue(value, type, lookup) {
            return value === 'none' ? null
                    : type === 'number' ? parseFloat(value)
                    : type === 'array' ?
                        value ? value.split(/[\s,]+/g).map(parseFloat) : []
                    : type === 'color' ? getDefinition(value) || value
                    : type === 'lookup' ? lookup[value]
                    : value;
        }
    
        function importGroup(node, type, options, isRoot) {
            var nodes = node.childNodes,
                isClip = type === 'clippath',
                isDefs = type === 'defs',
                item = new Group(),
                project = item._project,
                currentStyle = project._currentStyle,
                children = [];
            if (!isClip && !isDefs) {
                item = applyAttributes(item, node, isRoot);
                project._currentStyle = item._style.clone();
            }
            if (isRoot) {
                var defs = node.querySelectorAll('defs');
                for (var i = 0, l = defs.length; i < l; i++) {
                    importNode(defs[i], options, false);
                }
            }
            for (var i = 0, l = nodes.length; i < l; i++) {
                var childNode = nodes[i],
                    child;
                if (childNode.nodeType === 1
                        && !/^defs$/i.test(childNode.nodeName)
                        && (child = importNode(childNode, options, false))
                        && !(child instanceof SymbolDefinition))
                    children.push(child);
            }
            item.addChildren(children);
            if (isClip)
                item = applyAttributes(item.reduce(), node, isRoot);
            project._currentStyle = currentStyle;
            if (isClip || isDefs) {
                item.remove();
                item = null;
            }
            return item;
        }
    
        function importPoly(node, type) {
            var coords = node.getAttribute('points').match(
                        /[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
                points = [];
            for (var i = 0, l = coords.length; i < l; i += 2)
                points.push(new Point(
                        parseFloat(coords[i]),
                        parseFloat(coords[i + 1])));
            var path = new Path(points);
            if (type === 'polygon')
                path.closePath();
            return path;
        }
    
        function importPath(node) {
            return PathItem.create(node.getAttribute('d'));
        }
    
        function importGradient(node, type) {
            var id = (getValue(node, 'href', true) || '').substring(1),
                radial = type === 'radialgradient',
                gradient;
            if (id) {
                gradient = definitions[id].getGradient();
                if (gradient._radial ^ radial) {
                    gradient = gradient.clone();
                    gradient._radial = radial;
                }
            } else {
                var nodes = node.childNodes,
                    stops = [];
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var child = nodes[i];
                    if (child.nodeType === 1)
                        stops.push(applyAttributes(new GradientStop(), child));
                }
                gradient = new Gradient(stops, radial);
            }
            var origin, destination, highlight,
                scaleToBounds = getValue(node, 'gradientUnits', true) !==
                    'userSpaceOnUse';
            if (radial) {
                origin = getPoint(node, 'cx', 'cy', false, scaleToBounds);
                destination = origin.add(
                        getValue(node, 'r', false, false, scaleToBounds), 0);
                highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
            } else {
                origin = getPoint(node, 'x1', 'y1', false, scaleToBounds);
                destination = getPoint(node, 'x2', 'y2', false, scaleToBounds);
            }
            var color = applyAttributes(
                    new Color(gradient, origin, destination, highlight), node);
            color._scaleToBounds = scaleToBounds;
            return null;
        }
    
        var importers = {
            '#document': function (node, type, options, isRoot) {
                var nodes = node.childNodes;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    var child = nodes[i];
                    if (child.nodeType === 1)
                        return importNode(child, options, isRoot);
                }
            },
            g: importGroup,
            svg: importGroup,
            clippath: importGroup,
            polygon: importPoly,
            polyline: importPoly,
            path: importPath,
            lineargradient: importGradient,
            radialgradient: importGradient,
    
            image: function (node) {
                var raster = new Raster(getValue(node, 'href', true));
                raster.on('load', function() {
                    var size = getSize(node);
                    this.setSize(size);
                    var center = this._matrix._transformPoint(
                            getPoint(node).add(size.divide(2)));
                    this.translate(center);
                });
                return raster;
            },
    
            symbol: function(node, type, options, isRoot) {
                return new SymbolDefinition(
                        importGroup(node, type, options, isRoot), true);
            },
    
            defs: importGroup,
    
            use: function(node) {
                var id = (getValue(node, 'href', true) || '').substring(1),
                    definition = definitions[id],
                    point = getPoint(node);
                return definition
                        ? definition instanceof SymbolDefinition
                            ? definition.place(point)
                            : definition.clone().translate(point)
                        : null;
            },
    
            circle: function(node) {
                return new Shape.Circle(
                        getPoint(node, 'cx', 'cy'),
                        getValue(node, 'r'));
            },
    
            ellipse: function(node) {
                return new Shape.Ellipse({
                    center: getPoint(node, 'cx', 'cy'),
                    radius: getSize(node, 'rx', 'ry')
                });
            },
    
            rect: function(node) {
                return new Shape.Rectangle(new Rectangle(
                            getPoint(node),
                            getSize(node)
                        ), getSize(node, 'rx', 'ry'));
                },
    
            line: function(node) {
                return new Path.Line(
                        getPoint(node, 'x1', 'y1'),
                        getPoint(node, 'x2', 'y2'));
            },
    
            text: function(node) {
                var text = new PointText(getPoint(node).add(
                        getPoint(node, 'dx', 'dy')));
                text.setContent(node.textContent.trim() || '');
                return text;
            }
        };
    
        function applyTransform(item, value, name, node) {
            if (item.transform) {
                var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
                    matrix = new Matrix();
                for (var i = 0, l = transforms.length; i < l; i++) {
                    var transform = transforms[i];
                    if (!transform)
                        break;
                    var parts = transform.split(/\(\s*/),
                        command = parts[0],
                        v = parts[1].split(/[\s,]+/g);
                    for (var j = 0, m = v.length; j < m; j++)
                        v[j] = parseFloat(v[j]);
                    switch (command) {
                    case 'matrix':
                        matrix.append(
                                new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
                        break;
                    case 'rotate':
                        matrix.rotate(v[0], v[1], v[2]);
                        break;
                    case 'translate':
                        matrix.translate(v[0], v[1]);
                        break;
                    case 'scale':
                        matrix.scale(v);
                        break;
                    case 'skewX':
                        matrix.skew(v[0], 0);
                        break;
                    case 'skewY':
                        matrix.skew(0, v[0]);
                        break;
                    }
                }
                item.transform(matrix);
            }
        }
    
        function applyOpacity(item, value, name) {
            var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
                color = item[key] && item[key]();
            if (color)
                color.setAlpha(parseFloat(value));
        }
    
        var attributes = Base.set(Base.each(SvgStyles, function(entry) {
            this[entry.attribute] = function(item, value) {
                if (item[entry.set]) {
                    item[entry.set](convertValue(value, entry.type, entry.fromSVG));
                    if (entry.type === 'color') {
                        var color = item[entry.get]();
                        if (color) {
                            if (color._scaleToBounds) {
                                var bounds = item.getBounds();
                                color.transform(new Matrix()
                                    .translate(bounds.getPoint())
                                    .scale(bounds.getSize()));
                            }
                        }
                    }
                }
            };
        }, {}), {
            id: function(item, value) {
                definitions[value] = item;
                if (item.setName)
                    item.setName(value);
            },
    
            'clip-path': function(item, value) {
                var clip = getDefinition(value);
                if (clip) {
                    clip = clip.clone();
                    clip.setClipMask(true);
                    if (item instanceof Group) {
                        item.insertChild(0, clip);
                    } else {
                        return new Group(clip, item);
                    }
                }
            },
    
            gradientTransform: applyTransform,
            transform: applyTransform,
    
            'fill-opacity': applyOpacity,
            'stroke-opacity': applyOpacity,
    
            visibility: function(item, value) {
                if (item.setVisible)
                    item.setVisible(value === 'visible');
            },
    
            display: function(item, value) {
                if (item.setVisible)
                    item.setVisible(value !== null);
            },
    
            'stop-color': function(item, value) {
                if (item.setColor)
                    item.setColor(value);
            },
    
            'stop-opacity': function(item, value) {
                if (item._color)
                    item._color.setAlpha(parseFloat(value));
            },
    
            offset: function(item, value) {
                if (item.setOffset) {
                    var percent = value.match(/(.*)%$/);
                    item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
                }
            },
    
            viewBox: function(item, value, name, node, styles) {
                var rect = new Rectangle(convertValue(value, 'array')),
                    size = getSize(node, null, null, true),
                    group,
                    matrix;
                if (item instanceof Group) {
                    var scale = size ? size.divide(rect.getSize()) : 1,
                    matrix = new Matrix().scale(scale)
                            .translate(rect.getPoint().negate());
                    group = item;
                } else if (item instanceof SymbolDefinition) {
                    if (size)
                        rect.setSize(size);
                    group = item._item;
                }
                if (group)  {
                    if (getAttribute(node, 'overflow', styles) !== 'visible') {
                        var clip = new Shape.Rectangle(rect);
                        clip.setClipMask(true);
                        group.addChild(clip);
                    }
                    if (matrix)
                        group.transform(matrix);
                }
            }
        });
    
        function getAttribute(node, name, styles) {
            var attr = node.attributes[name],
                value = attr && attr.value;
            if (!value) {
                var style = Base.camelize(name);
                value = node.style[style];
                if (!value && styles.node[style] !== styles.parent[style])
                    value = styles.node[style];
            }
            return !value ? undefined
                    : value === 'none' ? null
                    : value;
        }
    
        function applyAttributes(item, node, isRoot) {
            if (node.style) {
                var parent = node.parentNode,
                    styles = {
                        node: DomElement.getStyles(node) || {},
                        parent: !isRoot && !/^defs$/i.test(parent.tagName)
                                && DomElement.getStyles(parent) || {}
                    };
                Base.each(attributes, function(apply, name) {
                    var value = getAttribute(node, name, styles);
                    item = value !== undefined
                            && apply(item, value, name, node, styles) || item;
                });
            }
            return item;
        }
    
        function getDefinition(value) {
            var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
                name = match && match[1],
                res = name && definitions[window
                        ? name.replace(window.location.href.split('#')[0] + '#', '')
                        : name];
            if (res && res._scaleToBounds) {
                res = res.clone();
                res._scaleToBounds = true;
            }
            return res;
        }
    
        function importNode(node, options, isRoot) {
            var type = node.nodeName.toLowerCase(),
                isElement = type !== '#document',
                body = document.body,
                container,
                parent,
                next;
            if (isRoot && isElement) {
                rootSize = paper.getView().getSize();
                rootSize = getSize(node, null, null, true) || rootSize;
                container = SvgElement.create('svg', {
                    style: 'stroke-width: 1px; stroke-miterlimit: 10'
                });
                parent = node.parentNode;
                next = node.nextSibling;
                container.appendChild(node);
                body.appendChild(container);
            }
            var settings = paper.settings,
                applyMatrix = settings.applyMatrix,
                insertItems = settings.insertItems;
            settings.applyMatrix = false;
            settings.insertItems = false;
            var importer = importers[type],
                item = importer && importer(node, type, options, isRoot) || null;
            settings.insertItems = insertItems;
            settings.applyMatrix = applyMatrix;
            if (item) {
                if (isElement && !(item instanceof Group))
                    item = applyAttributes(item, node, isRoot);
                var onImport = options.onImport,
                    data = isElement && node.getAttribute('data-paper-data');
                if (onImport)
                    item = onImport(node, item, options) || item;
                if (options.expandShapes && item instanceof Shape) {
                    item.remove();
                    item = item.toPath();
                }
                if (data)
                    item._data = JSON.parse(data);
            }
            if (container) {
                body.removeChild(container);
                if (parent) {
                    if (next) {
                        parent.insertBefore(node, next);
                    } else {
                        parent.appendChild(node);
                    }
                }
            }
            if (isRoot) {
                definitions = {};
                if (item && Base.pick(options.applyMatrix, applyMatrix))
                    item.matrix.apply(true, true);
            }
            return item;
        }
    
        function importSVG(source, options, owner) {
            if (!source)
                return null;
            options = typeof options === 'function' ? { onLoad: options }
                    : options || {};
            var scope = paper,
                item = null;
    
            function onLoad(svg) {
                try {
                    var node = typeof svg === 'object' ? svg : new self.DOMParser()
                            .parseFromString(svg, 'image/svg+xml');
                    if (!node.nodeName) {
                        node = null;
                        throw new Error('Unsupported SVG source: ' + source);
                    }
                    paper = scope;
                    item = importNode(node, options, true);
                    if (!options || options.insert !== false) {
                        owner._insertItem(undefined, item);
                    }
                    var onLoad = options.onLoad;
                    if (onLoad)
                        onLoad(item, svg);
                } catch (e) {
                    onError(e);
                }
            }
    
            function onError(message, status) {
                var onError = options.onError;
                if (onError) {
                    onError(message, status);
                } else {
                    throw new Error(message);
                }
            }
    
            if (typeof source === 'string' && !/^.*</.test(source)) {
                var node = document.getElementById(source);
                if (node) {
                    onLoad(node);
                } else {
                    Http.request({
                        url: source,
                        async: true,
                        onLoad: onLoad,
                        onError: onError
                    });
                }
            } else if (typeof File !== 'undefined' && source instanceof File) {
                var reader = new FileReader();
                reader.onload = function() {
                    onLoad(reader.result);
                };
                reader.onerror = function() {
                    onError(reader.error);
                };
                return reader.readAsText(source);
            } else {
                onLoad(source);
            }
    
            return item;
        }
    
        Item.inject({
            importSVG: function(node, options) {
                return importSVG(node, options, this);
            }
        });
    
        Project.inject({
            importSVG: function(node, options) {
                this.activate();
                return importSVG(node, options, this);
            }
        });
    };
    
    Base.exports.PaperScript = function() {
        var global = this,
            acorn = global.acorn;
        if (!acorn && "function" !== 'undefined') {
            try { acorn = __webpack_require__(181); } catch(e) {}
        }
        if (!acorn) {
            var exports, module;
            acorn = exports = module = {};
    
    (function(root, mod) {
      if (typeof exports == "object" && typeof module == "object") return mod(exports);
      if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                    (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      mod(root.acorn || (root.acorn = {}));
    })(this, function(exports) {
      "use strict";
    
      exports.version = "0.5.0";
    
      var options, input, inputLen, sourceFile;
    
      exports.parse = function(inpt, opts) {
        input = String(inpt); inputLen = input.length;
        setOptions(opts);
        initTokenState();
        return parseTopLevel(options.program);
      };
    
      var defaultOptions = exports.defaultOptions = {
        ecmaVersion: 5,
        strictSemicolons: false,
        allowTrailingCommas: true,
        forbidReserved: false,
        allowReturnOutsideFunction: false,
        locations: false,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null
      };
    
      function setOptions(opts) {
        options = opts || {};
        for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))
          options[opt] = defaultOptions[opt];
        sourceFile = options.sourceFile || null;
      }
    
      var getLineInfo = exports.getLineInfo = function(input, offset) {
        for (var line = 1, cur = 0;;) {
          lineBreak.lastIndex = cur;
          var match = lineBreak.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else break;
        }
        return {line: line, column: offset - cur};
      };
    
      exports.tokenize = function(inpt, opts) {
        input = String(inpt); inputLen = input.length;
        setOptions(opts);
        initTokenState();
    
        var t = {};
        function getToken(forceRegexp) {
          lastEnd = tokEnd;
          readToken(forceRegexp);
          t.start = tokStart; t.end = tokEnd;
          t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
          t.type = tokType; t.value = tokVal;
          return t;
        }
        getToken.jumpTo = function(pos, reAllowed) {
          tokPos = pos;
          if (options.locations) {
            tokCurLine = 1;
            tokLineStart = lineBreak.lastIndex = 0;
            var match;
            while ((match = lineBreak.exec(input)) && match.index < pos) {
              ++tokCurLine;
              tokLineStart = match.index + match[0].length;
            }
          }
          tokRegexpAllowed = reAllowed;
          skipSpace();
        };
        return getToken;
      };
    
      var tokPos;
    
      var tokStart, tokEnd;
    
      var tokStartLoc, tokEndLoc;
    
      var tokType, tokVal;
    
      var tokRegexpAllowed;
    
      var tokCurLine, tokLineStart;
    
      var lastStart, lastEnd, lastEndLoc;
    
      var inFunction, labels, strict;
    
      function raise(pos, message) {
        var loc = getLineInfo(input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
        throw err;
      }
    
      var empty = [];
    
      var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
      var _name = {type: "name"}, _eof = {type: "eof"};
    
      var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
      var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
      var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
      var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
      var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
      var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
      var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
      var _this = {keyword: "this"};
    
      var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
      var _false = {keyword: "false", atomValue: false};
    
      var _in = {keyword: "in", binop: 7, beforeExpr: true};
    
      var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
                          "continue": _continue, "debugger": _debugger, "default": _default,
                          "do": _do, "else": _else, "finally": _finally, "for": _for,
                          "function": _function, "if": _if, "return": _return, "switch": _switch,
                          "throw": _throw, "try": _try, "var": _var, "while": _while, "with": _with,
                          "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
                          "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
                          "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
                          "void": {keyword: "void", prefix: true, beforeExpr: true},
                          "delete": {keyword: "delete", prefix: true, beforeExpr: true}};
    
      var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
      var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
      var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
      var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};
    
      var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
      var _assign = {isAssign: true, beforeExpr: true};
      var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
      var _logicalOR = {binop: 1, beforeExpr: true};
      var _logicalAND = {binop: 2, beforeExpr: true};
      var _bitwiseOR = {binop: 3, beforeExpr: true};
      var _bitwiseXOR = {binop: 4, beforeExpr: true};
      var _bitwiseAND = {binop: 5, beforeExpr: true};
      var _equality = {binop: 6, beforeExpr: true};
      var _relational = {binop: 7, beforeExpr: true};
      var _bitShift = {binop: 8, beforeExpr: true};
      var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
      var _multiplyModulo = {binop: 10, beforeExpr: true};
    
      exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
                          parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
                          dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,
                          num: _num, regexp: _regexp, string: _string};
      for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];
    
      function makePredicate(words) {
        words = words.split(" ");
        var f = "", cats = [];
        out: for (var i = 0; i < words.length; ++i) {
          for (var j = 0; j < cats.length; ++j)
            if (cats[j][0].length == words[i].length) {
              cats[j].push(words[i]);
              continue out;
            }
          cats.push([words[i]]);
        }
        function compareTo(arr) {
          if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
          f += "switch(str){";
          for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
          f += "return true}return false;";
        }
    
        if (cats.length > 3) {
          cats.sort(function(a, b) {return b.length - a.length;});
          f += "switch(str.length){";
          for (var i = 0; i < cats.length; ++i) {
            var cat = cats[i];
            f += "case " + cat[0].length + ":";
            compareTo(cat);
          }
          f += "}";
    
        } else {
          compareTo(words);
        }
        return new Function("str", f);
      }
    
      var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");
    
      var isReservedWord5 = makePredicate("class enum extends super const export import");
    
      var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");
    
      var isStrictBadIdWord = makePredicate("eval arguments");
    
      var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");
    
      var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
      var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    
      var newline = /[\n\r\u2028\u2029]/;
    
      var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;
    
      var isIdentifierStart = exports.isIdentifierStart = function(code) {
        if (code < 65) return code === 36;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123)return true;
        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
      };
    
      var isIdentifierChar = exports.isIdentifierChar = function(code) {
        if (code < 48) return code === 36;
        if (code < 58) return true;
        if (code < 65) return false;
        if (code < 91) return true;
        if (code < 97) return code === 95;
        if (code < 123)return true;
        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
      };
    
      function line_loc_t() {
        this.line = tokCurLine;
        this.column = tokPos - tokLineStart;
      }
    
      function initTokenState() {
        tokCurLine = 1;
        tokPos = tokLineStart = 0;
        tokRegexpAllowed = true;
        skipSpace();
      }
    
      function finishToken(type, val) {
        tokEnd = tokPos;
        if (options.locations) tokEndLoc = new line_loc_t;
        tokType = type;
        skipSpace();
        tokVal = val;
        tokRegexpAllowed = type.beforeExpr;
      }
    
      function skipBlockComment() {
        var startLoc = options.onComment && options.locations && new line_loc_t;
        var start = tokPos, end = input.indexOf("*/", tokPos += 2);
        if (end === -1) raise(tokPos - 2, "Unterminated comment");
        tokPos = end + 2;
        if (options.locations) {
          lineBreak.lastIndex = start;
          var match;
          while ((match = lineBreak.exec(input)) && match.index < tokPos) {
            ++tokCurLine;
            tokLineStart = match.index + match[0].length;
          }
        }
        if (options.onComment)
          options.onComment(true, input.slice(start + 2, end), start, tokPos,
                            startLoc, options.locations && new line_loc_t);
      }
    
      function skipLineComment() {
        var start = tokPos;
        var startLoc = options.onComment && options.locations && new line_loc_t;
        var ch = input.charCodeAt(tokPos+=2);
        while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
          ++tokPos;
          ch = input.charCodeAt(tokPos);
        }
        if (options.onComment)
          options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,
                            startLoc, options.locations && new line_loc_t);
      }
    
      function skipSpace() {
        while (tokPos < inputLen) {
          var ch = input.charCodeAt(tokPos);
          if (ch === 32) {
            ++tokPos;
          } else if (ch === 13) {
            ++tokPos;
            var next = input.charCodeAt(tokPos);
            if (next === 10) {
              ++tokPos;
            }
            if (options.locations) {
              ++tokCurLine;
              tokLineStart = tokPos;
            }
          } else if (ch === 10 || ch === 8232 || ch === 8233) {
            ++tokPos;
            if (options.locations) {
              ++tokCurLine;
              tokLineStart = tokPos;
            }
          } else if (ch > 8 && ch < 14) {
            ++tokPos;
          } else if (ch === 47) {
            var next = input.charCodeAt(tokPos + 1);
            if (next === 42) {
              skipBlockComment();
            } else if (next === 47) {
              skipLineComment();
            } else break;
          } else if (ch === 160) {
            ++tokPos;
          } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++tokPos;
          } else {
            break;
          }
        }
      }
    
      function readToken_dot() {
        var next = input.charCodeAt(tokPos + 1);
        if (next >= 48 && next <= 57) return readNumber(true);
        ++tokPos;
        return finishToken(_dot);
      }
    
      function readToken_slash() {
        var next = input.charCodeAt(tokPos + 1);
        if (tokRegexpAllowed) {++tokPos; return readRegexp();}
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(_slash, 1);
      }
    
      function readToken_mult_modulo() {
        var next = input.charCodeAt(tokPos + 1);
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(_multiplyModulo, 1);
      }
    
      function readToken_pipe_amp(code) {
        var next = input.charCodeAt(tokPos + 1);
        if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
      }
    
      function readToken_caret() {
        var next = input.charCodeAt(tokPos + 1);
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(_bitwiseXOR, 1);
      }
    
      function readToken_plus_min(code) {
        var next = input.charCodeAt(tokPos + 1);
        if (next === code) {
          if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
              newline.test(input.slice(lastEnd, tokPos))) {
            tokPos += 3;
            skipLineComment();
            skipSpace();
            return readToken();
          }
          return finishOp(_incDec, 2);
        }
        if (next === 61) return finishOp(_assign, 2);
        return finishOp(_plusMin, 1);
      }
    
      function readToken_lt_gt(code) {
        var next = input.charCodeAt(tokPos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
          if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
          return finishOp(_bitShift, size);
        }
        if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
            input.charCodeAt(tokPos + 3) == 45) {
          tokPos += 4;
          skipLineComment();
          skipSpace();
          return readToken();
        }
        if (next === 61)
          size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
        return finishOp(_relational, size);
      }
    
      function readToken_eq_excl(code) {
        var next = input.charCodeAt(tokPos + 1);
        if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
        return finishOp(code === 61 ? _eq : _prefix, 1);
      }
    
      function getTokenFromCode(code) {
        switch(code) {
        case 46:
          return readToken_dot();
    
        case 40: ++tokPos; return finishToken(_parenL);
        case 41: ++tokPos; return finishToken(_parenR);
        case 59: ++tokPos; return finishToken(_semi);
        case 44: ++tokPos; return finishToken(_comma);
        case 91: ++tokPos; return finishToken(_bracketL);
        case 93: ++tokPos; return finishToken(_bracketR);
        case 123: ++tokPos; return finishToken(_braceL);
        case 125: ++tokPos; return finishToken(_braceR);
        case 58: ++tokPos; return finishToken(_colon);
        case 63: ++tokPos; return finishToken(_question);
    
        case 48:
          var next = input.charCodeAt(tokPos + 1);
          if (next === 120 || next === 88) return readHexNumber();
        case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:
          return readNumber(false);
    
        case 34: case 39:
          return readString(code);
    
        case 47:
          return readToken_slash(code);
    
        case 37: case 42:
          return readToken_mult_modulo();
    
        case 124: case 38:
          return readToken_pipe_amp(code);
    
        case 94:
          return readToken_caret();
    
        case 43: case 45:
          return readToken_plus_min(code);
    
        case 60: case 62:
          return readToken_lt_gt(code);
    
        case 61: case 33:
          return readToken_eq_excl(code);
    
        case 126:
          return finishOp(_prefix, 1);
        }
    
        return false;
      }
    
      function readToken(forceRegexp) {
        if (!forceRegexp) tokStart = tokPos;
        else tokPos = tokStart + 1;
        if (options.locations) tokStartLoc = new line_loc_t;
        if (forceRegexp) return readRegexp();
        if (tokPos >= inputLen) return finishToken(_eof);
    
        var code = input.charCodeAt(tokPos);
        if (isIdentifierStart(code) || code === 92 ) return readWord();
    
        var tok = getTokenFromCode(code);
    
        if (tok === false) {
          var ch = String.fromCharCode(code);
          if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
          raise(tokPos, "Unexpected character '" + ch + "'");
        }
        return tok;
      }
    
      function finishOp(type, size) {
        var str = input.slice(tokPos, tokPos + size);
        tokPos += size;
        finishToken(type, str);
      }
    
      function readRegexp() {
        var content = "", escaped, inClass, start = tokPos;
        for (;;) {
          if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
          var ch = input.charAt(tokPos);
          if (newline.test(ch)) raise(start, "Unterminated regular expression");
          if (!escaped) {
            if (ch === "[") inClass = true;
            else if (ch === "]" && inClass) inClass = false;
            else if (ch === "/" && !inClass) break;
            escaped = ch === "\\";
          } else escaped = false;
          ++tokPos;
        }
        var content = input.slice(start, tokPos);
        ++tokPos;
        var mods = readWord1();
        if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
        try {
          var value = new RegExp(content, mods);
        } catch (e) {
          if (e instanceof SyntaxError) raise(start, e.message);
          raise(e);
        }
        return finishToken(_regexp, value);
      }
    
      function readInt(radix, len) {
        var start = tokPos, total = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          var code = input.charCodeAt(tokPos), val;
          if (code >= 97) val = code - 97 + 10;
          else if (code >= 65) val = code - 65 + 10;
          else if (code >= 48 && code <= 57) val = code - 48;
          else val = Infinity;
          if (val >= radix) break;
          ++tokPos;
          total = total * radix + val;
        }
        if (tokPos === start || len != null && tokPos - start !== len) return null;
    
        return total;
      }
    
      function readHexNumber() {
        tokPos += 2;
        var val = readInt(16);
        if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
        if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
        return finishToken(_num, val);
      }
    
      function readNumber(startsWithDot) {
        var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
        if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
        if (input.charCodeAt(tokPos) === 46) {
          ++tokPos;
          readInt(10);
          isFloat = true;
        }
        var next = input.charCodeAt(tokPos);
        if (next === 69 || next === 101) {
          next = input.charCodeAt(++tokPos);
          if (next === 43 || next === 45) ++tokPos;
          if (readInt(10) === null) raise(start, "Invalid number");
          isFloat = true;
        }
        if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
    
        var str = input.slice(start, tokPos), val;
        if (isFloat) val = parseFloat(str);
        else if (!octal || str.length === 1) val = parseInt(str, 10);
        else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
        else val = parseInt(str, 8);
        return finishToken(_num, val);
      }
    
      function readString(quote) {
        tokPos++;
        var out = "";
        for (;;) {
          if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
          var ch = input.charCodeAt(tokPos);
          if (ch === quote) {
            ++tokPos;
            return finishToken(_string, out);
          }
          if (ch === 92) {
            ch = input.charCodeAt(++tokPos);
            var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
            if (octal) octal = octal[0];
            while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
            if (octal === "0") octal = null;
            ++tokPos;
            if (octal) {
              if (strict) raise(tokPos - 2, "Octal literal in strict mode");
              out += String.fromCharCode(parseInt(octal, 8));
              tokPos += octal.length - 1;
            } else {
              switch (ch) {
              case 110: out += "\n"; break;
              case 114: out += "\r"; break;
              case 120: out += String.fromCharCode(readHexChar(2)); break;
              case 117: out += String.fromCharCode(readHexChar(4)); break;
              case 85: out += String.fromCharCode(readHexChar(8)); break;
              case 116: out += "\t"; break;
              case 98: out += "\b"; break;
              case 118: out += "\u000b"; break;
              case 102: out += "\f"; break;
              case 48: out += "\0"; break;
              case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;
              case 10:
                if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
                break;
              default: out += String.fromCharCode(ch); break;
              }
            }
          } else {
            if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
            out += String.fromCharCode(ch);
            ++tokPos;
          }
        }
      }
    
      function readHexChar(len) {
        var n = readInt(16, len);
        if (n === null) raise(tokStart, "Bad character escape sequence");
        return n;
      }
    
      var containsEsc;
    
      function readWord1() {
        containsEsc = false;
        var word, first = true, start = tokPos;
        for (;;) {
          var ch = input.charCodeAt(tokPos);
          if (isIdentifierChar(ch)) {
            if (containsEsc) word += input.charAt(tokPos);
            ++tokPos;
          } else if (ch === 92) {
            if (!containsEsc) word = input.slice(start, tokPos);
            containsEsc = true;
            if (input.charCodeAt(++tokPos) != 117)
              raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
            ++tokPos;
            var esc = readHexChar(4);
            var escStr = String.fromCharCode(esc);
            if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
            if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
              raise(tokPos - 4, "Invalid Unicode escape");
            word += escStr;
          } else {
            break;
          }
          first = false;
        }
        return containsEsc ? word : input.slice(start, tokPos);
      }
    
      function readWord() {
        var word = readWord1();
        var type = _name;
        if (!containsEsc && isKeyword(word))
          type = keywordTypes[word];
        return finishToken(type, word);
      }
    
      function next() {
        lastStart = tokStart;
        lastEnd = tokEnd;
        lastEndLoc = tokEndLoc;
        readToken();
      }
    
      function setStrict(strct) {
        strict = strct;
        tokPos = tokStart;
        if (options.locations) {
          while (tokPos < tokLineStart) {
            tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
            --tokCurLine;
          }
        }
        skipSpace();
        readToken();
      }
    
      function node_t() {
        this.type = null;
        this.start = tokStart;
        this.end = null;
      }
    
      function node_loc_t() {
        this.start = tokStartLoc;
        this.end = null;
        if (sourceFile !== null) this.source = sourceFile;
      }
    
      function startNode() {
        var node = new node_t();
        if (options.locations)
          node.loc = new node_loc_t();
        if (options.directSourceFile)
          node.sourceFile = options.directSourceFile;
        if (options.ranges)
          node.range = [tokStart, 0];
        return node;
      }
    
      function startNodeFrom(other) {
        var node = new node_t();
        node.start = other.start;
        if (options.locations) {
          node.loc = new node_loc_t();
          node.loc.start = other.loc.start;
        }
        if (options.ranges)
          node.range = [other.range[0], 0];
    
        return node;
      }
    
      function finishNode(node, type) {
        node.type = type;
        node.end = lastEnd;
        if (options.locations)
          node.loc.end = lastEndLoc;
        if (options.ranges)
          node.range[1] = lastEnd;
        return node;
      }
    
      function isUseStrict(stmt) {
        return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
          stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
      }
    
      function eat(type) {
        if (tokType === type) {
          next();
          return true;
        }
      }
    
      function canInsertSemicolon() {
        return !options.strictSemicolons &&
          (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
      }
    
      function semicolon() {
        if (!eat(_semi) && !canInsertSemicolon()) unexpected();
      }
    
      function expect(type) {
        if (tokType === type) next();
        else unexpected();
      }
    
      function unexpected() {
        raise(tokStart, "Unexpected token");
      }
    
      function checkLVal(expr) {
        if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
          raise(expr.start, "Assigning to rvalue");
        if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
          raise(expr.start, "Assigning to " + expr.name + " in strict mode");
      }
    
      function parseTopLevel(program) {
        lastStart = lastEnd = tokPos;
        if (options.locations) lastEndLoc = new line_loc_t;
        inFunction = strict = null;
        labels = [];
        readToken();
    
        var node = program || startNode(), first = true;
        if (!program) node.body = [];
        while (tokType !== _eof) {
          var stmt = parseStatement();
          node.body.push(stmt);
          if (first && isUseStrict(stmt)) setStrict(true);
          first = false;
        }
        return finishNode(node, "Program");
      }
    
      var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};
    
      function parseStatement() {
        if (tokType === _slash || tokType === _assign && tokVal == "/=")
          readToken(true);
    
        var starttype = tokType, node = startNode();
    
        switch (starttype) {
        case _break: case _continue:
          next();
          var isBreak = starttype === _break;
          if (eat(_semi) || canInsertSemicolon()) node.label = null;
          else if (tokType !== _name) unexpected();
          else {
            node.label = parseIdent();
            semicolon();
          }
    
          for (var i = 0; i < labels.length; ++i) {
            var lab = labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
              if (node.label && isBreak) break;
            }
          }
          if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
          return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    
        case _debugger:
          next();
          semicolon();
          return finishNode(node, "DebuggerStatement");
    
        case _do:
          next();
          labels.push(loopLabel);
          node.body = parseStatement();
          labels.pop();
          expect(_while);
          node.test = parseParenExpression();
          semicolon();
          return finishNode(node, "DoWhileStatement");
    
        case _for:
          next();
          labels.push(loopLabel);
          expect(_parenL);
          if (tokType === _semi) return parseFor(node, null);
          if (tokType === _var) {
            var init = startNode();
            next();
            parseVar(init, true);
            finishNode(init, "VariableDeclaration");
            if (init.declarations.length === 1 && eat(_in))
              return parseForIn(node, init);
            return parseFor(node, init);
          }
          var init = parseExpression(false, true);
          if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}
          return parseFor(node, init);
    
        case _function:
          next();
          return parseFunction(node, true);
    
        case _if:
          next();
          node.test = parseParenExpression();
          node.consequent = parseStatement();
          node.alternate = eat(_else) ? parseStatement() : null;
          return finishNode(node, "IfStatement");
    
        case _return:
          if (!inFunction && !options.allowReturnOutsideFunction)
            raise(tokStart, "'return' outside of function");
          next();
    
          if (eat(_semi) || canInsertSemicolon()) node.argument = null;
          else { node.argument = parseExpression(); semicolon(); }
          return finishNode(node, "ReturnStatement");
    
        case _switch:
          next();
          node.discriminant = parseParenExpression();
          node.cases = [];
          expect(_braceL);
          labels.push(switchLabel);
    
          for (var cur, sawDefault; tokType != _braceR;) {
            if (tokType === _case || tokType === _default) {
              var isCase = tokType === _case;
              if (cur) finishNode(cur, "SwitchCase");
              node.cases.push(cur = startNode());
              cur.consequent = [];
              next();
              if (isCase) cur.test = parseExpression();
              else {
                if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
                cur.test = null;
              }
              expect(_colon);
            } else {
              if (!cur) unexpected();
              cur.consequent.push(parseStatement());
            }
          }
          if (cur) finishNode(cur, "SwitchCase");
          next();
          labels.pop();
          return finishNode(node, "SwitchStatement");
    
        case _throw:
          next();
          if (newline.test(input.slice(lastEnd, tokStart)))
            raise(lastEnd, "Illegal newline after throw");
          node.argument = parseExpression();
          semicolon();
          return finishNode(node, "ThrowStatement");
    
        case _try:
          next();
          node.block = parseBlock();
          node.handler = null;
          if (tokType === _catch) {
            var clause = startNode();
            next();
            expect(_parenL);
            clause.param = parseIdent();
            if (strict && isStrictBadIdWord(clause.param.name))
              raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
            expect(_parenR);
            clause.guard = null;
            clause.body = parseBlock();
            node.handler = finishNode(clause, "CatchClause");
          }
          node.guardedHandlers = empty;
          node.finalizer = eat(_finally) ? parseBlock() : null;
          if (!node.handler && !node.finalizer)
            raise(node.start, "Missing catch or finally clause");
          return finishNode(node, "TryStatement");
    
        case _var:
          next();
          parseVar(node);
          semicolon();
          return finishNode(node, "VariableDeclaration");
    
        case _while:
          next();
          node.test = parseParenExpression();
          labels.push(loopLabel);
          node.body = parseStatement();
          labels.pop();
          return finishNode(node, "WhileStatement");
    
        case _with:
          if (strict) raise(tokStart, "'with' in strict mode");
          next();
          node.object = parseParenExpression();
          node.body = parseStatement();
          return finishNode(node, "WithStatement");
    
        case _braceL:
          return parseBlock();
    
        case _semi:
          next();
          return finishNode(node, "EmptyStatement");
    
        default:
          var maybeName = tokVal, expr = parseExpression();
          if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
            for (var i = 0; i < labels.length; ++i)
              if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
            var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
            labels.push({name: maybeName, kind: kind});
            node.body = parseStatement();
            labels.pop();
            node.label = expr;
            return finishNode(node, "LabeledStatement");
          } else {
            node.expression = expr;
            semicolon();
            return finishNode(node, "ExpressionStatement");
          }
        }
      }
    
      function parseParenExpression() {
        expect(_parenL);
        var val = parseExpression();
        expect(_parenR);
        return val;
      }
    
      function parseBlock(allowStrict) {
        var node = startNode(), first = true, strict = false, oldStrict;
        node.body = [];
        expect(_braceL);
        while (!eat(_braceR)) {
          var stmt = parseStatement();
          node.body.push(stmt);
          if (first && allowStrict && isUseStrict(stmt)) {
            oldStrict = strict;
            setStrict(strict = true);
          }
          first = false;
        }
        if (strict && !oldStrict) setStrict(false);
        return finishNode(node, "BlockStatement");
      }
    
      function parseFor(node, init) {
        node.init = init;
        expect(_semi);
        node.test = tokType === _semi ? null : parseExpression();
        expect(_semi);
        node.update = tokType === _parenR ? null : parseExpression();
        expect(_parenR);
        node.body = parseStatement();
        labels.pop();
        return finishNode(node, "ForStatement");
      }
    
      function parseForIn(node, init) {
        node.left = init;
        node.right = parseExpression();
        expect(_parenR);
        node.body = parseStatement();
        labels.pop();
        return finishNode(node, "ForInStatement");
      }
    
      function parseVar(node, noIn) {
        node.declarations = [];
        node.kind = "var";
        for (;;) {
          var decl = startNode();
          decl.id = parseIdent();
          if (strict && isStrictBadIdWord(decl.id.name))
            raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
          decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
          node.declarations.push(finishNode(decl, "VariableDeclarator"));
          if (!eat(_comma)) break;
        }
        return node;
      }
    
      function parseExpression(noComma, noIn) {
        var expr = parseMaybeAssign(noIn);
        if (!noComma && tokType === _comma) {
          var node = startNodeFrom(expr);
          node.expressions = [expr];
          while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
          return finishNode(node, "SequenceExpression");
        }
        return expr;
      }
    
      function parseMaybeAssign(noIn) {
        var left = parseMaybeConditional(noIn);
        if (tokType.isAssign) {
          var node = startNodeFrom(left);
          node.operator = tokVal;
          node.left = left;
          next();
          node.right = parseMaybeAssign(noIn);
          checkLVal(left);
          return finishNode(node, "AssignmentExpression");
        }
        return left;
      }
    
      function parseMaybeConditional(noIn) {
        var expr = parseExprOps(noIn);
        if (eat(_question)) {
          var node = startNodeFrom(expr);
          node.test = expr;
          node.consequent = parseExpression(true);
          expect(_colon);
          node.alternate = parseExpression(true, noIn);
          return finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
    
      function parseExprOps(noIn) {
        return parseExprOp(parseMaybeUnary(), -1, noIn);
      }
    
      function parseExprOp(left, minPrec, noIn) {
        var prec = tokType.binop;
        if (prec != null && (!noIn || tokType !== _in)) {
          if (prec > minPrec) {
            var node = startNodeFrom(left);
            node.left = left;
            node.operator = tokVal;
            var op = tokType;
            next();
            node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
            var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
            return parseExprOp(exprNode, minPrec, noIn);
          }
        }
        return left;
      }
    
      function parseMaybeUnary() {
        if (tokType.prefix) {
          var node = startNode(), update = tokType.isUpdate;
          node.operator = tokVal;
          node.prefix = true;
          tokRegexpAllowed = true;
          next();
          node.argument = parseMaybeUnary();
          if (update) checkLVal(node.argument);
          else if (strict && node.operator === "delete" &&
                   node.argument.type === "Identifier")
            raise(node.start, "Deleting local variable in strict mode");
          return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        }
        var expr = parseExprSubscripts();
        while (tokType.postfix && !canInsertSemicolon()) {
          var node = startNodeFrom(expr);
          node.operator = tokVal;
          node.prefix = false;
          node.argument = expr;
          checkLVal(expr);
          next();
          expr = finishNode(node, "UpdateExpression");
        }
        return expr;
      }
    
      function parseExprSubscripts() {
        return parseSubscripts(parseExprAtom());
      }
    
      function parseSubscripts(base, noCalls) {
        if (eat(_dot)) {
          var node = startNodeFrom(base);
          node.object = base;
          node.property = parseIdent(true);
          node.computed = false;
          return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
        } else if (eat(_bracketL)) {
          var node = startNodeFrom(base);
          node.object = base;
          node.property = parseExpression();
          node.computed = true;
          expect(_bracketR);
          return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
        } else if (!noCalls && eat(_parenL)) {
          var node = startNodeFrom(base);
          node.callee = base;
          node.arguments = parseExprList(_parenR, false);
          return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
        } else return base;
      }
    
      function parseExprAtom() {
        switch (tokType) {
        case _this:
          var node = startNode();
          next();
          return finishNode(node, "ThisExpression");
        case _name:
          return parseIdent();
        case _num: case _string: case _regexp:
          var node = startNode();
          node.value = tokVal;
          node.raw = input.slice(tokStart, tokEnd);
          next();
          return finishNode(node, "Literal");
    
        case _null: case _true: case _false:
          var node = startNode();
          node.value = tokType.atomValue;
          node.raw = tokType.keyword;
          next();
          return finishNode(node, "Literal");
    
        case _parenL:
          var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
          next();
          var val = parseExpression();
          val.start = tokStart1;
          val.end = tokEnd;
          if (options.locations) {
            val.loc.start = tokStartLoc1;
            val.loc.end = tokEndLoc;
          }
          if (options.ranges)
            val.range = [tokStart1, tokEnd];
          expect(_parenR);
          return val;
    
        case _bracketL:
          var node = startNode();
          next();
          node.elements = parseExprList(_bracketR, true, true);
          return finishNode(node, "ArrayExpression");
    
        case _braceL:
          return parseObj();
    
        case _function:
          var node = startNode();
          next();
          return parseFunction(node, false);
    
        case _new:
          return parseNew();
    
        default:
          unexpected();
        }
      }
    
      function parseNew() {
        var node = startNode();
        next();
        node.callee = parseSubscripts(parseExprAtom(), true);
        if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
        else node.arguments = empty;
        return finishNode(node, "NewExpression");
      }
    
      function parseObj() {
        var node = startNode(), first = true, sawGetSet = false;
        node.properties = [];
        next();
        while (!eat(_braceR)) {
          if (!first) {
            expect(_comma);
            if (options.allowTrailingCommas && eat(_braceR)) break;
          } else first = false;
    
          var prop = {key: parsePropertyName()}, isGetSet = false, kind;
          if (eat(_colon)) {
            prop.value = parseExpression(true);
            kind = prop.kind = "init";
          } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
                     (prop.key.name === "get" || prop.key.name === "set")) {
            isGetSet = sawGetSet = true;
            kind = prop.kind = prop.key.name;
            prop.key = parsePropertyName();
            if (tokType !== _parenL) unexpected();
            prop.value = parseFunction(startNode(), false);
          } else unexpected();
    
          if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
            for (var i = 0; i < node.properties.length; ++i) {
              var other = node.properties[i];
              if (other.key.name === prop.key.name) {
                var conflict = kind == other.kind || isGetSet && other.kind === "init" ||
                  kind === "init" && (other.kind === "get" || other.kind === "set");
                if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
                if (conflict) raise(prop.key.start, "Redefinition of property");
              }
            }
          }
          node.properties.push(prop);
        }
        return finishNode(node, "ObjectExpression");
      }
    
      function parsePropertyName() {
        if (tokType === _num || tokType === _string) return parseExprAtom();
        return parseIdent(true);
      }
    
      function parseFunction(node, isStatement) {
        if (tokType === _name) node.id = parseIdent();
        else if (isStatement) unexpected();
        else node.id = null;
        node.params = [];
        var first = true;
        expect(_parenL);
        while (!eat(_parenR)) {
          if (!first) expect(_comma); else first = false;
          node.params.push(parseIdent());
        }
    
        var oldInFunc = inFunction, oldLabels = labels;
        inFunction = true; labels = [];
        node.body = parseBlock(true);
        inFunction = oldInFunc; labels = oldLabels;
    
        if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
          for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
            var id = i < 0 ? node.id : node.params[i];
            if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
              raise(id.start, "Defining '" + id.name + "' in strict mode");
            if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)
              raise(id.start, "Argument name clash in strict mode");
          }
        }
    
        return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      }
    
      function parseExprList(close, allowTrailingComma, allowEmpty) {
        var elts = [], first = true;
        while (!eat(close)) {
          if (!first) {
            expect(_comma);
            if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
          } else first = false;
    
          if (allowEmpty && tokType === _comma) elts.push(null);
          else elts.push(parseExpression(true));
        }
        return elts;
      }
    
      function parseIdent(liberal) {
        var node = startNode();
        if (liberal && options.forbidReserved == "everywhere") liberal = false;
        if (tokType === _name) {
          if (!liberal &&
              (options.forbidReserved &&
               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
               strict && isStrictReservedWord(tokVal)) &&
              input.slice(tokStart, tokEnd).indexOf("\\") == -1)
            raise(tokStart, "The keyword '" + tokVal + "' is reserved");
          node.name = tokVal;
        } else if (liberal && tokType.keyword) {
          node.name = tokType.keyword;
        } else {
          unexpected();
        }
        tokRegexpAllowed = false;
        next();
        return finishNode(node, "Identifier");
      }
    
    });
    
            if (!acorn.version)
                acorn = null;
        }
    
        function parse(code, options) {
            return (global.acorn || acorn).parse(code, options);
        }
    
        var binaryOperators = {
            '+': '__add',
            '-': '__subtract',
            '*': '__multiply',
            '/': '__divide',
            '%': '__modulo',
            '==': '__equals',
            '!=': '__equals'
        };
    
        var unaryOperators = {
            '-': '__negate',
            '+': '__self'
        };
    
        var fields = Base.each(
            ['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],
            function(name) {
                this['__' + name] = '#' + name;
            },
            {
                __self: function() {
                    return this;
                }
            }
        );
        Point.inject(fields);
        Size.inject(fields);
        Color.inject(fields);
    
        function __$__(left, operator, right) {
            var handler = binaryOperators[operator];
            if (left && left[handler]) {
                var res = left[handler](right);
                return operator === '!=' ? !res : res;
            }
            switch (operator) {
            case '+': return left + right;
            case '-': return left - right;
            case '*': return left * right;
            case '/': return left / right;
            case '%': return left % right;
            case '==': return left == right;
            case '!=': return left != right;
            }
        }
    
        function $__(operator, value) {
            var handler = unaryOperators[operator];
            if (value && value[handler])
                return value[handler]();
            switch (operator) {
            case '+': return +value;
            case '-': return -value;
            }
        }
    
        function compile(code, options) {
            if (!code)
                return '';
            options = options || {};
    
            var insertions = [];
    
            function getOffset(offset) {
                for (var i = 0, l = insertions.length; i < l; i++) {
                    var insertion = insertions[i];
                    if (insertion[0] >= offset)
                        break;
                    offset += insertion[1];
                }
                return offset;
            }
    
            function getCode(node) {
                return code.substring(getOffset(node.range[0]),
                        getOffset(node.range[1]));
            }
    
            function getBetween(left, right) {
                return code.substring(getOffset(left.range[1]),
                        getOffset(right.range[0]));
            }
    
            function replaceCode(node, str) {
                var start = getOffset(node.range[0]),
                    end = getOffset(node.range[1]),
                    insert = 0;
                for (var i = insertions.length - 1; i >= 0; i--) {
                    if (start > insertions[i][0]) {
                        insert = i + 1;
                        break;
                    }
                }
                insertions.splice(insert, 0, [start, str.length - end + start]);
                code = code.substring(0, start) + str + code.substring(end);
            }
    
            function walkAST(node, parent) {
                if (!node)
                    return;
                for (var key in node) {
                    if (key === 'range' || key === 'loc')
                        continue;
                    var value = node[key];
                    if (Array.isArray(value)) {
                        for (var i = 0, l = value.length; i < l; i++)
                            walkAST(value[i], node);
                    } else if (value && typeof value === 'object') {
                        walkAST(value, node);
                    }
                }
                switch (node.type) {
                case 'UnaryExpression':
                    if (node.operator in unaryOperators
                            && node.argument.type !== 'Literal') {
                        var arg = getCode(node.argument);
                        replaceCode(node, '$__("' + node.operator + '", '
                                + arg + ')');
                    }
                    break;
                case 'BinaryExpression':
                    if (node.operator in binaryOperators
                            && node.left.type !== 'Literal') {
                        var left = getCode(node.left),
                            right = getCode(node.right),
                            between = getBetween(node.left, node.right),
                            operator = node.operator;
                        replaceCode(node, '__$__(' + left + ','
                                + between.replace(new RegExp('\\' + operator),
                                    '"' + operator + '"')
                                + ', ' + right + ')');
                    }
                    break;
                case 'UpdateExpression':
                case 'AssignmentExpression':
                    var parentType = parent && parent.type;
                    if (!(
                            parentType === 'ForStatement'
                            || parentType === 'BinaryExpression'
                                && /^[=!<>]/.test(parent.operator)
                            || parentType === 'MemberExpression' && parent.computed
                    )) {
                        if (node.type === 'UpdateExpression') {
                            var arg = getCode(node.argument),
                                exp = '__$__(' + arg + ', "' + node.operator[0]
                                        + '", 1)',
                                str = arg + ' = ' + exp;
                            if (!node.prefix
                                    && (parentType === 'AssignmentExpression'
                                        || parentType === 'VariableDeclarator')) {
                                if (getCode(parent.left || parent.id) === arg)
                                    str = exp;
                                str = arg + '; ' + str;
                            }
                            replaceCode(node, str);
                        } else {
                            if (/^.=$/.test(node.operator)
                                    && node.left.type !== 'Literal') {
                                var left = getCode(node.left),
                                    right = getCode(node.right),
                                    exp = left + ' = __$__(' + left + ', "'
                                        + node.operator[0] + '", ' + right + ')';
                                replaceCode(node, /^\(.*\)$/.test(getCode(node))
                                        ? '(' + exp + ')' : exp);
                            }
                        }
                    }
                    break;
                }
            }
    
            function encodeVLQ(value) {
                var res = '',
                    base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);
                while (value || !res) {
                    var next = value & (32 - 1);
                    value >>= 5;
                    if (value)
                        next |= 32;
                    res += base64[next];
                }
                return res;
            }
    
            var url = options.url || '',
                agent = paper.agent,
                version = agent.versionNumber,
                offsetCode = false,
                sourceMaps = options.sourceMaps,
                source = options.source || code,
                lineBreaks = /\r\n|\n|\r/mg,
                offset = options.offset || 0,
                map;
            if (sourceMaps && (agent.chrome && version >= 30
                    || agent.webkit && version >= 537.76
                    || agent.firefox && version >= 23
                    || agent.node)) {
                if (agent.node) {
                    offset -= 2;
                } else if (window && url && !window.location.href.indexOf(url)) {
                    var html = document.getElementsByTagName('html')[0].innerHTML;
                    offset = html.substr(0, html.indexOf(code) + 1).match(
                            lineBreaks).length + 1;
                }
                offsetCode = offset > 0 && !(
                        agent.chrome && version >= 36 ||
                        agent.safari && version >= 600 ||
                        agent.firefox && version >= 40 ||
                        agent.node);
                var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
                mappings.length = (code.match(lineBreaks) || []).length + 1
                        + (offsetCode ? offset : 0);
                map = {
                    version: 3,
                    file: url,
                    names:[],
                    mappings: mappings.join(';AACA'),
                    sourceRoot: '',
                    sources: [url],
                    sourcesContent: [source]
                };
            }
            walkAST(parse(code, { ranges: true, preserveParens: true }));
            if (map) {
                if (offsetCode) {
                    code = new Array(offset + 1).join('\n') + code;
                }
                if (/^(inline|both)$/.test(sourceMaps)) {
                    code += "\n//# sourceMappingURL=data:application/json;base64,"
                            + self.btoa(unescape(encodeURIComponent(
                                JSON.stringify(map))));
                }
                code += "\n//# sourceURL=" + (url || 'paperscript');
            }
            return {
                url: url,
                source: source,
                code: code,
                map: map
            };
        }
    
        function execute(code, scope, options) {
            paper = scope;
            var view = scope.getView(),
                tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/
                        .test(code) && !/\bnew\s+Tool\b/.test(code)
                            ? new Tool() : null,
                toolHandlers = tool ? tool._events : [],
                handlers = ['onFrame', 'onResize'].concat(toolHandlers),
                params = [],
                args = [],
                func,
                compiled = typeof code === 'object' ? code : compile(code, options);
            code = compiled.code;
            function expose(scope, hidden) {
                for (var key in scope) {
                    if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
                            + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
                        params.push(key);
                        args.push(scope[key]);
                    }
                }
            }
            expose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },
                    true);
            expose(scope);
            handlers = Base.each(handlers, function(key) {
                if (new RegExp('\\s+' + key + '\\b').test(code)) {
                    params.push(key);
                    this.push(key + ': ' + key);
                }
            }, []).join(', ');
            if (handlers)
                code += '\nreturn { ' + handlers + ' };';
            var agent = paper.agent;
            if (document && (agent.chrome
                    || agent.firefox && agent.versionNumber < 40)) {
                var script = document.createElement('script'),
                    head = document.head || document.getElementsByTagName('head')[0];
                if (agent.firefox)
                    code = '\n' + code;
                script.appendChild(document.createTextNode(
                    'paper._execute = function(' + params + ') {' + code + '\n}'
                ));
                head.appendChild(script);
                func = paper._execute;
                delete paper._execute;
                head.removeChild(script);
            } else {
                func = Function(params, code);
            }
            var res = func.apply(scope, args) || {};
            Base.each(toolHandlers, function(key) {
                var value = res[key];
                if (value)
                    tool[key] = value;
            });
            if (view) {
                if (res.onResize)
                    view.setOnResize(res.onResize);
                view.emit('resize', {
                    size: view.size,
                    delta: new Point()
                });
                if (res.onFrame)
                    view.setOnFrame(res.onFrame);
                view.requestUpdate();
            }
            return compiled;
        }
    
        function loadScript(script) {
            if (/^text\/(?:x-|)paperscript$/.test(script.type)
                    && PaperScope.getAttribute(script, 'ignore') !== 'true') {
                var canvasId = PaperScope.getAttribute(script, 'canvas'),
                    canvas = document.getElementById(canvasId),
                    src = script.src || script.getAttribute('data-src'),
                    async = PaperScope.hasAttribute(script, 'async'),
                    scopeAttribute = 'data-paper-scope';
                if (!canvas)
                    throw new Error('Unable to find canvas with id "'
                            + canvasId + '"');
                var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
                            || new PaperScope().setup(canvas);
                canvas.setAttribute(scopeAttribute, scope._id);
                if (src) {
                    Http.request({
                        url: src,
                        async: async,
                        mimeType: 'text/plain',
                        onLoad: function(code) {
                            execute(code, scope, src);
                        }
                    });
                } else {
                    execute(script.innerHTML, scope, script.baseURI);
                }
                script.setAttribute('data-paper-ignore', 'true');
                return scope;
            }
        }
    
        function loadAll() {
            Base.each(document && document.getElementsByTagName('script'),
                    loadScript);
        }
    
        function load(script) {
            return script ? loadScript(script) : loadAll();
        }
    
        if (window) {
            if (document.readyState === 'complete') {
                setTimeout(loadAll);
            } else {
                DomEvent.add(window, { load: loadAll });
            }
        }
    
        return {
            compile: compile,
            execute: execute,
            load: load,
            parse: parse
        };
    
    }.call(this);
    
    paper = new (PaperScope.inject(Base.exports, {
        Base: Base,
        Numerical: Numerical,
        Key: Key,
        DomEvent: DomEvent,
        DomElement: DomElement,
        document: document,
        window: window,
        Symbol: SymbolDefinition,
        PlacedSymbol: SymbolItem
    }))();
    
    if (paper.agent.node) {
        __webpack_require__(182)(paper);
    }
    
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                    (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
                    __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module) {
        module.exports = paper;
    }
    
    return paper;
    }.call(this, typeof self === 'object' ? self : null);
    
    
    /***/ }),
    /* 180 */
    /***/ (function(module, exports) {
    
    /* (ignored) */
    
    /***/ }),
    /* 181 */
    /***/ (function(module, __webpack_exports__, __webpack_require__) {
    
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse_dammit", function() { return parse_dammit; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LooseParser", function() { return LooseParser; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pluginsLoose", function() { return pluginsLoose; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLooseExports", function() { return addLooseExports; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plugins", function() { return plugins; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords$1; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types$1; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
    // Reserved word lists for various dialects of the language
    
    var reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    
    // And the keywords
    
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    
    var keywords = {
      5: ecma5AndLessKeywords,
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    
    // ## Character categories
    
    // Big ugly regular expressions that match characters in the
    // whitespace, identifier, and identifier-start categories. These
    // are only applied when a character is found to actually have a
    // code point above 128.
    // Generated by `bin/generate-identifier-regex.js`.
    
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fd5\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
    var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d01-\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf8\u1cf9\u1dc0-\u1df5\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
    
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    
    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range. They were
    // generated by bin/generate-identifier-regex.js
    
    // eslint-disable-next-line comma-spacing
    var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541];
    
    // eslint-disable-next-line comma-spacing
    var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];
    
    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
      var pos = 0x10000;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code) { return false }
        pos += set[i + 1];
        if (pos >= code) { return true }
      }
    }
    
    // Test whether a given character code starts an identifier.
    
    function isIdentifierStart(code, astral) {
      if (code < 65) { return code === 36 }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes)
    }
    
    // Test whether a given character is part of an identifier.
    
    function isIdentifierChar(code, astral) {
      if (code < 48) { return code === 36 }
      if (code < 58) { return true }
      if (code < 65) { return false }
      if (code < 91) { return true }
      if (code < 97) { return code === 95 }
      if (code < 123) { return true }
      if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
      if (astral === false) { return false }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
    }
    
    // ## Token types
    
    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.
    
    // All token type variables start with an underscore, to make them
    // easy to recognize.
    
    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.
    
    var TokenType = function TokenType(label, conf) {
      if ( conf === void 0 ) conf = {};
    
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    
    function binop(name, prec) {
      return new TokenType(name, {beforeExpr: true, binop: prec})
    }
    var beforeExpr = {beforeExpr: true};
    var startsExpr = {startsExpr: true};
    
    // Map keyword names to token types.
    
    var keywords$1 = {};
    
    // Succinct definitions of keyword token types
    function kw(name, options) {
      if ( options === void 0 ) options = {};
    
      options.keyword = name;
      return keywords$1[name] = new TokenType(name, options)
    }
    
    var types = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      eof: new TokenType("eof"),
    
      // Punctuation token types.
      bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),
    
      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.
    
      eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
      assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
      incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
      prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", {beforeExpr: true}),
    
      // Keyword token types.
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", {isLoop: true, beforeExpr: true}),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", {isLoop: true}),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", {isLoop: true}),
      _with: kw("with"),
      _new: kw("new", {beforeExpr: true, startsExpr: true}),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import"),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", {beforeExpr: true, binop: 7}),
      _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
      _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
      _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
      _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
    };
    
    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.
    
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    
    function isNewLine(code) {
      return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
    }
    
    var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    
    var ref = Object.prototype;
    var hasOwnProperty = ref.hasOwnProperty;
    var toString = ref.toString;
    
    // Checks if an object has a property.
    
    function has(obj, propName) {
      return hasOwnProperty.call(obj, propName)
    }
    
    var isArray = Array.isArray || (function (obj) { return (
      toString.call(obj) === "[object Array]"
    ); });
    
    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.
    
    var Position = function Position(line, col) {
      this.line = line;
      this.column = col;
    };
    
    Position.prototype.offset = function offset (n) {
      return new Position(this.line, this.column + n)
    };
    
    var SourceLocation = function SourceLocation(p, start, end) {
      this.start = start;
      this.end = end;
      if (p.sourceFile !== null) { this.source = p.sourceFile; }
    };
    
    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.
    
    function getLineInfo(input, offset) {
      for (var line = 1, cur = 0;;) {
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
          ++line;
          cur = match.index + match[0].length;
        } else {
          return new Position(line, offset - cur)
        }
      }
    }
    
    // A second optional argument can be given to further configure
    // the parser process. These options are recognized:
    
    var defaultOptions = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must
      // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
      // for strict mode, the set of reserved words, and support for
      // new syntax features. The default is 7.
      ecmaVersion: 7,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called
      // when a semicolon is automatically inserted. It will be passed
      // th position of the comma as an offset, and if `locations` is
      // enabled, it is given the location as a `{line, column}` object
      // as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program.
      allowImportExportEverywhere: false,
      // When enabled, hashbang directive in the beginning of file
      // is allowed and treated as a line comment.
      allowHashBang: false,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callback—that will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callback—that will corrupt its internal state.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false,
      plugins: {}
    };
    
    // Interpret and default an options object
    
    function getOptions(opts) {
      var options = {};
    
      for (var opt in defaultOptions)
        { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }
    
      if (options.ecmaVersion >= 2015)
        { options.ecmaVersion -= 2009; }
    
      if (options.allowReserved == null)
        { options.allowReserved = options.ecmaVersion < 5; }
    
      if (isArray(options.onToken)) {
        var tokens = options.onToken;
        options.onToken = function (token) { return tokens.push(token); };
      }
      if (isArray(options.onComment))
        { options.onComment = pushComment(options, options.onComment); }
    
      return options
    }
    
    function pushComment(options, array) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        if (options.locations)
          { comment.loc = new SourceLocation(this, startLoc, endLoc); }
        if (options.ranges)
          { comment.range = [start, end]; }
        array.push(comment);
      }
    }
    
    // Registered plugins
    var plugins = {};
    
    function keywordRegexp(words) {
      return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
    }
    
    var Parser = function Parser(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
      var reserved = "";
      if (!options.allowReserved) {
        for (var v = options.ecmaVersion;; v--)
          { if (reserved = reservedWords[v]) { break } }
        if (options.sourceType == "module") { reserved += " await"; }
      }
      this.reservedWords = keywordRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = keywordRegexp(reservedStrict);
      this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
    
      // Used to signal to callers of `readWord1` whether the word
      // contained any escape sequences. This is needed because words with
      // escape sequences must not be interpreted as keywords.
      this.containsEsc = false;
    
      // Load plugins
      this.loadPlugins(options.plugins);
    
      // Set up token state
    
      // The current position of the tokenizer in the input.
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
    
      // Properties of the current token:
      // Its type
      this.type = types.eof;
      // For tokens that include more information than their type, the value
      this.value = null;
      // Its start and end offset
      this.start = this.end = this.pos;
      // And, if locations are used, the {line, column} object
      // corresponding to those offsets
      this.startLoc = this.endLoc = this.curPosition();
    
      // Position information for the previous token
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
    
      // The context stack is used to superficially track syntactic
      // context to predict whether a regular expression is allowed in a
      // given position.
      this.context = this.initialContext();
      this.exprAllowed = true;
    
      // Figure out if it's a module code.
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
    
      // Used to signify the start of a potential arrow function
      this.potentialArrowAt = -1;
    
      // Flags to track whether we are in a function, a generator, an async function.
      this.inFunction = this.inGenerator = this.inAsync = false;
      // Positions to delayed-check that yield/await does not exist in default parameters.
      this.yieldPos = this.awaitPos = 0;
      // Labels in scope.
      this.labels = [];
    
      // If enabled, skip leading hashbang line.
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
        { this.skipLineComment(2); }
    
      // Scope tracking for duplicate variable names (see scope.js)
      this.scopeStack = [];
      this.enterFunctionScope();
    };
    
    // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
    Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
    Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };
    
    Parser.prototype.extend = function extend (name, f) {
      this[name] = f(this[name]);
    };
    
    Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
        var this$1 = this;
    
      for (var name in pluginConfigs) {
        var plugin = plugins[name];
        if (!plugin) { throw new Error("Plugin '" + name + "' not found") }
        plugin(this$1, pluginConfigs[name]);
      }
    };
    
    Parser.prototype.parse = function parse () {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node)
    };
    
    var pp = Parser.prototype;
    
    // ## Parser utilities
    
    var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
    pp.strictDirective = function(start) {
      var this$1 = this;
    
      for (;;) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this$1.input)[0].length;
        var match = literal.exec(this$1.input.slice(start));
        if (!match) { return false }
        if ((match[1] || match[2]) == "use strict") { return true }
        start += match[0].length;
      }
    };
    
    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.
    
    pp.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true
      } else {
        return false
      }
    };
    
    // Tests whether parsed token is a contextual keyword.
    
    pp.isContextual = function(name) {
      return this.type === types.name && this.value === name
    };
    
    // Consumes contextual keyword if possible.
    
    pp.eatContextual = function(name) {
      return this.value === name && this.eat(types.name)
    };
    
    // Asserts that following token is given contextual keyword.
    
    pp.expectContextual = function(name) {
      if (!this.eatContextual(name)) { this.unexpected(); }
    };
    
    // Test whether a semicolon can be inserted at the current position.
    
    pp.canInsertSemicolon = function() {
      return this.type === types.eof ||
        this.type === types.braceR ||
        lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };
    
    pp.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon)
          { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
        return true
      }
    };
    
    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.
    
    pp.semicolon = function() {
      if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
    };
    
    pp.afterTrailingComma = function(tokType, notNext) {
      if (this.type == tokType) {
        if (this.options.onTrailingComma)
          { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
        if (!notNext)
          { this.next(); }
        return true
      }
    };
    
    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.
    
    pp.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    
    // Raise an unexpected token error.
    
    pp.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    
    function DestructuringErrors() {
      this.shorthandAssign =
      this.trailingComma =
      this.parenthesizedAssign =
      this.parenthesizedBind =
        -1;
    }
    
    pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) { return }
      if (refDestructuringErrors.trailingComma > -1)
        { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
    };
    
    pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;
      if (!andThrow) { return pos >= 0 }
      if (pos > -1) { this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns"); }
    };
    
    pp.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
        { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
      if (this.awaitPos)
        { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
    };
    
    pp.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression")
        { return this.isSimpleAssignTarget(expr.expression) }
      return expr.type === "Identifier" || expr.type === "MemberExpression"
    };
    
    var pp$1 = Parser.prototype;
    
    // ### Statement parsing
    
    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.
    
    pp$1.parseTopLevel = function(node) {
      var this$1 = this;
    
      var exports = {};
      if (!node.body) { node.body = []; }
      while (this.type !== types.eof) {
        var stmt = this$1.parseStatement(true, true, exports);
        node.body.push(stmt);
      }
      this.next();
      if (this.options.ecmaVersion >= 6) {
        node.sourceType = this.options.sourceType;
      }
      return this.finishNode(node, "Program")
    };
    
    var loopLabel = {kind: "loop"};
    var switchLabel = {kind: "switch"};
    
    pp$1.isLet = function() {
      if (this.type !== types.name || this.options.ecmaVersion < 6 || this.value != "let") { return false }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91 || nextCh == 123) { return true } // '{' and '['
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
        var ident = this.input.slice(next, pos);
        if (!this.isKeyword(ident)) { return true }
      }
      return false
    };
    
    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$1.isAsyncFunction = function() {
      if (this.type !== types.name || this.options.ecmaVersion < 8 || this.value != "async")
        { return false }
    
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length;
      return !lineBreak.test(this.input.slice(this.pos, next)) &&
        this.input.slice(next, next + 8) === "function" &&
        (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
    };
    
    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.
    
    pp$1.parseStatement = function(declaration, topLevel, exports) {
      var starttype = this.type, node = this.startNode(), kind;
    
      if (this.isLet()) {
        starttype = types._var;
        kind = "let";
      }
    
      // Most types of statements are recognized by the keyword they
      // start with. Many are trivial to parse, some require a bit of
      // complexity.
    
      switch (starttype) {
      case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
      case types._debugger: return this.parseDebuggerStatement(node)
      case types._do: return this.parseDoStatement(node)
      case types._for: return this.parseForStatement(node)
      case types._function:
        if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }
        return this.parseFunctionStatement(node, false)
      case types._class:
        if (!declaration) { this.unexpected(); }
        return this.parseClass(node, true)
      case types._if: return this.parseIfStatement(node)
      case types._return: return this.parseReturnStatement(node)
      case types._switch: return this.parseSwitchStatement(node)
      case types._throw: return this.parseThrowStatement(node)
      case types._try: return this.parseTryStatement(node)
      case types._const: case types._var:
        kind = kind || this.value;
        if (!declaration && kind != "var") { this.unexpected(); }
        return this.parseVarStatement(node, kind)
      case types._while: return this.parseWhileStatement(node)
      case types._with: return this.parseWithStatement(node)
      case types.braceL: return this.parseBlock()
      case types.semi: return this.parseEmptyStatement(node)
      case types._export:
      case types._import:
        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel)
            { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
          if (!this.inModule)
            { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
        }
        return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)
    
        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction() && declaration) {
          this.next();
          return this.parseFunctionStatement(node, true)
        }
    
        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
          { return this.parseLabeledStatement(node, maybeName, expr) }
        else { return this.parseExpressionStatement(node, expr) }
      }
    };
    
    pp$1.parseBreakContinueStatement = function(node, keyword) {
      var this$1 = this;
    
      var isBreak = keyword == "break";
      this.next();
      if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
      else if (this.type !== types.name) { this.unexpected(); }
      else {
        node.label = this.parseIdent();
        this.semicolon();
      }
    
      // Verify that there is an actual destination to break or
      // continue to.
      var i = 0;
      for (; i < this.labels.length; ++i) {
        var lab = this$1.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
          if (node.label && isBreak) { break }
        }
      }
      if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
    };
    
    pp$1.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement")
    };
    
    pp$1.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.labels.pop();
      this.expect(types._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6)
        { this.eat(types.semi); }
      else
        { this.semicolon(); }
      return this.finishNode(node, "DoWhileStatement")
    };
    
    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.
    
    pp$1.parseForStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      this.enterLexicalScope();
      this.expect(types.parenL);
      if (this.type === types.semi) { return this.parseFor(node, null) }
      var isLet = this.isLet();
      if (this.type === types._var || this.type === types._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
            !(kind !== "var" && init$1.declarations[0].init))
          { return this.parseForIn(node, init$1) }
        return this.parseFor(node, init$1)
      }
      var refDestructuringErrors = new DestructuringErrors;
      var init = this.parseExpression(true, refDestructuringErrors);
      if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        this.toAssignable(init);
        this.checkLVal(init);
        this.checkPatternErrors(refDestructuringErrors, true);
        return this.parseForIn(node, init)
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      return this.parseFor(node, init)
    };
    
    pp$1.parseFunctionStatement = function(node, isAsync) {
      this.next();
      return this.parseFunction(node, true, false, isAsync)
    };
    
    pp$1.isFunction = function() {
      return this.type === types._function || this.isAsyncFunction()
    };
    
    pp$1.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      // allow function declarations in branches, but only in non-strict mode
      node.consequent = this.parseStatement(!this.strict && this.isFunction());
      node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;
      return this.finishNode(node, "IfStatement")
    };
    
    pp$1.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction)
        { this.raise(this.start, "'return' outside of function"); }
      this.next();
    
      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.
    
      if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
      else { node.argument = this.parseExpression(); this.semicolon(); }
      return this.finishNode(node, "ReturnStatement")
    };
    
    pp$1.parseSwitchStatement = function(node) {
      var this$1 = this;
    
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types.braceL);
      this.labels.push(switchLabel);
      this.enterLexicalScope();
    
      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.
    
      var cur;
      for (var sawDefault = false; this.type != types.braceR;) {
        if (this$1.type === types._case || this$1.type === types._default) {
          var isCase = this$1.type === types._case;
          if (cur) { this$1.finishNode(cur, "SwitchCase"); }
          node.cases.push(cur = this$1.startNode());
          cur.consequent = [];
          this$1.next();
          if (isCase) {
            cur.test = this$1.parseExpression();
          } else {
            if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses"); }
            sawDefault = true;
            cur.test = null;
          }
          this$1.expect(types.colon);
        } else {
          if (!cur) { this$1.unexpected(); }
          cur.consequent.push(this$1.parseStatement(true));
        }
      }
      this.exitLexicalScope();
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      this.next(); // Closing brace
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement")
    };
    
    pp$1.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
        { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement")
    };
    
    // Reused empty array added for node fields that are always empty.
    
    var empty = [];
    
    pp$1.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(types.parenL);
        clause.param = this.parseBindingAtom();
        this.enterLexicalScope();
        this.checkLVal(clause.param, "let");
        this.expect(types.parenR);
        clause.body = this.parseBlock(false);
        this.exitLexicalScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer)
        { this.raise(node.start, "Missing catch or finally clause"); }
      return this.finishNode(node, "TryStatement")
    };
    
    pp$1.parseVarStatement = function(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration")
    };
    
    pp$1.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, "WhileStatement")
    };
    
    pp$1.parseWithStatement = function(node) {
      if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement(false);
      return this.finishNode(node, "WithStatement")
    };
    
    pp$1.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement")
    };
    
    pp$1.parseLabeledStatement = function(node, maybeName, expr) {
      var this$1 = this;
    
      for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)
        {
        var label = list[i$1];
    
        if (label.name === maybeName)
          { this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
      } }
      var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
      for (var i = this.labels.length - 1; i >= 0; i--) {
        var label$1 = this$1.labels[i];
        if (label$1.statementStart == node.start) {
          label$1.statementStart = this$1.start;
          label$1.kind = kind;
        } else { break }
      }
      this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
      node.body = this.parseStatement(true);
      if (node.body.type == "ClassDeclaration" ||
          node.body.type == "VariableDeclaration" && node.body.kind != "var" ||
          node.body.type == "FunctionDeclaration" && (this.strict || node.body.generator))
        { this.raiseRecoverable(node.body.start, "Invalid labeled declaration"); }
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement")
    };
    
    pp$1.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement")
    };
    
    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).
    
    pp$1.parseBlock = function(createNewLexicalScope) {
      var this$1 = this;
      if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    
      var node = this.startNode();
      node.body = [];
      this.expect(types.braceL);
      if (createNewLexicalScope) {
        this.enterLexicalScope();
      }
      while (!this.eat(types.braceR)) {
        var stmt = this$1.parseStatement(true);
        node.body.push(stmt);
      }
      if (createNewLexicalScope) {
        this.exitLexicalScope();
      }
      return this.finishNode(node, "BlockStatement")
    };
    
    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.
    
    pp$1.parseFor = function(node, init) {
      node.init = init;
      this.expect(types.semi);
      node.test = this.type === types.semi ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.type === types.parenR ? null : this.parseExpression();
      this.expect(types.parenR);
      this.exitLexicalScope();
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, "ForStatement")
    };
    
    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.
    
    pp$1.parseForIn = function(node, init) {
      var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
      this.next();
      node.left = init;
      node.right = this.parseExpression();
      this.expect(types.parenR);
      this.exitLexicalScope();
      node.body = this.parseStatement(false);
      this.labels.pop();
      return this.finishNode(node, type)
    };
    
    // Parse a list of variable declarations.
    
    pp$1.parseVar = function(node, isFor, kind) {
      var this$1 = this;
    
      node.declarations = [];
      node.kind = kind;
      for (;;) {
        var decl = this$1.startNode();
        this$1.parseVarId(decl, kind);
        if (this$1.eat(types.eq)) {
          decl.init = this$1.parseMaybeAssign(isFor);
        } else if (kind === "const" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
          this$1.unexpected();
        } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
          this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
        if (!this$1.eat(types.comma)) { break }
      }
      return node
    };
    
    pp$1.parseVarId = function(decl, kind) {
      decl.id = this.parseBindingAtom(kind);
      this.checkLVal(decl.id, kind, false);
    };
    
    // Parse a function declaration or literal (depending on the
    // `isStatement` parameter).
    
    pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6 && !isAsync)
        { node.generator = this.eat(types.star); }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }
    
      if (isStatement) {
        node.id = isStatement === "nullableID" && this.type != types.name ? null : this.parseIdent();
        if (node.id) {
          this.checkLVal(node.id, "var");
        }
      }
    
      var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
          oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
      this.inGenerator = node.generator;
      this.inAsync = node.async;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.inFunction = true;
      this.enterFunctionScope();
    
      if (!isStatement)
        { node.id = this.type == types.name ? this.parseIdent() : null; }
    
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody);
    
      this.inGenerator = oldInGen;
      this.inAsync = oldInAsync;
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.inFunction = oldInFunc;
      return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
    };
    
    pp$1.parseFunctionParams = function(node) {
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    
    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).
    
    pp$1.parseClass = function(node, isStatement) {
      var this$1 = this;
    
      this.next();
    
      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (this$1.eat(types.semi)) { continue }
        var method = this$1.startNode();
        var isGenerator = this$1.eat(types.star);
        var isAsync = false;
        var isMaybeStatic = this$1.type === types.name && this$1.value === "static";
        this$1.parsePropertyName(method);
        method.static = isMaybeStatic && this$1.type !== types.parenL;
        if (method.static) {
          if (isGenerator) { this$1.unexpected(); }
          isGenerator = this$1.eat(types.star);
          this$1.parsePropertyName(method);
        }
        if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&
            method.key.type === "Identifier" && method.key.name === "async" && this$1.type !== types.parenL &&
            !this$1.canInsertSemicolon()) {
          isAsync = true;
          this$1.parsePropertyName(method);
        }
        method.kind = "method";
        var isGetSet = false;
        if (!method.computed) {
          var key = method.key;
          if (!isGenerator && !isAsync && key.type === "Identifier" && this$1.type !== types.parenL && (key.name === "get" || key.name === "set")) {
            isGetSet = true;
            method.kind = key.name;
            key = this$1.parsePropertyName(method);
          }
          if (!method.static && (key.type === "Identifier" && key.name === "constructor" ||
              key.type === "Literal" && key.value === "constructor")) {
            if (hadConstructor) { this$1.raise(key.start, "Duplicate constructor in the same class"); }
            if (isGetSet) { this$1.raise(key.start, "Constructor can't have get/set modifier"); }
            if (isGenerator) { this$1.raise(key.start, "Constructor can't be a generator"); }
            if (isAsync) { this$1.raise(key.start, "Constructor can't be an async method"); }
            method.kind = "constructor";
            hadConstructor = true;
          }
        }
        this$1.parseClassMethod(classBody, method, isGenerator, isAsync);
        if (isGetSet) {
          var paramCount = method.kind === "get" ? 0 : 1;
          if (method.value.params.length !== paramCount) {
            var start = method.value.start;
            if (method.kind === "get")
              { this$1.raiseRecoverable(start, "getter should have no params"); }
            else
              { this$1.raiseRecoverable(start, "setter should have exactly one param"); }
          } else {
            if (method.kind === "set" && method.value.params[0].type === "RestElement")
              { this$1.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
          }
        }
      }
      node.body = this.finishNode(classBody, "ClassBody");
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
    };
    
    pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
      method.value = this.parseMethod(isGenerator, isAsync);
      classBody.body.push(this.finishNode(method, "MethodDefinition"));
    };
    
    pp$1.parseClassId = function(node, isStatement) {
      node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
    };
    
    pp$1.parseClassSuper = function(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };
    
    // Parses module export declaration.
    
    pp$1.parseExport = function(node, exports) {
      var this$1 = this;
    
      this.next();
      // export * from '...'
      if (this.eat(types.star)) {
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration")
      }
      if (this.eat(types._default)) { // export default ...
        this.checkExport(exports, "default", this.lastTokStart);
        var isAsync;
        if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) { this.next(); }
          node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
        } else if (this.type === types._class) {
          var cNode = this.startNode();
          node.declaration = this.parseClass(cNode, "nullableID");
        } else {
          node.declaration = this.parseMaybeAssign();
          this.semicolon();
        }
        return this.finishNode(node, "ExportDefaultDeclaration")
      }
      // export var|const|let|function|class ...
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseStatement(true);
        if (node.declaration.type === "VariableDeclaration")
          { this.checkVariableExport(exports, node.declaration.declarations); }
        else
          { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
        node.specifiers = [];
        node.source = null;
      } else { // export { x, y as z } [from '...']
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports);
        if (this.eatContextual("from")) {
          node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
        } else {
          // check for keywords used as local names
          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
            var spec = list[i];
    
            this$1.checkUnreserved(spec.local);
          }
    
          node.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration")
    };
    
    pp$1.checkExport = function(exports, name, pos) {
      if (!exports) { return }
      if (has(exports, name))
        { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
      exports[name] = true;
    };
    
    pp$1.checkPatternExport = function(exports, pat) {
      var this$1 = this;
    
      var type = pat.type;
      if (type == "Identifier")
        { this.checkExport(exports, pat.name, pat.start); }
      else if (type == "ObjectPattern")
        { for (var i = 0, list = pat.properties; i < list.length; i += 1)
          {
            var prop = list[i];
    
            this$1.checkPatternExport(exports, prop.value);
          } }
      else if (type == "ArrayPattern")
        { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];
    
            if (elt) { this$1.checkPatternExport(exports, elt); }
        } }
      else if (type == "AssignmentPattern")
        { this.checkPatternExport(exports, pat.left); }
      else if (type == "ParenthesizedExpression")
        { this.checkPatternExport(exports, pat.expression); }
    };
    
    pp$1.checkVariableExport = function(exports, decls) {
      var this$1 = this;
    
      if (!exports) { return }
      for (var i = 0, list = decls; i < list.length; i += 1)
        {
        var decl = list[i];
    
        this$1.checkPatternExport(exports, decl.id);
      }
    };
    
    pp$1.shouldParseExportStatement = function() {
      return this.type.keyword === "var" ||
        this.type.keyword === "const" ||
        this.type.keyword === "class" ||
        this.type.keyword === "function" ||
        this.isLet() ||
        this.isAsyncFunction()
    };
    
    // Parses a comma-separated list of module exports.
    
    pp$1.parseExportSpecifiers = function(exports) {
      var this$1 = this;
    
      var nodes = [], first = true;
      // export { x, y as z } [from '...']
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this$1.expect(types.comma);
          if (this$1.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }
    
        var node = this$1.startNode();
        node.local = this$1.parseIdent(true);
        node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
        this$1.checkExport(exports, node.exported.name, node.exported.start);
        nodes.push(this$1.finishNode(node, "ExportSpecifier"));
      }
      return nodes
    };
    
    // Parses import declaration.
    
    pp$1.parseImport = function(node) {
      this.next();
      // import '...'
      if (this.type === types.string) {
        node.specifiers = empty;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration")
    };
    
    // Parses a comma-separated list of module imports.
    
    pp$1.parseImportSpecifiers = function() {
      var this$1 = this;
    
      var nodes = [], first = true;
      if (this.type === types.name) {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLVal(node.local, "let");
        nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
        if (!this.eat(types.comma)) { return nodes }
      }
      if (this.type === types.star) {
        var node$1 = this.startNode();
        this.next();
        this.expectContextual("as");
        node$1.local = this.parseIdent();
        this.checkLVal(node$1.local, "let");
        nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
        return nodes
      }
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (!first) {
          this$1.expect(types.comma);
          if (this$1.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }
    
        var node$2 = this$1.startNode();
        node$2.imported = this$1.parseIdent(true);
        if (this$1.eatContextual("as")) {
          node$2.local = this$1.parseIdent();
        } else {
          this$1.checkUnreserved(node$2.imported);
          node$2.local = node$2.imported;
        }
        this$1.checkLVal(node$2.local, "let");
        nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
      }
      return nodes
    };
    
    var pp$2 = Parser.prototype;
    
    // Convert existing expression atom to assignable pattern
    // if possible.
    
    pp$2.toAssignable = function(node, isBinding) {
      var this$1 = this;
    
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
        case "Identifier":
          if (this.inAsync && node.name === "await")
            { this.raise(node.start, "Can not use 'await' as identifier inside an async function"); }
          break
    
        case "ObjectPattern":
        case "ArrayPattern":
          break
    
        case "ObjectExpression":
          node.type = "ObjectPattern";
          for (var i = 0, list = node.properties; i < list.length; i += 1) {
            var prop = list[i];
    
          if (prop.kind !== "init") { this$1.raise(prop.key.start, "Object pattern can't contain getter or setter"); }
            this$1.toAssignable(prop.value, isBinding);
          }
          break
    
        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, isBinding);
          break
    
        case "AssignmentExpression":
          if (node.operator === "=") {
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
            // falls through to AssignmentPattern
          } else {
            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            break
          }
    
        case "AssignmentPattern":
          break
    
        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isBinding);
          break
    
        case "MemberExpression":
          if (!isBinding) { break }
    
        default:
          this.raise(node.start, "Assigning to rvalue");
        }
      }
      return node
    };
    
    // Convert list of expression atoms to binding list.
    
    pp$2.toAssignableList = function(exprList, isBinding) {
      var this$1 = this;
    
      var end = exprList.length;
      if (end) {
        var last = exprList[end - 1];
        if (last && last.type == "RestElement") {
          --end;
        } else if (last && last.type == "SpreadElement") {
          last.type = "RestElement";
          var arg = last.argument;
          this.toAssignable(arg, isBinding);
          --end;
        }
    
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
          { this.unexpected(last.argument.start); }
      }
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt) { this$1.toAssignable(elt, isBinding); }
      }
      return exprList
    };
    
    // Parses spread element.
    
    pp$2.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement")
    };
    
    pp$2.parseRestBinding = function() {
      var node = this.startNode();
      this.next();
    
      // RestElement inside of a function parameter must be an identifier
      if (this.options.ecmaVersion === 6 && this.type !== types.name)
        { this.unexpected(); }
    
      node.argument = this.parseBindingAtom();
    
      return this.finishNode(node, "RestElement")
    };
    
    // Parses lvalue (assignable) atom.
    
    pp$2.parseBindingAtom = function() {
      if (this.options.ecmaVersion < 6) { return this.parseIdent() }
      switch (this.type) {
      case types.name:
        return this.parseIdent()
    
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")
    
      case types.braceL:
        return this.parseObj(true)
    
      default:
        this.unexpected();
      }
    };
    
    pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
      var this$1 = this;
    
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) { first = false; }
        else { this$1.expect(types.comma); }
        if (allowEmpty && this$1.type === types.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
          break
        } else if (this$1.type === types.ellipsis) {
          var rest = this$1.parseRestBinding();
          this$1.parseBindingListItem(rest);
          elts.push(rest);
          if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
          this$1.expect(close);
          break
        } else {
          var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
          this$1.parseBindingListItem(elem);
          elts.push(elem);
        }
      }
      return elts
    };
    
    pp$2.parseBindingListItem = function(param) {
      return param
    };
    
    // Parses assignment pattern around given atom if possible.
    
    pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern")
    };
    
    // Verify that a node is an lval — something that can be assigned
    // to.
    // bindingType can be either:
    // 'var' indicating that the lval creates a 'var' binding
    // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
    // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references
    
    pp$2.checkLVal = function(expr, bindingType, checkClashes) {
      var this$1 = this;
    
      switch (expr.type) {
      case "Identifier":
        if (this.strict && this.reservedWordsStrictBind.test(expr.name))
          { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
        if (checkClashes) {
          if (has(checkClashes, expr.name))
            { this.raiseRecoverable(expr.start, "Argument name clash"); }
          checkClashes[expr.name] = true;
        }
        if (bindingType && bindingType !== "none") {
          if (
            bindingType === "var" && !this.canDeclareVarName(expr.name) ||
            bindingType !== "var" && !this.canDeclareLexicalName(expr.name)
          ) {
            this.raiseRecoverable(expr.start, ("Identifier '" + (expr.name) + "' has already been declared"));
          }
          if (bindingType === "var") {
            this.declareVarName(expr.name);
          } else {
            this.declareLexicalName(expr.name);
          }
        }
        break
    
      case "MemberExpression":
        if (bindingType) { this.raiseRecoverable(expr.start, (bindingType ? "Binding" : "Assigning to") + " member expression"); }
        break
    
      case "ObjectPattern":
        for (var i = 0, list = expr.properties; i < list.length; i += 1)
          {
        var prop = list[i];
    
        this$1.checkLVal(prop.value, bindingType, checkClashes);
      }
        break
    
      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];
    
        if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }
        }
        break
    
      case "AssignmentPattern":
        this.checkLVal(expr.left, bindingType, checkClashes);
        break
    
      case "RestElement":
        this.checkLVal(expr.argument, bindingType, checkClashes);
        break
    
      case "ParenthesizedExpression":
        this.checkLVal(expr.expression, bindingType, checkClashes);
        break
    
      default:
        this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    
    // A recursive descent parser operates by defining functions for all
    // syntactic elements, and recursively calling those, each function
    // advancing the input stream and returning an AST node. Precedence
    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
    // instead of `(!x)[1]` is handled by the fact that the parser
    // function that parses unary prefix operators is called first, and
    // in turn calls the function that parses `[]` subscripts — that
    // way, it'll receive the node for `x[1]` already parsed, and wraps
    // *that* in the unary operator node.
    //
    // Acorn uses an [operator precedence parser][opp] to handle binary
    // operator precedence, because it is much more compact than using
    // the technique outlined above, which uses different, nesting
    // functions to specify precedence, for all of the ten binary
    // precedence levels that JavaScript defines.
    //
    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
    
    var pp$3 = Parser.prototype;
    
    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.
    
    pp$3.checkPropClash = function(prop, propHash) {
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
        { return }
      var key = prop.key;
      var name;
      switch (key.type) {
      case "Identifier": name = key.name; break
      case "Literal": name = String(key.value); break
      default: return
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
          propHash.proto = true;
        }
        return
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition)
          { this.raiseRecoverable(key.start, "Redefinition of property"); }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    
    // ### Expression parsing
    
    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.
    
    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).
    
    pp$3.parseExpression = function(noIn, refDestructuringErrors) {
      var this$1 = this;
    
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
      if (this.type === types.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }
        return this.finishNode(node, "SequenceExpression")
      }
      return expr
    };
    
    // Parse an assignment expression. This includes applications of
    // operators like `+=`.
    
    pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
      if (this.inGenerator && this.isContextual("yield")) { return this.parseYield() }
    
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors;
        ownDestructuringErrors = true;
      }
    
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type == types.parenL || this.type == types.name)
        { this.potentialArrowAt = this.start; }
      var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
      if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
      if (this.type.isAssign) {
        this.checkPatternErrors(refDestructuringErrors, true);
        if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        node.left = this.type === types.eq ? this.toAssignable(left) : left;
        refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
        this.checkLVal(left);
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression")
      } else {
        if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
      }
      if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
      if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
      return left
    };
    
    // Parse a ternary conditional (`?:`) operator.
    
    pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(noIn, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression")
      }
      return expr
    };
    
    // Start the precedence parser.
    
    pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      return expr.start == startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
    };
    
    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.
    
    pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.type.binop;
      if (prec != null && (!noIn || this.type !== types._in)) {
        if (prec > minPrec) {
          var logical = this.type === types.logicalOR || this.type === types.logicalAND;
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
        }
      }
      return left
    };
    
    pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
    };
    
    // Parse unary operators, both prefix and postfix.
    
    pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
      var this$1 = this;
    
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.inAsync && this.isContextual("await")) {
        expr = this.parseAwait(refDestructuringErrors);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) { this.checkLVal(node.argument); }
        else if (this.strict && node.operator === "delete" &&
                 node.argument.type === "Identifier")
          { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
        else { sawUnary = true; }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this$1.startNodeAt(startPos, startLoc);
          node$1.operator = this$1.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this$1.checkLVal(expr);
          this$1.next();
          expr = this$1.finishNode(node$1, "UpdateExpression");
        }
      }
    
      if (!sawUnary && this.eat(types.starstar))
        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
      else
        { return expr }
    };
    
    // Parse call, dot, and `[]`-subscript expressions.
    
    pp$3.parseExprSubscripts = function(refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors);
      var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
      if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
      var result = this.parseSubscripts(expr, startPos, startLoc);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
        if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
      }
      return result
    };
    
    pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
      var this$1 = this;
    
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
          this.lastTokEnd == base.end && !this.canInsertSemicolon();
      for (var computed = (void 0);;) {
        if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
          var node = this$1.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
          node.computed = !!computed;
          if (computed) { this$1.expect(types.bracketR); }
          base = this$1.finishNode(node, "MemberExpression");
        } else if (!noCalls && this$1.eat(types.parenL)) {
          var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
          this$1.yieldPos = 0;
          this$1.awaitPos = 0;
          var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
            this$1.checkPatternErrors(refDestructuringErrors, false);
            this$1.checkYieldAwaitInDefaultParams();
            this$1.yieldPos = oldYieldPos;
            this$1.awaitPos = oldAwaitPos;
            return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
          }
          this$1.checkExpressionErrors(refDestructuringErrors, true);
          this$1.yieldPos = oldYieldPos || this$1.yieldPos;
          this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
          var node$1 = this$1.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          base = this$1.finishNode(node$1, "CallExpression");
        } else if (this$1.type === types.backQuote) {
          var node$2 = this$1.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this$1.parseTemplate({isTagged: true});
          base = this$1.finishNode(node$2, "TaggedTemplateExpression");
        } else {
          return base
        }
      }
    };
    
    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.
    
    pp$3.parseExprAtom = function(refDestructuringErrors) {
      var node, canBeArrow = this.potentialArrowAt == this.start;
      switch (this.type) {
      case types._super:
        if (!this.inFunction)
          { this.raise(this.start, "'super' outside of function or class"); }
    
      case types._this:
        var type = this.type === types._this ? "ThisExpression" : "Super";
        node = this.startNode();
        this.next();
        return this.finishNode(node, type)
    
      case types.name:
        var startPos = this.start, startLoc = this.startLoc;
        var id = this.parseIdent(this.type !== types.name);
        if (this.options.ecmaVersion >= 8 && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
          { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types.arrow))
            { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name) {
            id = this.parseIdent();
            if (this.canInsertSemicolon() || !this.eat(types.arrow))
              { this.unexpected(); }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
          }
        }
        return id
    
      case types.regexp:
        var value = this.value;
        node = this.parseLiteral(value.value);
        node.regex = {pattern: value.pattern, flags: value.flags};
        return node
    
      case types.num: case types.string:
        return this.parseLiteral(this.value)
    
      case types._null: case types._true: case types._false:
        node = this.startNode();
        node.value = this.type === types._null ? null : this.type === types._true;
        node.raw = this.type.keyword;
        this.next();
        return this.finishNode(node, "Literal")
    
      case types.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
            { refDestructuringErrors.parenthesizedAssign = start; }
          if (refDestructuringErrors.parenthesizedBind < 0)
            { refDestructuringErrors.parenthesizedBind = start; }
        }
        return expr
    
      case types.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node, "ArrayExpression")
    
      case types.braceL:
        return this.parseObj(false, refDestructuringErrors)
    
      case types._function:
        node = this.startNode();
        this.next();
        return this.parseFunction(node, false)
    
      case types._class:
        return this.parseClass(this.startNode(), false)
    
      case types._new:
        return this.parseNew()
    
      case types.backQuote:
        return this.parseTemplate()
    
      default:
        this.unexpected();
      }
    };
    
    pp$3.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      this.next();
      return this.finishNode(node, "Literal")
    };
    
    pp$3.parseParenExpression = function() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val
    };
    
    pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
      var this$1 = this;
    
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
    
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types.parenR) {
          first ? first = false : this$1.expect(types.comma);
          if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
            lastIsComma = true;
            break
          } else if (this$1.type === types.ellipsis) {
            spreadStart = this$1.start;
            exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
            if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
            break
          } else {
            if (this$1.type === types.parenL && !innerParenStart) {
              innerParenStart = this$1.start;
            }
            exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
          }
        }
        var innerEndPos = this.start, innerEndLoc = this.startLoc;
        this.expect(types.parenR);
    
        if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (innerParenStart) { this.unexpected(innerParenStart); }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList)
        }
    
        if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
        if (spreadStart) { this.unexpected(spreadStart); }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
    
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
    
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression")
      } else {
        return val
      }
    };
    
    pp$3.parseParenItem = function(item) {
      return item
    };
    
    pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
    };
    
    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call — at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.
    
    var empty$1 = [];
    
    pp$3.parseNew = function() {
      var node = this.startNode();
      var meta = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
        node.meta = meta;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target")
          { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
        if (!this.inFunction)
          { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
        return this.finishNode(node, "MetaProperty")
      }
      var startPos = this.start, startLoc = this.startLoc;
      node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
      else { node.arguments = empty$1; }
      return this.finishNode(node, "NewExpression")
    };
    
    // Parse template expression.
    
    pp$3.parseTemplateElement = function(ref) {
      var isTagged = ref.isTagged;
    
      var elem = this.startNode();
      if (this.type === types.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value,
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types.backQuote;
      return this.finishNode(elem, "TemplateElement")
    };
    
    pp$3.parseTemplate = function(ref) {
      var this$1 = this;
      if ( ref === void 0 ) ref = {};
      var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;
    
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({isTagged: isTagged});
      node.quasis = [curElt];
      while (!curElt.tail) {
        this$1.expect(types.dollarBraceL);
        node.expressions.push(this$1.parseExpression());
        this$1.expect(types.braceR);
        node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral")
    };
    
    // Parse an object literal or binding pattern.
    
    pp$3.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
        (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword) &&
        !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
    };
    
    pp$3.parseObj = function(isPattern, refDestructuringErrors) {
      var this$1 = this;
    
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types.braceR)) {
        if (!first) {
          this$1.expect(types.comma);
          if (this$1.afterTrailingComma(types.braceR)) { break }
        } else { first = false; }
    
        var prop = this$1.startNode(), isGenerator = (void 0), isAsync = (void 0), startPos = (void 0), startLoc = (void 0);
        if (this$1.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this$1.start;
            startLoc = this$1.startLoc;
          }
          if (!isPattern)
            { isGenerator = this$1.eat(types.star); }
        }
        this$1.parsePropertyName(prop);
        if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && this$1.isAsyncProp(prop)) {
          isAsync = true;
          this$1.parsePropertyName(prop, refDestructuringErrors);
        } else {
          isAsync = false;
        }
        this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);
        this$1.checkPropClash(prop, propHash);
        node.properties.push(this$1.finishNode(prop, "Property"));
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
    };
    
    pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
      if ((isGenerator || isAsync) && this.type === types.colon)
        { this.unexpected(); }
    
      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
        if (isPattern) { this.unexpected(); }
        prop.kind = "init";
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
      } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set") &&
                 (this.type != types.comma && this.type != types.braceR)) {
        if (isGenerator || isAsync || isPattern) { this.unexpected(); }
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get")
            { this.raiseRecoverable(start, "getter should have no params"); }
          else
            { this.raiseRecoverable(start, "setter should have exactly one param"); }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
            { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
        }
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        this.checkUnreserved(prop.key);
        prop.kind = "init";
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else if (this.type === types.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0)
            { refDestructuringErrors.shorthandAssign = this.start; }
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
        } else {
          prop.value = prop.key;
        }
        prop.shorthand = true;
      } else { this.unexpected(); }
    };
    
    pp$3.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types.bracketR);
          return prop.key
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
    };
    
    // Initialize empty function node.
    
    pp$3.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) {
        node.generator = false;
        node.expression = false;
      }
      if (this.options.ecmaVersion >= 8)
        { node.async = false; }
    };
    
    // Parse object or class method.
    
    pp$3.parseMethod = function(isGenerator, isAsync) {
      var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
          oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
    
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6)
        { node.generator = isGenerator; }
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }
    
      this.inGenerator = node.generator;
      this.inAsync = node.async;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.inFunction = true;
      this.enterFunctionScope();
    
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false);
    
      this.inGenerator = oldInGen;
      this.inAsync = oldInAsync;
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.inFunction = oldInFunc;
      return this.finishNode(node, "FunctionExpression")
    };
    
    // Parse arrow function expression with given parameters.
    
    pp$3.parseArrowExpression = function(node, params, isAsync) {
      var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
          oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
    
      this.enterFunctionScope();
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8)
        { node.async = !!isAsync; }
    
      this.inGenerator = false;
      this.inAsync = node.async;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.inFunction = true;
    
      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true);
    
      this.inGenerator = oldInGen;
      this.inAsync = oldInAsync;
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.inFunction = oldInFunc;
      return this.finishNode(node, "ArrowFunctionExpression")
    };
    
    // Parse function body and check parameters.
    
    pp$3.parseFunctionBody = function(node, isArrowFunction) {
      var isExpression = isArrowFunction && this.type !== types.braceL;
      var oldStrict = this.strict, useStrict = false;
    
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          // If this is a strict mode function, verify that argument names
          // are not repeated, and it does not try to bind the words `eval`
          // or `arguments`.
          if (useStrict && nonSimple)
            { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
        }
        // Start a new scope with regard to labels and the `inFunction`
        // flag (restore them to their old value afterwards).
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) { this.strict = true; }
    
        // Add the params to varDeclaredNames to ensure that an error is thrown
        // if a let/const declaration in the function clashes with one of the params.
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
        node.body = this.parseBlock(false);
        node.expression = false;
        this.labels = oldLabels;
      }
      this.exitFunctionScope();
    
      if (this.strict && node.id) {
        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
        this.checkLVal(node.id, "none");
      }
      this.strict = oldStrict;
    };
    
    pp$3.isSimpleParamList = function(params) {
      for (var i = 0, list = params; i < list.length; i += 1)
        {
        var param = list[i];
    
        if (param.type !== "Identifier") { return false
      } }
      return true
    };
    
    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.
    
    pp$3.checkParams = function(node, allowDuplicates) {
      var this$1 = this;
    
      var nameHash = {};
      for (var i = 0, list = node.params; i < list.length; i += 1)
        {
        var param = list[i];
    
        this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
      }
    };
    
    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).
    
    pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var this$1 = this;
    
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this$1.expect(types.comma);
          if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }
        } else { first = false; }
    
        var elt = (void 0);
        if (allowEmpty && this$1.type === types.comma)
          { elt = null; }
        else if (this$1.type === types.ellipsis) {
          elt = this$1.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)
            { refDestructuringErrors.trailingComma = this$1.start; }
        } else {
          elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts
    };
    
    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.
    
    pp$3.checkUnreserved = function(ref) {
      var start = ref.start;
      var end = ref.end;
      var name = ref.name;
    
      if (this.inGenerator && name === "yield")
        { this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator"); }
      if (this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function"); }
      if (this.isKeyword(name))
        { this.raise(start, ("Unexpected keyword '" + name + "'")); }
      if (this.options.ecmaVersion < 6 &&
        this.input.slice(start, end).indexOf("\\") != -1) { return }
      var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re.test(name))
        { this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved")); }
    };
    
    pp$3.parseIdent = function(liberal, isBinding) {
      var node = this.startNode();
      if (liberal && this.options.allowReserved == "never") { liberal = false; }
      if (this.type === types.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node, "Identifier");
      if (!liberal) { this.checkUnreserved(node); }
      return node
    };
    
    // Parses yield expression inside generator.
    
    pp$3.parseYield = function() {
      if (!this.yieldPos) { this.yieldPos = this.start; }
    
      var node = this.startNode();
      this.next();
      if (this.type == types.semi || this.canInsertSemicolon() || (this.type != types.star && !this.type.startsExpr)) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign();
      }
      return this.finishNode(node, "YieldExpression")
    };
    
    pp$3.parseAwait = function() {
      if (!this.awaitPos) { this.awaitPos = this.start; }
    
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      return this.finishNode(node, "AwaitExpression")
    };
    
    var pp$4 = Parser.prototype;
    
    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.
    
    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
      throw err
    };
    
    pp$4.raiseRecoverable = pp$4.raise;
    
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart)
      }
    };
    
    var pp$5 = Parser.prototype;
    
    // Object.assign polyfill
    var assign = Object.assign || function(target) {
      var sources = [], len = arguments.length - 1;
      while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];
    
      for (var i = 0, list = sources; i < list.length; i += 1) {
        var source = list[i];
    
        for (var key in source) {
          if (has(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target
    };
    
    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
    
    pp$5.enterFunctionScope = function() {
      // var: a hash of var-declared names in the current lexical scope
      // lexical: a hash of lexically-declared names in the current lexical scope
      // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
      // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
      this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});
    };
    
    pp$5.exitFunctionScope = function() {
      this.scopeStack.pop();
    };
    
    pp$5.enterLexicalScope = function() {
      var parentScope = this.scopeStack[this.scopeStack.length - 1];
      var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};
    
      this.scopeStack.push(childScope);
      assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
    };
    
    pp$5.exitLexicalScope = function() {
      var childScope = this.scopeStack.pop();
      var parentScope = this.scopeStack[this.scopeStack.length - 1];
    
      assign(parentScope.childVar, childScope.var, childScope.childVar);
    };
    
    /**
     * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
     * in the current lexical scope or any of the parent lexical scopes in this function.
     */
    pp$5.canDeclareVarName = function(name) {
      var currentScope = this.scopeStack[this.scopeStack.length - 1];
    
      return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)
    };
    
    /**
     * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
     * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
     * any child lexical scopes in this function.
     */
    pp$5.canDeclareLexicalName = function(name) {
      var currentScope = this.scopeStack[this.scopeStack.length - 1];
    
      return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)
    };
    
    pp$5.declareVarName = function(name) {
      this.scopeStack[this.scopeStack.length - 1].var[name] = true;
    };
    
    pp$5.declareLexicalName = function(name) {
      this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
    };
    
    var Node = function Node(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations)
        { this.loc = new SourceLocation(parser, loc); }
      if (parser.options.directSourceFile)
        { this.sourceFile = parser.options.directSourceFile; }
      if (parser.options.ranges)
        { this.range = [pos, 0]; }
    };
    
    // Start an AST node, attaching a start offset.
    
    var pp$6 = Parser.prototype;
    
    pp$6.startNode = function() {
      return new Node(this, this.start, this.startLoc)
    };
    
    pp$6.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc)
    };
    
    // Finish an AST node, adding `type` and `end` properties.
    
    function finishNodeAt(node, type, pos, loc) {
      node.type = type;
      node.end = pos;
      if (this.options.locations)
        { node.loc.end = loc; }
      if (this.options.ranges)
        { node.range[1] = pos; }
      return node
    }
    
    pp$6.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
    };
    
    // Finish node at given position
    
    pp$6.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc)
    };
    
    // The algorithm used to determine whether a regexp can appear at a
    // given point in the program is loosely based on sweet.js' approach.
    // See https://github.com/mozilla/sweet.js/wiki/design
    
    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    
    var types$1 = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    
    var pp$7 = Parser.prototype;
    
    pp$7.initialContext = function() {
      return [types$1.b_stat]
    };
    
    pp$7.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types$1.f_expr || parent === types$1.f_stat)
        { return true }
      if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
        { return !parent.isExpr }
    
      // The check for `tt.name && exprAllowed` detects whether we are
      // after a `yield` or `of` construct. See the `updateContext` for
      // `tt.name`.
      if (prevType === types._return || prevType == types.name && this.exprAllowed)
        { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow)
        { return true }
      if (prevType == types.braceL)
        { return parent === types$1.b_stat }
      if (prevType == types._var || prevType == types.name)
        { return false }
      return !this.exprAllowed
    };
    
    pp$7.inGeneratorContext = function() {
      var this$1 = this;
    
      for (var i = this.context.length - 1; i >= 1; i--) {
        var context = this$1.context[i];
        if (context.token === "function")
          { return context.generator }
      }
      return false
    };
    
    pp$7.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType == types.dot)
        { this.exprAllowed = false; }
      else if (update = type.updateContext)
        { update.call(this, prevType); }
      else
        { this.exprAllowed = type.beforeExpr; }
    };
    
    // Token-specific context update code
    
    types.parenR.updateContext = types.braceR.updateContext = function() {
      if (this.context.length == 1) {
        this.exprAllowed = true;
        return
      }
      var out = this.context.pop();
      if (out === types$1.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    
    types.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
      this.exprAllowed = true;
    };
    
    types.dollarBraceL.updateContext = function() {
      this.context.push(types$1.b_tmpl);
      this.exprAllowed = true;
    };
    
    types.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
      this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
      this.exprAllowed = true;
    };
    
    types.incDec.updateContext = function() {
      // tokExprAllowed stays unchanged
    };
    
    types._function.updateContext = types._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
          !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
        { this.context.push(types$1.f_expr); }
      else
        { this.context.push(types$1.f_stat); }
      this.exprAllowed = false;
    };
    
    types.backQuote.updateContext = function() {
      if (this.curContext() === types$1.q_tmpl)
        { this.context.pop(); }
      else
        { this.context.push(types$1.q_tmpl); }
      this.exprAllowed = false;
    };
    
    types.star.updateContext = function(prevType) {
      if (prevType == types._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types$1.f_expr)
          { this.context[index] = types$1.f_expr_gen; }
        else
          { this.context[index] = types$1.f_gen; }
      }
      this.exprAllowed = true;
    };
    
    types.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6) {
        if (this.value == "of" && !this.exprAllowed ||
            this.value == "yield" && this.inGeneratorContext())
          { allowed = true; }
      }
      this.exprAllowed = allowed;
    };
    
    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.
    
    var Token = function Token(p) {
      this.type = p.type;
      this.value = p.value;
      this.start = p.start;
      this.end = p.end;
      if (p.options.locations)
        { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
      if (p.options.ranges)
        { this.range = [p.start, p.end]; }
    };
    
    // ## Tokenizer
    
    var pp$8 = Parser.prototype;
    
    // Are we running under Rhino?
    var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
    
    // Move to the next token
    
    pp$8.next = function() {
      if (this.options.onToken)
        { this.options.onToken(new Token(this)); }
    
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    
    pp$8.getToken = function() {
      this.next();
      return new Token(this)
    };
    
    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined")
      { pp$8[Symbol.iterator] = function() {
        var this$1 = this;
    
        return {
          next: function () {
            var token = this$1.getToken();
            return {
              done: token.type === types.eof,
              value: token
            }
          }
        }
      }; }
    
    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).
    
    pp$8.curContext = function() {
      return this.context[this.context.length - 1]
    };
    
    // Read a single token, updating the parser object's token-related
    // properties.
    
    pp$8.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }
    
      this.start = this.pos;
      if (this.options.locations) { this.startLoc = this.curPosition(); }
      if (this.pos >= this.input.length) { return this.finishToken(types.eof) }
    
      if (curContext.override) { return curContext.override(this) }
      else { this.readToken(this.fullCharCodeAtPos()); }
    };
    
    pp$8.readToken = function(code) {
      // Identifier or keyword. '\uXXXX' sequences are allowed in
      // identifiers, so '\' also dispatches to that.
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
        { return this.readWord() }
    
      return this.getTokenFromCode(code)
    };
    
    pp$8.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 0xd7ff || code >= 0xe000) { return code }
      var next = this.input.charCodeAt(this.pos + 1);
      return (code << 10) + next - 0x35fdc00
    };
    
    pp$8.skipBlockComment = function() {
      var this$1 = this;
    
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
      this.pos = end + 2;
      if (this.options.locations) {
        lineBreakG.lastIndex = start;
        var match;
        while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
          ++this$1.curLine;
          this$1.lineStart = match.index + match[0].length;
        }
      }
      if (this.options.onComment)
        { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                               startLoc, this.curPosition()); }
    };
    
    pp$8.skipLineComment = function(startSkip) {
      var this$1 = this;
    
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this$1.input.charCodeAt(++this$1.pos);
      }
      if (this.options.onComment)
        { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                               startLoc, this.curPosition()); }
    };
    
    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.
    
    pp$8.skipSpace = function() {
      var this$1 = this;
    
      loop: while (this.pos < this.input.length) {
        var ch = this$1.input.charCodeAt(this$1.pos);
        switch (ch) {
        case 32: case 160: // ' '
          ++this$1.pos;
          break
        case 13:
          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
            ++this$1.pos;
          }
        case 10: case 8232: case 8233:
          ++this$1.pos;
          if (this$1.options.locations) {
            ++this$1.curLine;
            this$1.lineStart = this$1.pos;
          }
          break
        case 47: // '/'
          switch (this$1.input.charCodeAt(this$1.pos + 1)) {
          case 42: // '*'
            this$1.skipBlockComment();
            break
          case 47:
            this$1.skipLineComment(2);
            break
          default:
            break loop
          }
          break
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this$1.pos;
          } else {
            break loop
          }
        }
      }
    };
    
    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.
    
    pp$8.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) { this.endLoc = this.curPosition(); }
      var prevType = this.type;
      this.type = type;
      this.value = val;
    
      this.updateContext(prevType);
    };
    
    // ### Token reading
    
    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp$8.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) { return this.readNumber(true) }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
        this.pos += 3;
        return this.finishToken(types.ellipsis)
      } else {
        ++this.pos;
        return this.finishToken(types.dot)
      }
    };
    
    pp$8.readToken_slash = function() { // '/'
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.slash, 1)
    };
    
    pp$8.readToken_mult_modulo_exp = function(code) { // '%*'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types.star : types.modulo;
    
      // exponentiation operator ** and **=
      if (this.options.ecmaVersion >= 7 && next === 42) {
        ++size;
        tokentype = types.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
    
      if (next === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(tokentype, size)
    };
    
    pp$8.readToken_pipe_amp = function(code) { // '|&'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
    };
    
    pp$8.readToken_caret = function() { // '^'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.bitwiseXOR, 1)
    };
    
    pp$8.readToken_plus_min = function(code) { // '+-'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next == 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 62 &&
            (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          // A `-->` line comment
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken()
        }
        return this.finishOp(types.incDec, 2)
      }
      if (next === 61) { return this.finishOp(types.assign, 2) }
      return this.finishOp(types.plusMin, 1)
    };
    
    pp$8.readToken_lt_gt = function(code) { // '<>'
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
        return this.finishOp(types.bitShift, size)
      }
      if (next == 33 && code == 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 45 &&
          this.input.charCodeAt(this.pos + 3) == 45) {
        // `<!--`, an XML-style comment that should be interpreted as a line comment
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken()
      }
      if (next === 61) { size = 2; }
      return this.finishOp(types.relational, size)
    };
    
    pp$8.readToken_eq_excl = function(code) { // '=!'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
        this.pos += 2;
        return this.finishToken(types.arrow)
      }
      return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
    };
    
    pp$8.getTokenFromCode = function(code) {
      switch (code) {
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
      case 46: // '.'
        return this.readToken_dot()
    
        // Punctuation tokens.
      case 40: ++this.pos; return this.finishToken(types.parenL)
      case 41: ++this.pos; return this.finishToken(types.parenR)
      case 59: ++this.pos; return this.finishToken(types.semi)
      case 44: ++this.pos; return this.finishToken(types.comma)
      case 91: ++this.pos; return this.finishToken(types.bracketL)
      case 93: ++this.pos; return this.finishToken(types.bracketR)
      case 123: ++this.pos; return this.finishToken(types.braceL)
      case 125: ++this.pos; return this.finishToken(types.braceR)
      case 58: ++this.pos; return this.finishToken(types.colon)
      case 63: ++this.pos; return this.finishToken(types.question)
    
      case 96: // '`'
        if (this.options.ecmaVersion < 6) { break }
        ++this.pos;
        return this.finishToken(types.backQuote)
    
      case 48: // '0'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
          if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
        }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
      case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
        return this.readNumber(false)
    
        // Quotes produce strings.
      case 34: case 39: // '"', "'"
        return this.readString(code)
    
        // Operators are parsed inline in tiny state machines. '=' (61) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
    
      case 47: // '/'
        return this.readToken_slash()
    
      case 37: case 42: // '%*'
        return this.readToken_mult_modulo_exp(code)
    
      case 124: case 38: // '|&'
        return this.readToken_pipe_amp(code)
    
      case 94: // '^'
        return this.readToken_caret()
    
      case 43: case 45: // '+-'
        return this.readToken_plus_min(code)
    
      case 60: case 62: // '<>'
        return this.readToken_lt_gt(code)
    
      case 61: case 33: // '=!'
        return this.readToken_eq_excl(code)
    
      case 126: // '~'
        return this.finishOp(types.prefix, 1)
      }
    
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    
    pp$8.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str)
    };
    
    // Parse a regular expression. Some context-awareness is necessary,
    // since a '/' inside a '[]' set does not end the expression.
    
    function tryCreateRegexp(src, flags, throwErrorAt, parser) {
      try {
        return new RegExp(src, flags)
      } catch (e) {
        if (throwErrorAt !== undefined) {
          if (e instanceof SyntaxError) { parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message); }
          throw e
        }
      }
    }
    
    var regexpUnicodeSupport = !!tryCreateRegexp("\uffff", "u");
    
    pp$8.readRegexp = function() {
      var this$1 = this;
    
      var escaped, inClass, start = this.pos;
      for (;;) {
        if (this$1.pos >= this$1.input.length) { this$1.raise(start, "Unterminated regular expression"); }
        var ch = this$1.input.charAt(this$1.pos);
        if (lineBreak.test(ch)) { this$1.raise(start, "Unterminated regular expression"); }
        if (!escaped) {
          if (ch === "[") { inClass = true; }
          else if (ch === "]" && inClass) { inClass = false; }
          else if (ch === "/" && !inClass) { break }
          escaped = ch === "\\";
        } else { escaped = false; }
        ++this$1.pos;
      }
      var content = this.input.slice(start, this.pos);
      ++this.pos;
      // Need to use `readWord1` because '\uXXXX' sequences are allowed
      // here (don't ask).
      var mods = this.readWord1();
      var tmp = content, tmpFlags = "";
      if (mods) {
        var validFlags = /^[gim]*$/;
        if (this.options.ecmaVersion >= 6) { validFlags = /^[gimuy]*$/; }
        if (!validFlags.test(mods)) { this.raise(start, "Invalid regular expression flag"); }
        if (mods.indexOf("u") >= 0) {
          if (regexpUnicodeSupport) {
            tmpFlags = "u";
          } else {
            // Replace each astral symbol and every Unicode escape sequence that
            // possibly represents an astral symbol or a paired surrogate with a
            // single ASCII symbol to avoid throwing on regular expressions that
            // are only valid in combination with the `/u` flag.
            // Note: replacing with the ASCII symbol `x` might cause false
            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
            // perfectly valid pattern that is equivalent to `[a-b]`, but it would
            // be replaced by `[x-b]` which throws an error.
            tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
              code = Number("0x" + code);
              if (code > 0x10FFFF) { this$1.raise(start + offset + 3, "Code point out of bounds"); }
              return "x"
            });
            tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
            tmpFlags = tmpFlags.replace("u", "");
          }
        }
      }
      // Detect invalid regular expressions.
      var value = null;
      // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
      // so don't do detection if we are running under Rhino
      if (!isRhino) {
        tryCreateRegexp(tmp, tmpFlags, start, this);
        // Get a regular expression object for this pattern-flag pair, or `null` in
        // case the current environment doesn't support the flags it uses.
        value = tryCreateRegexp(content, mods);
      }
      return this.finishToken(types.regexp, {pattern: content, flags: mods, value: value})
    };
    
    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.
    
    pp$8.readInt = function(radix, len) {
      var this$1 = this;
    
      var start = this.pos, total = 0;
      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);
        if (code >= 97) { val = code - 97 + 10; } // a
        else if (code >= 65) { val = code - 65 + 10; } // A
        else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
        else { val = Infinity; }
        if (val >= radix) { break }
        ++this$1.pos;
        total = total * radix + val;
      }
      if (this.pos === start || len != null && this.pos - start !== len) { return null }
    
      return total
    };
    
    pp$8.readRadixNumber = function(radix) {
      this.pos += 2; // 0x
      var val = this.readInt(radix);
      if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val)
    };
    
    // Read an integer, octal integer, or floating-point number.
    
    pp$8.readNumber = function(startsWithDot) {
      var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48;
      if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
      if (octal && this.pos == start + 1) { octal = false; }
      var next = this.input.charCodeAt(this.pos);
      if (next === 46 && !octal) { // '.'
        ++this.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) { // 'eE'
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) { ++this.pos; } // '+-'
        if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
        isFloat = true;
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    
      var str = this.input.slice(start, this.pos), val;
      if (isFloat) { val = parseFloat(str); }
      else if (!octal || str.length === 1) { val = parseInt(str, 10); }
      else if (this.strict) { this.raise(start, "Invalid number"); }
      else if (/[89]/.test(str)) { val = parseInt(str, 10); }
      else { val = parseInt(str, 8); }
      return this.finishToken(types.num, val)
    };
    
    // Read a string value, interpreting backslash-escapes.
    
    pp$8.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;
    
      if (ch === 123) { // '{'
        if (this.options.ecmaVersion < 6) { this.unexpected(); }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
      } else {
        code = this.readHexChar(4);
      }
      return code
    };
    
    function codePointToString(code) {
      // UTF-16 Decoding
      if (code <= 0xFFFF) { return String.fromCharCode(code) }
      code -= 0x10000;
      return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
    }
    
    pp$8.readString = function(quote) {
      var this$1 = this;
    
      var out = "", chunkStart = ++this.pos;
      for (;;) {
        if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated string constant"); }
        var ch = this$1.input.charCodeAt(this$1.pos);
        if (ch === quote) { break }
        if (ch === 92) { // '\'
          out += this$1.input.slice(chunkStart, this$1.pos);
          out += this$1.readEscapedChar(false);
          chunkStart = this$1.pos;
        } else {
          if (isNewLine(ch)) { this$1.raise(this$1.start, "Unterminated string constant"); }
          ++this$1.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types.string, out)
    };
    
    // Reads template string tokens.
    
    var INVALID_TEMPLATE_ESCAPE_ERROR = {};
    
    pp$8.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err
        }
      }
    
      this.inTemplateElement = false;
    };
    
    pp$8.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR
      } else {
        this.raise(position, message);
      }
    };
    
    pp$8.readTmplToken = function() {
      var this$1 = this;
    
      var out = "", chunkStart = this.pos;
      for (;;) {
        if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated template"); }
        var ch = this$1.input.charCodeAt(this$1.pos);
        if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
          if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
            if (ch === 36) {
              this$1.pos += 2;
              return this$1.finishToken(types.dollarBraceL)
            } else {
              ++this$1.pos;
              return this$1.finishToken(types.backQuote)
            }
          }
          out += this$1.input.slice(chunkStart, this$1.pos);
          return this$1.finishToken(types.template, out)
        }
        if (ch === 92) { // '\'
          out += this$1.input.slice(chunkStart, this$1.pos);
          out += this$1.readEscapedChar(true);
          chunkStart = this$1.pos;
        } else if (isNewLine(ch)) {
          out += this$1.input.slice(chunkStart, this$1.pos);
          ++this$1.pos;
          switch (ch) {
          case 13:
            if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }
          case 10:
            out += "\n";
            break
          default:
            out += String.fromCharCode(ch);
            break
          }
          if (this$1.options.locations) {
            ++this$1.curLine;
            this$1.lineStart = this$1.pos;
          }
          chunkStart = this$1.pos;
        } else {
          ++this$1.pos;
        }
      }
    };
    
    // Reads a template token to search for the end, without validating any escape sequences
    pp$8.readInvalidTemplateToken = function() {
      var this$1 = this;
    
      for (; this.pos < this.input.length; this.pos++) {
        switch (this$1.input[this$1.pos]) {
        case "\\":
          ++this$1.pos;
          break
    
        case "$":
          if (this$1.input[this$1.pos + 1] !== "{") {
            break
          }
        // falls through
    
        case "`":
          return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))
    
        // no default
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    
    // Used to read escaped characters
    
    pp$8.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
      case 110: return "\n" // 'n' -> '\n'
      case 114: return "\r" // 'r' -> '\r'
      case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
      case 117: return codePointToString(this.readCodePoint()) // 'u'
      case 116: return "\t" // 't' -> '\t'
      case 98: return "\b" // 'b' -> '\b'
      case 118: return "\u000b" // 'v' -> '\u000b'
      case 102: return "\f" // 'f' -> '\f'
      case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
      case 10: // ' \n'
        if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
        return ""
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octalStr !== "0" && (this.strict || inTemplate)) {
            this.invalidStringToken(this.pos - 2, "Octal literal in strict mode");
          }
          this.pos += octalStr.length - 1;
          return String.fromCharCode(octal)
        }
        return String.fromCharCode(ch)
      }
    };
    
    // Used to read character escape sequences ('\x', '\u', '\U').
    
    pp$8.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
      return n
    };
    
    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.
    
    pp$8.readWord1 = function() {
      var this$1 = this;
    
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this$1.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this$1.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) { // "\"
          this$1.containsEsc = true;
          word += this$1.input.slice(chunkStart, this$1.pos);
          var escStart = this$1.pos;
          if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
            { this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX"); }
          ++this$1.pos;
          var esc = this$1.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
            { this$1.invalidStringToken(escStart, "Invalid Unicode escape"); }
          word += codePointToString(esc);
          chunkStart = this$1.pos;
        } else {
          break
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos)
    };
    
    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.
    
    pp$8.readWord = function() {
      var word = this.readWord1();
      var type = types.name;
      if (this.keywords.test(word)) {
        if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
        type = keywords$1[word];
      }
      return this.finishToken(type, word)
    };
    
    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
    // various contributors and released under an MIT license.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/ternjs/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/ternjs/acorn/issues
    //
    // This file defines the main parser interface. The library also comes
    // with a [error-tolerant parser][dammit] and an
    // [abstract syntax tree walker][walk], defined in other files.
    //
    // [dammit]: acorn_loose.js
    // [walk]: util/walk.js
    
    var version = "5.1.2";
    
    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and
    // returns an abstract syntax tree as specified by [Mozilla parser
    // API][api].
    //
    // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
    
    function parse(input, options) {
      return new Parser(options, input).parse()
    }
    
    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.
    
    function parseExpressionAt(input, pos, options) {
      var p = new Parser(options, input, pos);
      p.nextToken();
      return p.parseExpression()
    }
    
    // Acorn is organized as a tokenizer and a recursive-descent parser.
    // The `tokenizer` export provides an interface to the tokenizer.
    
    function tokenizer(input, options) {
      return new Parser(options, input)
    }
    
    // This is a terrible kludge to support the existing, pre-ES6
    // interface where the loose parser module retroactively adds exports
    // to this module.
    var parse_dammit;
    var LooseParser;
    var pluginsLoose; // eslint-disable-line camelcase
    function addLooseExports(parse, Parser$$1, plugins$$1) {
      parse_dammit = parse; // eslint-disable-line camelcase
      LooseParser = Parser$$1;
      pluginsLoose = plugins$$1;
    }
    
    
    
    
    /***/ }),
    /* 182 */
    /***/ (function(module, exports) {
    
    /* (ignored) */
    
    /***/ }),
    /* 183 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _logoShape = __webpack_require__(82);
    
    var _logoShape2 = _interopRequireDefault(_logoShape);
    
    var _metaballizer = __webpack_require__(184);
    
    var _metaballizer2 = _interopRequireDefault(_metaballizer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var LogoShapeWebGl = function (_LogoShape) {
        _inherits(LogoShapeWebGl, _LogoShape);
    
        function LogoShapeWebGl(mesh, app) {
            _classCallCheck(this, LogoShapeWebGl);
    
            var _this = _possibleConstructorReturn(this, _LogoShape.call(this, mesh, app));
    
            _this.noMaskColor = "white";
            return _this;
        }
    
        LogoShapeWebGl.prototype.prepareMetaballizer = function prepareMetaballizer() {
            this.metaballizer = new _metaballizer2.default(this.maskContext);
            this.metaballizer.registerBalls(this.bubbles);
        };
    
        LogoShapeWebGl.prototype.appendMask = function appendMask(app) {
            this.isApplied = true;
            this.mesh.mask = this._createMask(app);
        };
    
        LogoShapeWebGl.prototype.refreshMask = function refreshMask(time) {
            this.mesh.mask.texture.update();
        };
    
        return LogoShapeWebGl;
    }(_logoShape2.default);
    
    exports.default = LogoShapeWebGl;
    
    /***/ }),
    /* 184 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _metaballizer = __webpack_require__(185);
    
    var _metaballizer2 = _interopRequireDefault(_metaballizer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    var MetaballizerWebGl = function (_Metaballizer) {
        _inherits(MetaballizerWebGl, _Metaballizer);
    
        function MetaballizerWebGl() {
            _classCallCheck(this, MetaballizerWebGl);
    
            return _possibleConstructorReturn(this, _Metaballizer.apply(this, arguments));
        }
    
        MetaballizerWebGl.prototype.render = function render() {
            // reset grid
            this.iteration++;
            this.sign = -this.sign;
            this.drawing = false;
    
            this.context.fillStyle = this.metaFill;;
            this.context.beginPath();
    
            // compute metaballs
            for (var i = 0; i < this.balls.length; i++) {
                var ball = this.balls[i];
                var next = [Math.round(ball.x / _metaballizer.step), Math.round(ball.y / _metaballizer.step), false];
    
                do {
                    // marching squares
                    next = this.marchingSquares(next);
                } while (next);
    
                if (this.drawing) {
                    // fill and close path
                    this.context.fill();
                    this.context.closePath();
                    this.context.beginPath();
                    this.drawing = false;
                }
            }
        };
    
        return MetaballizerWebGl;
    }(_metaballizer2.default);
    
    exports.default = MetaballizerWebGl;
    
    /***/ }),
    /* 185 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var Point = function () {
        function Point(x, y) {
            _classCallCheck(this, Point);
    
            this.x = x;
            this.y = y;
            this.magnitude = x * x + y * y;
            this.computed = 0;
            this.force = 0;
        }
    
        Point.prototype.add = function add(other) {
            return new Point(this.x + other.x, this.y + other.y);
        };
    
        return Point;
    }();
    
    var plx = [0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0];
    var ply = [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1];
    var mscases = [0, 3, 0, 3, 1, 3, 0, 3, 2, 2, 0, 2, 1, 1, 0];
    var ixConst = [1, 0, -1, 0, 0, 1, 0, -1, -1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1];
    var step = exports.step = 5;
    
    var Metaballizer = function () {
        function Metaballizer(context) {
            var fillColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "white";
    
            _classCallCheck(this, Metaballizer);
    
            this.context = context;
            this.metaFill = fillColor;
            this.balls = [];
    
            this.setupInnerParameters();
            this.setupGrid();
        }
    
        Metaballizer.prototype.setupInnerParameters = function setupInnerParameters() {
            this.width = this.context.canvas.width;
            this.height = this.context.canvas.height;
            this.sx = Math.floor(this.width / step);
            this.sy = Math.floor(this.height / step);
    
            this.drawing = false;
            this.iteration = 0;
            this.sign = 1;
        };
    
        Metaballizer.prototype.setupGrid = function setupGrid() {
            this.grid = [];
            var total = (this.sx + 2) * (this.sy + 2);
            for (var i = 0; i < total; i++) {
                var x = i % (this.sx + 2) * step;
                var y = Math.floor(i / (this.sx + 2)) * step;
                this.grid[i] = new Point(x, y);
            }
        };
    
        Metaballizer.prototype.registerBalls = function registerBalls(balls) {
            this.balls = balls || [];
        };
    
        Metaballizer.prototype.render = function render() {
            // reset grid
            this.iteration++;
            this.sign = -this.sign;
            this.drawing = false;
    
            this.context.fillStyle = this.metaFill;;
            this.context.fillRect(0, 0, this.height, this.width);
            this.context.globalCompositeOperation = "destination-out";
    
            this.context.beginPath();
    
            // compute metaballs
            for (var i = 0; i < this.balls.length; i++) {
                var ball = this.balls[i];
                var next = [Math.round(ball.x / step), Math.round(ball.y / step), false];
    
                do {
                    // marching squares
                    next = this.marchingSquares(next);
                } while (next);
    
                if (this.drawing) {
                    // fill and close path
                    this.context.fill();
                    this.context.closePath();
                    this.context.globalCompositeOperation = "source-over";
                    this.context.beginPath();
                    this.drawing = false;
                }
            }
        };
    
        Metaballizer.prototype.marchingSquares = function marchingSquares(next) {
            var x = next[0];
            var y = next[1];
            var pdir = next[2];
            var id = x + y * (this.sx + 2);
            if (this.grid[id].computed === this.iteration) {
                return false;
            }
            var dir,
                mscase = 0;
            // calculate neighbors force
            for (var i = 0; i < 4; i++) {
                var idx = x + ixConst[i + 12] + (y + ixConst[i + 16]) * (this.sx + 2);
                var force = this.grid[idx].force;
                if (force > 0 && this.sign < 0 || force < 0 && this.sign > 0 || !force) {
                    // compute force if it hasn't been cached early
                    force = this.computeForce(x + ixConst[i + 12], y + ixConst[i + 16], idx);
                }
                if (Math.abs(force) > 1) {
                    mscase += Math.pow(2, i);
                }
            }
            if (mscase === 15) {
                // inside of the metaball
                return [x, y - 1, false];
            } else {
                // ambiguous cases
                if (mscase === 5) {
                    dir = pdir === 2 ? 3 : 1;
                } else if (mscase === 10) {
                    dir = pdir === 3 ? 0 : 2;
                } else {
                    dir = mscases[mscase];
                    this.grid[id].computed = this.iteration;
                }
                var ix = step / (Math.abs(Math.abs(this.grid[x + plx[4 * dir + 2] + (y + ply[4 * dir + 2]) * (this.sx + 2)].force) - 1) / Math.abs(Math.abs(this.grid[x + plx[4 * dir + 3] + (y + ply[4 * dir + 3]) * (this.sx + 2)].force) - 1) + 1);
                this.context.lineTo(this.grid[x + plx[4 * dir + 0] + (y + ply[4 * dir + 0]) * (this.sx + 2)].x + ixConst[dir] * ix, this.grid[x + plx[4 * dir + 1] + (y + ply[4 * dir + 1]) * (this.sx + 2)].y + ixConst[dir + 4] * ix);
                this.drawing = true;
                // return next
                return [x + ixConst[dir + 4], y + ixConst[dir + 8], dir];
            }
        };
    
        Metaballizer.prototype.computeForce = function computeForce(x, y, idx) {
            var force = 0;
            var id = idx || x + y * (this.sx + 2);
            if (x === 0 || y === 0 || x === this.sx || y === this.sy) {
                force = 0.6 * this.sign;
            } else {
                var cell = this.grid[id];
                for (var i = 0; i < this.balls.length; i++) {
                    var ball = this.balls[i];
                    var ballX = ball.x;
                    var ballY = ball.y;
                    var ballSize = ball.radius;
                    var ballMagnitude = ballX * ballX + ballY * ballY;
                    force += ballSize * ballSize / (-2 * cell.x * ballX - 2 * cell.y * ballY + ballMagnitude + cell.magnitude);
                }
                force *= this.sign;
            }
            this.grid[id].force = force;
            return force;
        };
    
        return Metaballizer;
    }();
    
    exports.default = Metaballizer;
    
    /***/ }),
    /* 186 */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.__esModule = true;
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    var _logo = __webpack_require__(78);
    
    var _logo2 = _interopRequireDefault(_logo);
    
    var _logo3 = __webpack_require__(81);
    
    var _logo4 = _interopRequireDefault(_logo3);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var defaultTransitionDuration = 600;
    var defaultTransitionDelay = 0;
    var defaultEaseType = "";
    
    function getSize(container) {
        return Math.min(container.clientWidth, container.clientHeight);
    }
    
    function ensureContainer(placeholder) {
        if (!placeholder) {
            throw new Error("Please, provide HTML-container for the SHLogo");
        }
        if (typeof placeholder === "string") {
            return document.getElementById(placeholder);
        } else if ((typeof placeholder === "undefined" ? "undefined" : _typeof(placeholder)) === "object") {
            return placeholder;
        }
        throw new Error("Please, provide HTML container for the SHLogo");
    }
    
    var Logo = function () {
        function Logo(container, onReadyCallback) {
            _classCallCheck(this, Logo);
    
            this.app = null;
            this.container = null;
    
            this.isReady = false;
            this.isResponsive = true;
            this.supportedStates = {};
    
            this.registerBaseStates();
            this.init(container, onReadyCallback);
        }
    
        Logo.prototype.init = function init(placeholder, onReadyCallback) {
            this.container = ensureContainer(placeholder);
            var size = getSize(this.container);
            // init pixijs app
            this.app = new PIXI.Application({
                width: size,
                height: size,
                forceCanvas: false,
                transparent: true,
                backgroundColor: 0xFFFFFF
            });
            this.container.appendChild(this.app.view);
    
            var self = this;
            var logoTexture = new _logo2.default(self.app, size, function () {
                self.body = new _logo4.default(logoTexture, self.app, size);
                self.app.ticker.add(function (delta) {
                    self.update(delta);
                }, this);
                self.isReady = true;
                if (typeof onReadyCallback === "function") {
                    onReadyCallback();
                }
            });
    
            this.setupResponsive();
        };
    
        Logo.prototype.setupResponsive = function setupResponsive() {
            if (!this.isResponsive) {
                return;
            }
            var self = this;
            var callback = function callback() {
                self.resize();
            };
            if (window.attachEvent) {
                window.attachEvent("onresize", callback);
            } else if (window.addEventListener) {
                window.addEventListener("resize", callback, true);
            }
        };
    
        Logo.prototype.resize = function resize() {
            if (!this.isReady) {
                return;
            }
            var size = getSize(this.container) + "px";
            var view = this.app.renderer.view;
            view.style.width = size;
            view.style.height = size;
        };
    
        Logo.prototype.update = function update(deltaTime) {
            this.body.update(deltaTime);
        };
    
        // plugin system for Logo's stages
    
    
        Logo.prototype.defineState = function defineState(stateName, settings) {
            if (typeof stateName !== "string") {
                throw new Error("Provide a string name for a new logo's state");
            }
            if ((typeof settings === "undefined" ? "undefined" : _typeof(settings)) !== "object") {
                throw new Error("Provide settings for a new logo's state");
            }
            if (!!this.supportedStates[stateName]) {
                throw new Error("The '" + stateName + "' state has already been defined.");
            }
            this.supportedStates[stateName] = settings;
        };
    
        Logo.prototype.removeState = function removeState(stateName) {
            delete this.supportedStates[stateName];
        };
    
        Logo.prototype.applyState = function applyState(stateName) {
            var stateSettings = this.getStateSettings(stateName);
            this.body.setState(stateSettings);
        };
    
        Logo.prototype.transitTo = function transitTo(stateName, duration, delay, easeType) {
            var stateSettings = this.getStateSettings(stateName);
            this.body.transitTo(stateSettings, duration || defaultTransitionDuration, delay || defaultTransitionDelay, easeType || defaultEaseType);
        };
    
        Logo.prototype.getStateSettings = function getStateSettings(stateName) {
            if (!stateName || typeof stateName !== "string") {
                throw new Error("Please provide correct state name");
            }
            var stateSettings = this.supportedStates[stateName];
            if (!stateSettings) {
                throw new Error("The '" + stateName + "' state is undefined");
            }
            return stateSettings;
        };
    
        Logo.prototype.registerBaseStates = function registerBaseStates() {
            // todo
        };
    
        return Logo;
    }();
    
    exports.default = Logo;
    
    /***/ })
    /******/ ]);